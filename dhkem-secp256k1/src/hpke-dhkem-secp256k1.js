var cr=Object.defineProperty;var ur=(r,e)=>{for(var t in e)cr(r,t,{get:e[t],enumerable:!0})};var Ve=class extends Error{constructor(e){let t;e instanceof Error?t=e.message:typeof e=="string"?t=e:t="",super(t),this.name=this.constructor.name}},X=class extends Ve{},Q=class extends X{};var J=class extends X{},V=class extends X{},Te=class extends X{},Ne=class extends X{};var pe=class extends X{},$=class extends X{};var fr={},zt=lr(globalThis,fr);function lr(r,e){return new Proxy(r,{get(t,n,i){return n in e?e[n]:r[n]},set(t,n,i){return n in e&&delete e[n],r[n]=i,!0},deleteProperty(t,n){let i=!1;return n in e&&(delete e[n],i=!0),n in r&&(delete r[n],i=!0),i},ownKeys(t){let n=Reflect.ownKeys(r),i=Reflect.ownKeys(e),o=new Set(i);return[...n.filter(a=>!o.has(a)),...i]},defineProperty(t,n,i){return n in e&&delete e[n],Reflect.defineProperty(r,n,i),!0},getOwnPropertyDescriptor(t,n){return n in e?Reflect.getOwnPropertyDescriptor(e,n):Reflect.getOwnPropertyDescriptor(r,n)},has(t,n){return n in e||n in r}})}async function hr(){if(zt!==void 0&&globalThis.crypto!==void 0)return globalThis.crypto.subtle;try{let{webcrypto:r}=await import("crypto");return r.subtle}catch(r){throw new $(r)}}var ce=class{constructor(){Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}async _setup(){this._api===void 0&&(this._api=await hr())}};var ee={NotAssigned:0,DhkemP256HkdfSha256:16,DhkemP384HkdfSha384:17,DhkemP521HkdfSha512:18,DhkemSecp256k1HkdfSha256:19,DhkemX25519HkdfSha256:32,DhkemX448HkdfSha512:33,HybridkemX25519Kyber768:48},Re={HkdfSha256:1,HkdfSha384:2,HkdfSha512:3};var G=new Uint8Array(0);var Ye=new Uint8Array([75,69,77,0,0]);var ue=r=>typeof r=="object"&&r!==null&&typeof r.privateKey=="object"&&typeof r.publicKey=="object";function me(r,e){if(e<=0)throw new Error("i2Osp: too small size");if(r>=256**e)throw new Error("i2Osp: too large integer");let t=new Uint8Array(e);for(let n=0;n<e&&r;n++)t[e-(n+1)]=r%256,r=r>>8;return t}function ge(r,e){let t=new Uint8Array(r.length+e.length);return t.set(r,0),t.set(e,r.length),t}var yr=new Uint8Array([101,97,101,95,112,114,107]),br=new Uint8Array([115,104,97,114,101,100,95,115,101,99,114,101,116]);function wr(r,e,t){let n=new Uint8Array(r.length+e.length+t.length);return n.set(r,0),n.set(e,r.length),n.set(t,r.length+e.length),n}var xe=class{constructor(e,t,n){Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_prim",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.id=e,this._prim=t,this._kdf=n;let i=new Uint8Array(Ye);i.set(me(this.id,2),3),this._kdf.init(i)}async serializePublicKey(e){return await this._prim.serializePublicKey(e)}async deserializePublicKey(e){return await this._prim.deserializePublicKey(e)}async serializePrivateKey(e){return await this._prim.serializePrivateKey(e)}async deserializePrivateKey(e){return await this._prim.deserializePrivateKey(e)}async importKey(e,t,n=!0){return await this._prim.importKey(e,t,n)}async generateKeyPair(){return await this._prim.generateKeyPair()}async deriveKeyPair(e){if(e.byteLength>8192)throw new Q("Too long ikm");return await this._prim.deriveKeyPair(e)}async encap(e){let t;e.ekm===void 0?t=await this.generateKeyPair():ue(e.ekm)?t=e.ekm:t=await this.deriveKeyPair(e.ekm);let n=await this._prim.serializePublicKey(t.publicKey),i=await this._prim.serializePublicKey(e.recipientPublicKey);try{let o;if(e.senderKey===void 0)o=new Uint8Array(await this._prim.dh(t.privateKey,e.recipientPublicKey));else{let s=ue(e.senderKey)?e.senderKey.privateKey:e.senderKey,u=new Uint8Array(await this._prim.dh(t.privateKey,e.recipientPublicKey)),h=new Uint8Array(await this._prim.dh(s,e.recipientPublicKey));o=ge(u,h)}let a;if(e.senderKey===void 0)a=ge(new Uint8Array(n),new Uint8Array(i));else{let s=ue(e.senderKey)?e.senderKey.publicKey:await this._prim.derivePublicKey(e.senderKey),u=await this._prim.serializePublicKey(s);a=wr(new Uint8Array(n),new Uint8Array(i),new Uint8Array(u))}let c=await this._generateSharedSecret(o,a);return{enc:n,sharedSecret:c}}catch(o){throw new Te(o)}}async decap(e){let t=await this._prim.deserializePublicKey(e.enc),n=ue(e.recipientKey)?e.recipientKey.privateKey:e.recipientKey,i=ue(e.recipientKey)?e.recipientKey.publicKey:await this._prim.derivePublicKey(e.recipientKey),o=await this._prim.serializePublicKey(i);try{let a;if(e.senderPublicKey===void 0)a=new Uint8Array(await this._prim.dh(n,t));else{let s=new Uint8Array(await this._prim.dh(n,t)),u=new Uint8Array(await this._prim.dh(n,e.senderPublicKey));a=ge(s,u)}let c;if(e.senderPublicKey===void 0)c=ge(new Uint8Array(e.enc),new Uint8Array(o));else{let s=await this._prim.serializePublicKey(e.senderPublicKey);c=new Uint8Array(e.enc.byteLength+o.byteLength+s.byteLength),c.set(new Uint8Array(e.enc),0),c.set(new Uint8Array(o),e.enc.byteLength),c.set(new Uint8Array(s),e.enc.byteLength+o.byteLength)}return await this._generateSharedSecret(a,c)}catch(a){throw new Ne(a)}}async _generateSharedSecret(e,t){let n=this._kdf.buildLabeledIkm(yr,e),i=this._kdf.buildLabeledInfo(br,t,this.secretSize);return await this._kdf.extractAndExpand(G,n,i,this.secretSize)}};var ft=new Uint8Array([100,107,112,95,112,114,107]),Ht=new Uint8Array([115,107]);var Tn=new Uint8Array([99,97,110,100,105,100,97,116,101]),Nn=new Uint8Array([255,255,255,255,0,0,0,0,255,255,255,255,255,255,255,255,188,230,250,173,167,23,158,132,243,185,202,194,252,99,37,81]),Rn=new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,199,99,77,129,244,55,45,223,88,26,13,178,72,176,167,122,236,236,25,106,204,197,41,115]),jn=new Uint8Array([1,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,81,134,135,131,191,47,150,107,127,204,1,72,247,9,165,208,59,181,201,184,137,156,71,174,187,111,183,30,145,56,100,9]),Dn=new Uint8Array([48,65,2,1,0,48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7,4,39,48,37,2,1,1,4,32]),qn=new Uint8Array([48,78,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,34,4,55,48,53,2,1,1,4,48]),Cn=new Uint8Array([48,96,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,35,4,73,48,71,2,1,1,4,66]);function Tt(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`positive integer expected, not ${r}`)}function vr(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function Be(r,...e){if(!vr(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${r.length}`)}function Nt(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Tt(r.outputLen),Tt(r.blockLen)}function Ie(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Rt(r,e){Be(r);let t=e.outputLen;if(r.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var _e=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var Qe=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),Y=(r,e)=>r<<32-e|r>>>e;var si=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Er(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function je(r){return typeof r=="string"&&(r=Er(r)),Be(r),r}function jt(...r){let e=0;for(let n=0;n<r.length;n++){let i=r[n];Be(i),e+=i.length}let t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){let o=r[n];t.set(o,i),i+=o.length}return t}var Le=class{clone(){return this._cloneInto()}},ai={}.toString;function Dt(r){let e=n=>r().update(je(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function qt(r=32){if(_e&&typeof _e.getRandomValues=="function")return _e.getRandomValues(new Uint8Array(r));if(_e&&typeof _e.randomBytes=="function")return _e.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}var Je=class extends Le{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Nt(e);let n=je(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,o=new Uint8Array(i);o.set(n.length>i?e.create().update(n).digest():n);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),o.fill(0)}update(e){return Ie(this),this.iHash.update(e),this}digestInto(e){Ie(this),Be(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:n,finished:i,destroyed:o,blockLen:a,outputLen:c}=this;return e=e,e.finished=i,e.destroyed=o,e.blockLen=a,e.outputLen=c,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},De=(r,e,t)=>new Je(r,e).update(t).digest();De.create=(r,e)=>new Je(r,e);function kr(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);let i=BigInt(32),o=BigInt(4294967295),a=Number(t>>i&o),c=Number(t&o),s=n?4:0,u=n?0:4;r.setUint32(e+s,a,n),r.setUint32(e+u,c,n)}var Ct=(r,e,t)=>r&e^~r&t,Mt=(r,e,t)=>r&e^r&t^e&t,Fe=class extends Le{constructor(e,t,n,i){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Qe(this.buffer)}update(e){Ie(this);let{view:t,buffer:n,blockLen:i}=this;e=je(e);let o=e.length;for(let a=0;a<o;){let c=Math.min(i-this.pos,o-a);if(c===i){let s=Qe(e);for(;i<=o-a;a+=i)this.process(s,a);continue}n.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Ie(this),Rt(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:i,isLE:o}=this,{pos:a}=this;t[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>i-a&&(this.process(n,0),a=0);for(let d=a;d<i;d++)t[d]=0;kr(n,i-8,BigInt(this.length*8),o),this.process(n,0);let c=Qe(e),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let u=s/4,h=this.get();if(u>h.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<u;d++)c.setUint32(4*d,h[d],o)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:i,finished:o,destroyed:a,pos:c}=this;return e.length=i,e.pos=c,e.finished=o,e.destroyed=a,i%t&&e.buffer.set(n),e}};var Sr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),fe=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),le=new Uint32Array(64),lt=class extends Fe{constructor(){super(64,32,8,!1),this.A=fe[0]|0,this.B=fe[1]|0,this.C=fe[2]|0,this.D=fe[3]|0,this.E=fe[4]|0,this.F=fe[5]|0,this.G=fe[6]|0,this.H=fe[7]|0}get(){let{A:e,B:t,C:n,D:i,E:o,F:a,G:c,H:s}=this;return[e,t,n,i,o,a,c,s]}set(e,t,n,i,o,a,c,s){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=o|0,this.F=a|0,this.G=c|0,this.H=s|0}process(e,t){for(let d=0;d<16;d++,t+=4)le[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){let l=le[d-15],k=le[d-2],O=Y(l,7)^Y(l,18)^l>>>3,m=Y(k,17)^Y(k,19)^k>>>10;le[d]=m+le[d-7]+O+le[d-16]|0}let{A:n,B:i,C:o,D:a,E:c,F:s,G:u,H:h}=this;for(let d=0;d<64;d++){let l=Y(c,6)^Y(c,11)^Y(c,25),k=h+l+Ct(c,s,u)+Sr[d]+le[d]|0,m=(Y(n,2)^Y(n,13)^Y(n,22))+Mt(n,i,o)|0;h=u,u=s,s=c,c=a+k|0,a=o,o=i,i=n,n=k+m|0}n=n+this.A|0,i=i+this.B|0,o=o+this.C|0,a=a+this.D|0,c=c+this.E|0,s=s+this.F|0,u=u+this.G|0,h=h+this.H|0,this.set(n,i,o,a,c,s,u,h)}roundClean(){le.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var et=Dt(()=>new lt);var Bi=new Uint8Array([115,101,99]);var Wi=new Uint8Array([98,97,115,101,95,110,111,110,99,101]),Xi=new Uint8Array([101,120,112]),Qi=new Uint8Array([105,110,102,111,95,104,97,115,104]),Ji=new Uint8Array([107,101,121]),Fi=new Uint8Array([112,115,107,95,105,100,95,104,97,115,104]),eo=new Uint8Array([115,101,99,114,101,116]),to=new Uint8Array([72,80,75,69,0,0,0,0,0,0]);var $t=new Uint8Array([72,80,75,69,45,118,49]),dt=class extends ce{constructor(){super(),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Re.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_suiteId",{enumerable:!0,configurable:!0,writable:!0,value:G}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}init(e){this._suiteId=e}buildLabeledIkm(e,t){this._checkInit();let n=new Uint8Array(7+this._suiteId.byteLength+e.byteLength+t.byteLength);return n.set($t,0),n.set(this._suiteId,7),n.set(e,7+this._suiteId.byteLength),n.set(t,7+this._suiteId.byteLength+e.byteLength),n}buildLabeledInfo(e,t,n){this._checkInit();let i=new Uint8Array(9+this._suiteId.byteLength+e.byteLength+t.byteLength);return i.set(new Uint8Array([0,n]),0),i.set($t,2),i.set(this._suiteId,9),i.set(e,9+this._suiteId.byteLength),i.set(t,9+this._suiteId.byteLength+e.byteLength),i}async extract(e,t){if(await this._setup(),e.byteLength===0&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)throw new Q("The salt length must be the same as the hashSize");let n=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,t)}async expand(e,t,n){await this._setup();let i=await this._api.importKey("raw",e,this.algHash,!1,["sign"]),o=new ArrayBuffer(n),a=new Uint8Array(o),c=G,s=new Uint8Array(t),u=new Uint8Array(1);if(n>255*this.hashSize)throw new Error("Entropy limit reached");let h=new Uint8Array(this.hashSize+s.length+1);for(let d=1,l=0;l<a.length;d++)u[0]=d,h.set(c,0),h.set(s,c.length),h.set(u,c.length+s.length),c=new Uint8Array(await this._api.sign("HMAC",i,h.slice(0,c.length+s.length+1))),a.length-l>=c.length?(a.set(c,l),l+=c.length):(a.set(c.slice(0,a.length-l),l),l+=a.length-l);return o}async extractAndExpand(e,t,n,i){await this._setup();let o=await this._api.importKey("raw",t,"HKDF",!1,["deriveBits"]);return await this._api.deriveBits({name:"HKDF",hash:this.algHash.hash,salt:e,info:n},o,i*8)}async labeledExtract(e,t,n){return await this.extract(e,this.buildLabeledIkm(t,n))}async labeledExpand(e,t,n,i){return await this.expand(e,this.buildLabeledInfo(t,n,i),i)}_checkInit(){if(this._suiteId===G)throw new Error("Not initialized. Call init()")}},qe=class extends dt{constructor(){super(...arguments),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Re.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}};var Ce=class extends qe{};var F=class{constructor(e,t,n,i=[]){Object.defineProperty(this,"key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extractable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"algorithm",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"usages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.key=t,this.type=n,this.algorithm={name:e},this.usages=i,n==="public"&&(this.usages=[])}};var Oe=class extends Ce{async extract(e,t){if(await this._setup(),e.byteLength===0&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)return De(et,new Uint8Array(e),new Uint8Array(t));let n=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,t)}};var gt={};ur(gt,{aInRange:()=>ye,abool:()=>ve,abytes:()=>Ue,bitGet:()=>Rr,bitLen:()=>pt,bitMask:()=>$e,bitSet:()=>jr,bytesToHex:()=>Ee,bytesToNumberBE:()=>re,bytesToNumberLE:()=>rt,concatBytes:()=>ze,createHmacDrbg:()=>mt,ensureBytes:()=>q,equalBytes:()=>Tr,hexToBytes:()=>Se,hexToNumber:()=>wt,inRange:()=>Me,isBytes:()=>de,memoized:()=>it,notImplemented:()=>qr,numberToBytesBE:()=>he,numberToBytesLE:()=>nt,numberToHexUnpadded:()=>ke,numberToVarBytesBE:()=>Hr,utf8ToBytes:()=>Nr,validateObject:()=>be});var bt=BigInt(0),tt=BigInt(1),Ur=BigInt(2);function de(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function Ue(r){if(!de(r))throw new Error("Uint8Array expected")}function ve(r,e){if(typeof e!="boolean")throw new Error(`${r} must be valid boolean, got "${e}".`)}var zr=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function Ee(r){Ue(r);let e="";for(let t=0;t<r.length;t++)e+=zr[r[t]];return e}function ke(r){let e=r.toString(16);return e.length&1?`0${e}`:e}function wt(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}var te={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Gt(r){if(r>=te._0&&r<=te._9)return r-te._0;if(r>=te._A&&r<=te._F)return r-(te._A-10);if(r>=te._a&&r<=te._f)return r-(te._a-10)}function Se(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let e=r.length,t=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);let n=new Uint8Array(t);for(let i=0,o=0;i<t;i++,o+=2){let a=Gt(r.charCodeAt(o)),c=Gt(r.charCodeAt(o+1));if(a===void 0||c===void 0){let s=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+o)}n[i]=a*16+c}return n}function re(r){return wt(Ee(r))}function rt(r){return Ue(r),wt(Ee(Uint8Array.from(r).reverse()))}function he(r,e){return Se(r.toString(16).padStart(e*2,"0"))}function nt(r,e){return he(r,e).reverse()}function Hr(r){return Se(ke(r))}function q(r,e,t){let n;if(typeof e=="string")try{n=Se(e)}catch(o){throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${o}`)}else if(de(e))n=Uint8Array.from(e);else throw new Error(`${r} must be hex string or Uint8Array`);let i=n.length;if(typeof t=="number"&&i!==t)throw new Error(`${r} expected ${t} bytes, got ${i}`);return n}function ze(...r){let e=0;for(let n=0;n<r.length;n++){let i=r[n];Ue(i),e+=i.length}let t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){let o=r[n];t.set(o,i),i+=o.length}return t}function Tr(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}function Nr(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}var ht=r=>typeof r=="bigint"&&bt<=r;function Me(r,e,t){return ht(r)&&ht(e)&&ht(t)&&e<=r&&r<t}function ye(r,e,t,n){if(!Me(e,t,n))throw new Error(`expected valid ${r}: ${t} <= n < ${n}, got ${typeof e} ${e}`)}function pt(r){let e;for(e=0;r>bt;r>>=tt,e+=1);return e}function Rr(r,e){return r>>BigInt(e)&tt}function jr(r,e,t){return r|(t?tt:bt)<<BigInt(e)}var $e=r=>(Ur<<BigInt(r-1))-tt,yt=r=>new Uint8Array(r),Zt=r=>Uint8Array.from(r);function mt(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=yt(r),i=yt(r),o=0,a=()=>{n.fill(1),i.fill(0),o=0},c=(...d)=>t(i,n,...d),s=(d=yt())=>{i=c(Zt([0]),d),n=c(),d.length!==0&&(i=c(Zt([1]),d),n=c())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let d=0,l=[];for(;d<e;){n=c();let k=n.slice();l.push(k),d+=n.length}return ze(...l)};return(d,l)=>{a(),s(d);let k;for(;!(k=l(u()));)s();return a(),k}}var Dr={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||de(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function be(r,e,t={}){let n=(i,o,a)=>{let c=Dr[o];if(typeof c!="function")throw new Error(`Invalid validator "${o}", expected function`);let s=r[i];if(!(a&&s===void 0)&&!c(s,r))throw new Error(`Invalid param ${String(i)}=${s} (${typeof s}), expected ${o}`)};for(let[i,o]of Object.entries(e))n(i,o,!1);for(let[i,o]of Object.entries(t))n(i,o,!0);return r}var qr=()=>{throw new Error("not implemented")};function it(r){let e=new WeakMap;return(t,...n)=>{let i=e.get(t);if(i!==void 0)return i;let o=r(t,...n);return e.set(t,o),o}}var z=BigInt(0),U=BigInt(1),Pe=BigInt(2),Cr=BigInt(3),xt=BigInt(4),Vt=BigInt(5),Yt=BigInt(8),Mr=BigInt(9),$r=BigInt(16);function N(r,e){let t=r%e;return t>=z?t:e+t}function Gr(r,e,t){if(t<=z||e<z)throw new Error("Expected power/modulo > 0");if(t===U)return z;let n=U;for(;e>z;)e&U&&(n=n*r%t),r=r*r%t,e>>=U;return n}function C(r,e,t){let n=r;for(;e-- >z;)n*=n,n%=t;return n}function ot(r,e){if(r===z||e<=z)throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);let t=N(r,e),n=e,i=z,o=U,a=U,c=z;for(;t!==z;){let u=n/t,h=n%t,d=i-a*u,l=o-c*u;n=t,t=h,i=a,o=c,a=d,c=l}if(n!==U)throw new Error("invert: does not exist");return N(i,e)}function Zr(r){let e=(r-U)/Pe,t,n,i;for(t=r-U,n=0;t%Pe===z;t/=Pe,n++);for(i=Pe;i<r&&Gr(i,e,r)!==r-U;i++);if(n===1){let a=(r+U)/xt;return function(s,u){let h=s.pow(u,a);if(!s.eql(s.sqr(h),u))throw new Error("Cannot find square root");return h}}let o=(t+U)/Pe;return function(c,s){if(c.pow(s,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let u=n,h=c.pow(c.mul(c.ONE,i),t),d=c.pow(s,o),l=c.pow(s,t);for(;!c.eql(l,c.ONE);){if(c.eql(l,c.ZERO))return c.ZERO;let k=1;for(let m=c.sqr(l);k<u&&!c.eql(m,c.ONE);k++)m=c.sqr(m);let O=c.pow(h,U<<BigInt(u-k-1));h=c.sqr(O),d=c.mul(d,O),l=c.mul(l,h),u=k}return d}}function Vr(r){if(r%xt===Cr){let e=(r+U)/xt;return function(n,i){let o=n.pow(i,e);if(!n.eql(n.sqr(o),i))throw new Error("Cannot find square root");return o}}if(r%Yt===Vt){let e=(r-Vt)/Yt;return function(n,i){let o=n.mul(i,Pe),a=n.pow(o,e),c=n.mul(i,a),s=n.mul(n.mul(c,Pe),a),u=n.mul(c,n.sub(s,n.ONE));if(!n.eql(n.sqr(u),i))throw new Error("Cannot find square root");return u}}return r%$r,Zr(r)}var Yr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function _t(r){let e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Yr.reduce((n,i)=>(n[i]="function",n),e);return be(r,t)}function Wr(r,e,t){if(t<z)throw new Error("Expected power > 0");if(t===z)return r.ONE;if(t===U)return e;let n=r.ONE,i=e;for(;t>z;)t&U&&(n=r.mul(n,i)),i=r.sqr(i),t>>=U;return n}function Xr(r,e){let t=new Array(e.length),n=e.reduce((o,a,c)=>r.is0(a)?o:(t[c]=o,r.mul(o,a)),r.ONE),i=r.inv(n);return e.reduceRight((o,a,c)=>r.is0(a)?o:(t[c]=r.mul(o,t[c]),r.mul(o,a)),i),t}function vt(r,e){let t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function st(r,e,t=!1,n={}){if(r<=z)throw new Error(`Expected Field ORDER > 0, got ${r}`);let{nBitLength:i,nByteLength:o}=vt(r,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");let a=Vr(r),c=Object.freeze({ORDER:r,BITS:i,BYTES:o,MASK:$e(i),ZERO:z,ONE:U,create:s=>N(s,r),isValid:s=>{if(typeof s!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof s}`);return z<=s&&s<r},is0:s=>s===z,isOdd:s=>(s&U)===U,neg:s=>N(-s,r),eql:(s,u)=>s===u,sqr:s=>N(s*s,r),add:(s,u)=>N(s+u,r),sub:(s,u)=>N(s-u,r),mul:(s,u)=>N(s*u,r),pow:(s,u)=>Wr(c,s,u),div:(s,u)=>N(s*ot(u,r),r),sqrN:s=>s*s,addN:(s,u)=>s+u,subN:(s,u)=>s-u,mulN:(s,u)=>s*u,inv:s=>ot(s,r),sqrt:n.sqrt||(s=>a(c,s)),invertBatch:s=>Xr(c,s),cmov:(s,u,h)=>h?u:s,toBytes:s=>t?nt(s,o):he(s,o),fromBytes:s=>{if(s.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${s.length}`);return t?rt(s):re(s)}});return Object.freeze(c)}function Wt(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let e=r.toString(2).length;return Math.ceil(e/8)}function Et(r){let e=Wt(r);return e+Math.ceil(e/2)}function Xt(r,e,t=!1){let n=r.length,i=Wt(e),o=Et(e);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);let a=t?re(r):rt(r),c=N(a,e-U)+U;return t?nt(c,i):he(c,i)}var Jr=BigInt(0),kt=BigInt(1),St=new WeakMap,Qt=new WeakMap;function Jt(r,e){let t=(o,a)=>{let c=a.negate();return o?c:a},n=o=>{if(!Number.isSafeInteger(o)||o<=0||o>e)throw new Error(`Wrong window size=${o}, should be [1..${e}]`)},i=o=>{n(o);let a=Math.ceil(e/o)+1,c=2**(o-1);return{windows:a,windowSize:c}};return{constTimeNegate:t,unsafeLadder(o,a){let c=r.ZERO,s=o;for(;a>Jr;)a&kt&&(c=c.add(s)),s=s.double(),a>>=kt;return c},precomputeWindow(o,a){let{windows:c,windowSize:s}=i(a),u=[],h=o,d=h;for(let l=0;l<c;l++){d=h,u.push(d);for(let k=1;k<s;k++)d=d.add(h),u.push(d);h=d.double()}return u},wNAF(o,a,c){let{windows:s,windowSize:u}=i(o),h=r.ZERO,d=r.BASE,l=BigInt(2**o-1),k=2**o,O=BigInt(o);for(let m=0;m<s;m++){let f=m*u,b=Number(c&l);c>>=O,b>u&&(b-=k,c+=kt);let g=f,_=f+Math.abs(b)-1,E=m%2!==0,K=b<0;b===0?d=d.add(t(E,a[g])):h=h.add(t(K,a[_]))}return{p:h,f:d}},wNAFCached(o,a,c){let s=Qt.get(o)||1,u=St.get(o);return u||(u=this.precomputeWindow(o,s),s!==1&&St.set(o,c(u))),this.wNAF(s,u,a)},setWindowSize(o,a){n(a),Qt.set(o,a),St.delete(o)}}}function Ft(r,e,t,n){if(!Array.isArray(t)||!Array.isArray(n)||n.length!==t.length)throw new Error("arrays of points and scalars must have equal length");n.forEach((h,d)=>{if(!e.isValid(h))throw new Error(`wrong scalar at index ${d}`)}),t.forEach((h,d)=>{if(!(h instanceof r))throw new Error(`wrong point at index ${d}`)});let i=pt(BigInt(t.length)),o=i>12?i-3:i>4?i-2:i?2:1,a=(1<<o)-1,c=new Array(a+1).fill(r.ZERO),s=Math.floor((e.BITS-1)/o)*o,u=r.ZERO;for(let h=s;h>=0;h-=o){c.fill(r.ZERO);for(let l=0;l<n.length;l++){let k=n[l],O=Number(k>>BigInt(h)&BigInt(a));c[O]=c[O].add(t[l])}let d=r.ZERO;for(let l=c.length-1,k=r.ZERO;l>0;l--)k=k.add(c[l]),d=d.add(k);if(u=u.add(d),h!==0)for(let l=0;l<o;l++)u=u.double()}return u}function Pt(r){return _t(r.Fp),be(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...vt(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var Wo=new Uint8Array;var Xo=new Uint8Array([100,107,112,95,112,114,107]),Qo=new Uint8Array([115,107]);function er(r){r.lowS!==void 0&&ve("lowS",r.lowS),r.prehash!==void 0&&ve("prehash",r.prehash)}function en(r){let e=Pt(r);be(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:t,Fp:n,a:i}=e;if(t){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}var{bytesToNumberBE:tn,hexToBytes:rn}=gt,ne={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode:(r,e)=>{let{Err:t}=ne;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");let n=e.length/2,i=ke(n);if(i.length/2&128)throw new t("tlv.encode: long form length too big");let o=n>127?ke(i.length/2|128):"";return`${ke(r)}${o}${i}${e}`},decode(r,e){let{Err:t}=ne,n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");let i=e[n++],o=!!(i&128),a=0;if(!o)a=i;else{let s=i&127;if(!s)throw new t("tlv.decode(long): indefinite length not supported");if(s>4)throw new t("tlv.decode(long): byte length is too big");let u=e.subarray(n,n+s);if(u.length!==s)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(let h of u)a=a<<8|h;if(n+=s,a<128)throw new t("tlv.decode(long): not minimal encoding")}let c=e.subarray(n,n+a);if(c.length!==a)throw new t("tlv.decode: wrong value length");return{v:c,l:e.subarray(n+a)}}},_int:{encode(r){let{Err:e}=ne;if(r<ie)throw new e("integer: negative integers are not allowed");let t=ke(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected assertion");return t},decode(r){let{Err:e}=ne;if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return tn(r)}},toSig(r){let{Err:e,_int:t,_tlv:n}=ne,i=typeof r=="string"?rn(r):r;Ue(i);let{v:o,l:a}=n.decode(48,i);if(a.length)throw new e("Invalid signature: left bytes after parsing");let{v:c,l:s}=n.decode(2,o),{v:u,l:h}=n.decode(2,s);if(h.length)throw new e("Invalid signature: left bytes after parsing");return{r:t.decode(c),s:t.decode(u)}},hexFromSig(r){let{_tlv:e,_int:t}=ne,n=`${e.encode(2,t.encode(r.r))}${e.encode(2,t.encode(r.s))}`;return e.encode(48,n)}},ie=BigInt(0),T=BigInt(1),ls=BigInt(2),tr=BigInt(3),ds=BigInt(4);function nn(r){let e=en(r),{Fp:t}=e,n=st(e.n,e.nBitLength),i=e.toBytes||((m,f,b)=>{let g=f.toAffine();return ze(Uint8Array.from([4]),t.toBytes(g.x),t.toBytes(g.y))}),o=e.fromBytes||(m=>{let f=m.subarray(1),b=t.fromBytes(f.subarray(0,t.BYTES)),g=t.fromBytes(f.subarray(t.BYTES,2*t.BYTES));return{x:b,y:g}});function a(m){let{a:f,b}=e,g=t.sqr(m),_=t.mul(g,m);return t.add(t.add(_,t.mul(m,f)),b)}if(!t.eql(t.sqr(e.Gy),a(e.Gx)))throw new Error("bad generator point: equation left != right");function c(m){return Me(m,T,e.n)}function s(m){let{allowedPrivateKeyLengths:f,nByteLength:b,wrapPrivateKey:g,n:_}=e;if(f&&typeof m!="bigint"){if(de(m)&&(m=Ee(m)),typeof m!="string"||!f.includes(m.length))throw new Error("Invalid key");m=m.padStart(b*2,"0")}let E;try{E=typeof m=="bigint"?m:re(q("private key",m,b))}catch{throw new Error(`private key must be ${b} bytes, hex or bigint, not ${typeof m}`)}return g&&(E=N(E,_)),ye("private key",E,T,_),E}function u(m){if(!(m instanceof l))throw new Error("ProjectivePoint expected")}let h=it((m,f)=>{let{px:b,py:g,pz:_}=m;if(t.eql(_,t.ONE))return{x:b,y:g};let E=m.is0();f==null&&(f=E?t.ONE:t.inv(_));let K=t.mul(b,f),S=t.mul(g,f),x=t.mul(_,f);if(E)return{x:t.ZERO,y:t.ZERO};if(!t.eql(x,t.ONE))throw new Error("invZ was invalid");return{x:K,y:S}}),d=it(m=>{if(m.is0()){if(e.allowInfinityPoint&&!t.is0(m.py))return;throw new Error("bad point: ZERO")}let{x:f,y:b}=m.toAffine();if(!t.isValid(f)||!t.isValid(b))throw new Error("bad point: x or y not FE");let g=t.sqr(b),_=a(f);if(!t.eql(g,_))throw new Error("bad point: equation left != right");if(!m.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class l{constructor(f,b,g){if(this.px=f,this.py=b,this.pz=g,f==null||!t.isValid(f))throw new Error("x required");if(b==null||!t.isValid(b))throw new Error("y required");if(g==null||!t.isValid(g))throw new Error("z required");Object.freeze(this)}static fromAffine(f){let{x:b,y:g}=f||{};if(!f||!t.isValid(b)||!t.isValid(g))throw new Error("invalid affine point");if(f instanceof l)throw new Error("projective point not allowed");let _=E=>t.eql(E,t.ZERO);return _(b)&&_(g)?l.ZERO:new l(b,g,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){let b=t.invertBatch(f.map(g=>g.pz));return f.map((g,_)=>g.toAffine(b[_])).map(l.fromAffine)}static fromHex(f){let b=l.fromAffine(o(q("pointHex",f)));return b.assertValidity(),b}static fromPrivateKey(f){return l.BASE.multiply(s(f))}static msm(f,b){return Ft(l,n,f,b)}_setWindowSize(f){O.setWindowSize(this,f)}assertValidity(){d(this)}hasEvenY(){let{y:f}=this.toAffine();if(t.isOdd)return!t.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){u(f);let{px:b,py:g,pz:_}=this,{px:E,py:K,pz:S}=f,x=t.eql(t.mul(b,S),t.mul(E,_)),v=t.eql(t.mul(g,S),t.mul(K,_));return x&&v}negate(){return new l(this.px,t.neg(this.py),this.pz)}double(){let{a:f,b}=e,g=t.mul(b,tr),{px:_,py:E,pz:K}=this,S=t.ZERO,x=t.ZERO,v=t.ZERO,A=t.mul(_,_),M=t.mul(E,E),L=t.mul(K,K),B=t.mul(_,E);return B=t.add(B,B),v=t.mul(_,K),v=t.add(v,v),S=t.mul(f,v),x=t.mul(g,L),x=t.add(S,x),S=t.sub(M,x),x=t.add(M,x),x=t.mul(S,x),S=t.mul(B,S),v=t.mul(g,v),L=t.mul(f,L),B=t.sub(A,L),B=t.mul(f,B),B=t.add(B,v),v=t.add(A,A),A=t.add(v,A),A=t.add(A,L),A=t.mul(A,B),x=t.add(x,A),L=t.mul(E,K),L=t.add(L,L),A=t.mul(L,B),S=t.sub(S,A),v=t.mul(L,M),v=t.add(v,v),v=t.add(v,v),new l(S,x,v)}add(f){u(f);let{px:b,py:g,pz:_}=this,{px:E,py:K,pz:S}=f,x=t.ZERO,v=t.ZERO,A=t.ZERO,M=e.a,L=t.mul(e.b,tr),B=t.mul(b,E),D=t.mul(g,K),y=t.mul(_,S),w=t.add(b,g),p=t.add(E,K);w=t.mul(w,p),p=t.add(B,D),w=t.sub(w,p),p=t.add(b,_);let P=t.add(E,S);return p=t.mul(p,P),P=t.add(B,y),p=t.sub(p,P),P=t.add(g,_),x=t.add(K,S),P=t.mul(P,x),x=t.add(D,y),P=t.sub(P,x),A=t.mul(M,p),x=t.mul(L,y),A=t.add(x,A),x=t.sub(D,A),A=t.add(D,A),v=t.mul(x,A),D=t.add(B,B),D=t.add(D,B),y=t.mul(M,y),p=t.mul(L,p),D=t.add(D,y),y=t.sub(B,y),y=t.mul(M,y),p=t.add(p,y),B=t.mul(D,p),v=t.add(v,B),B=t.mul(P,p),x=t.mul(w,x),x=t.sub(x,B),B=t.mul(w,D),A=t.mul(P,A),A=t.add(A,B),new l(x,v,A)}subtract(f){return this.add(f.negate())}is0(){return this.equals(l.ZERO)}wNAF(f){return O.wNAFCached(this,f,l.normalizeZ)}multiplyUnsafe(f){ye("scalar",f,ie,e.n);let b=l.ZERO;if(f===ie)return b;if(f===T)return this;let{endo:g}=e;if(!g)return O.unsafeLadder(this,f);let{k1neg:_,k1:E,k2neg:K,k2:S}=g.splitScalar(f),x=b,v=b,A=this;for(;E>ie||S>ie;)E&T&&(x=x.add(A)),S&T&&(v=v.add(A)),A=A.double(),E>>=T,S>>=T;return _&&(x=x.negate()),K&&(v=v.negate()),v=new l(t.mul(v.px,g.beta),v.py,v.pz),x.add(v)}multiply(f){let{endo:b,n:g}=e;ye("scalar",f,T,g);let _,E;if(b){let{k1neg:K,k1:S,k2neg:x,k2:v}=b.splitScalar(f),{p:A,f:M}=this.wNAF(S),{p:L,f:B}=this.wNAF(v);A=O.constTimeNegate(K,A),L=O.constTimeNegate(x,L),L=new l(t.mul(L.px,b.beta),L.py,L.pz),_=A.add(L),E=M.add(B)}else{let{p:K,f:S}=this.wNAF(f);_=K,E=S}return l.normalizeZ([_,E])[0]}multiplyAndAddUnsafe(f,b,g){let _=l.BASE,E=(S,x)=>x===ie||x===T||!S.equals(_)?S.multiplyUnsafe(x):S.multiply(x),K=E(this,b).add(E(f,g));return K.is0()?void 0:K}toAffine(f){return h(this,f)}isTorsionFree(){let{h:f,isTorsionFree:b}=e;if(f===T)return!0;if(b)return b(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:f,clearCofactor:b}=e;return f===T?this:b?b(l,this):this.multiplyUnsafe(e.h)}toRawBytes(f=!0){return ve("isCompressed",f),this.assertValidity(),i(l,this,f)}toHex(f=!0){return ve("isCompressed",f),Ee(this.toRawBytes(f))}}l.BASE=new l(e.Gx,e.Gy,t.ONE),l.ZERO=new l(t.ZERO,t.ONE,t.ZERO);let k=e.nBitLength,O=Jt(l,e.endo?Math.ceil(k/2):k);return{CURVE:e,ProjectivePoint:l,normPrivateKeyToScalar:s,weierstrassEquation:a,isWithinCurveOrder:c}}function on(r){let e=Pt(r);return be(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function rr(r){let e=on(r),{Fp:t,n}=e,i=t.BYTES+1,o=2*t.BYTES+1;function a(y){return N(y,n)}function c(y){return ot(y,n)}let{ProjectivePoint:s,normPrivateKeyToScalar:u,weierstrassEquation:h,isWithinCurveOrder:d}=nn({...e,toBytes(y,w,p){let P=w.toAffine(),I=t.toBytes(P.x),H=ze;return ve("isCompressed",p),p?H(Uint8Array.from([w.hasEvenY()?2:3]),I):H(Uint8Array.from([4]),I,t.toBytes(P.y))},fromBytes(y){let w=y.length,p=y[0],P=y.subarray(1);if(w===i&&(p===2||p===3)){let I=re(P);if(!Me(I,T,t.ORDER))throw new Error("Point is not on curve");let H=h(I),R;try{R=t.sqrt(H)}catch(Z){let se=Z instanceof Error?": "+Z.message:"";throw new Error("Point is not on curve"+se)}let j=(R&T)===T;return(p&1)===1!==j&&(R=t.neg(R)),{x:I,y:R}}else if(w===o&&p===4){let I=t.fromBytes(P.subarray(0,t.BYTES)),H=t.fromBytes(P.subarray(t.BYTES,2*t.BYTES));return{x:I,y:H}}else throw new Error(`Point of length ${w} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}}),l=y=>Ee(he(y,e.nByteLength));function k(y){let w=n>>T;return y>w}function O(y){return k(y)?a(-y):y}let m=(y,w,p)=>re(y.slice(w,p));class f{constructor(w,p,P){this.r=w,this.s=p,this.recovery=P,this.assertValidity()}static fromCompact(w){let p=e.nByteLength;return w=q("compactSignature",w,p*2),new f(m(w,0,p),m(w,p,2*p))}static fromDER(w){let{r:p,s:P}=ne.toSig(q("DER",w));return new f(p,P)}assertValidity(){ye("r",this.r,T,n),ye("s",this.s,T,n)}addRecoveryBit(w){return new f(this.r,this.s,w)}recoverPublicKey(w){let{r:p,s:P,recovery:I}=this,H=S(q("msgHash",w));if(I==null||![0,1,2,3].includes(I))throw new Error("recovery id invalid");let R=I===2||I===3?p+e.n:p;if(R>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");let j=I&1?"03":"02",oe=s.fromHex(j+l(R)),Z=c(R),se=a(-H*Z),He=a(P*Z),ae=s.BASE.multiplyAndAddUnsafe(oe,se,He);if(!ae)throw new Error("point at infinify");return ae.assertValidity(),ae}hasHighS(){return k(this.s)}normalizeS(){return this.hasHighS()?new f(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return Se(this.toDERHex())}toDERHex(){return ne.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Se(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}let b={isValidPrivateKey(y){try{return u(y),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{let y=Et(e.n);return Xt(e.randomBytes(y),e.n)},precompute(y=8,w=s.BASE){return w._setWindowSize(y),w.multiply(BigInt(3)),w}};function g(y,w=!0){return s.fromPrivateKey(y).toRawBytes(w)}function _(y){let w=de(y),p=typeof y=="string",P=(w||p)&&y.length;return w?P===i||P===o:p?P===2*i||P===2*o:y instanceof s}function E(y,w,p=!0){if(_(y))throw new Error("first arg must be private key");if(!_(w))throw new Error("second arg must be public key");return s.fromHex(w).multiply(u(y)).toRawBytes(p)}let K=e.bits2int||function(y){let w=re(y),p=y.length*8-e.nBitLength;return p>0?w>>BigInt(p):w},S=e.bits2int_modN||function(y){return a(K(y))},x=$e(e.nBitLength);function v(y){return ye(`num < 2^${e.nBitLength}`,y,ie,x),he(y,e.nByteLength)}function A(y,w,p=M){if(["recovered","canonical"].some(we=>we in p))throw new Error("sign() legacy options not supported");let{hash:P,randomBytes:I}=e,{lowS:H,prehash:R,extraEntropy:j}=p;H==null&&(H=!0),y=q("msgHash",y),er(p),R&&(y=q("prehashed msgHash",P(y)));let oe=S(y),Z=u(w),se=[v(Z),v(oe)];if(j!=null&&j!==!1){let we=j===!0?I(t.BYTES):j;se.push(q("extraEntropy",we))}let He=ze(...se),ae=oe;function ut(we){let Ae=K(we);if(!d(Ae))return;let Lt=c(Ae),W=s.BASE.multiply(Ae).toAffine(),Ke=a(W.x);if(Ke===ie)return;let Ze=a(Lt*a(ae+Ke*Z));if(Ze===ie)return;let Ot=(W.x===Ke?0:2)|Number(W.y&T),Ut=Ze;return H&&k(Ze)&&(Ut=O(Ze),Ot^=1),new f(Ke,Ut,Ot)}return{seed:He,k2sig:ut}}let M={lowS:e.lowS,prehash:!1},L={lowS:e.lowS,prehash:!1};function B(y,w,p=M){let{seed:P,k2sig:I}=A(y,w,p),H=e;return mt(H.hash.outputLen,H.nByteLength,H.hmac)(P,I)}s.BASE._setWindowSize(8);function D(y,w,p,P=L){let I=y;if(w=q("msgHash",w),p=q("publicKey",p),"strict"in P)throw new Error("options.strict was renamed to lowS");er(P);let{lowS:H,prehash:R}=P,j,oe;try{if(typeof I=="string"||de(I))try{j=f.fromDER(I)}catch(W){if(!(W instanceof ne.Err))throw W;j=f.fromCompact(I)}else if(typeof I=="object"&&typeof I.r=="bigint"&&typeof I.s=="bigint"){let{r:W,s:Ke}=I;j=new f(W,Ke)}else throw new Error("PARSE");oe=s.fromHex(p)}catch(W){if(W.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(H&&j.hasHighS())return!1;R&&(w=e.hash(w));let{r:Z,s:se}=j,He=S(w),ae=c(se),ut=a(He*ae),we=a(Z*ae),Ae=s.BASE.multiplyAndAddUnsafe(oe,ut,we)?.toAffine();return Ae?a(Ae.x)===Z:!1}return{CURVE:e,getPublicKey:g,getSharedSecret:E,sign:B,verify:D,ProjectivePoint:s,Signature:f,utils:b}}function sn(r){return{hash:r,hmac:(e,...t)=>De(r,e,jt(...t)),randomBytes:qt}}function nr(r,e){let t=n=>rr({...r,...sn(n)});return Object.freeze({...t(e),create:t})}var sr=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ir=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),an=BigInt(1),At=BigInt(2),or=(r,e)=>(r+e/At)/e;function cn(r){let e=sr,t=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),a=BigInt(23),c=BigInt(44),s=BigInt(88),u=r*r*r%e,h=u*u*r%e,d=C(h,t,e)*h%e,l=C(d,t,e)*h%e,k=C(l,At,e)*u%e,O=C(k,i,e)*k%e,m=C(O,o,e)*O%e,f=C(m,c,e)*m%e,b=C(f,s,e)*f%e,g=C(b,c,e)*m%e,_=C(g,t,e)*h%e,E=C(_,a,e)*O%e,K=C(E,n,e)*u%e,S=C(K,At,e);if(!Kt.eql(Kt.sqr(S),r))throw new Error("Cannot find square root");return S}var Kt=st(sr,void 0,void 0,{sqrt:cn}),Ge=nr({a:BigInt(0),b:BigInt(7),Fp:Kt,n:ir,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{let e=ir,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-an*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,a=BigInt("0x100000000000000000000000000000000"),c=or(o*r,e),s=or(-n*r,e),u=N(r-c*t-s*i,e),h=N(-c*n-s*o,e),d=u>a,l=h>a;if(d&&(u=e-u),l&&(h=e-h),u>a||h>a)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:d,k1:u,k2neg:l,k2:h}}}},et),_s=BigInt(0);var vs=Ge.ProjectivePoint;var at="ECDH",ar=new Uint8Array,Bt=["deriveBits"],un=new Uint8Array([100,107,112,95,112,114,107]),fn=new Uint8Array([115,107]),ct=class{constructor(e){Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=e,this._nPk=33,this._nSk=32}async serializePublicKey(e){try{return await this._serializePublicKey(e)}catch(t){throw new J(t)}}async deserializePublicKey(e){try{return await this._importRawKey(e,!0)}catch(t){throw new V(t)}}async serializePrivateKey(e){try{return await this._serializePrivateKey(e)}catch(t){throw new J(t)}}async deserializePrivateKey(e){try{return await this._importRawKey(e,!1)}catch(t){throw new V(t)}}async importKey(e,t,n){try{if(e!=="raw")throw new Error("Unsupported format");return await this._importRawKey(t,n)}catch(i){throw new V(i)}}async generateKeyPair(){try{let e=Ge.utils.randomPrivateKey(),t=new F(at,e,"private",Bt);return{publicKey:await this.derivePublicKey(t),privateKey:t}}catch(e){throw new $(e)}}async deriveKeyPair(e){try{let t=await this._hkdf.labeledExtract(ar,un,new Uint8Array(e)),n=await this._hkdf.labeledExpand(t,fn,ar,this._nSk),i=new F(at,new Uint8Array(n),"private",Bt);return{privateKey:i,publicKey:await this.derivePublicKey(i)}}catch(t){throw new pe(t)}}async derivePublicKey(e){try{return await this._derivePublicKey(e)}catch(t){throw new V(t)}}async dh(e,t){try{return await this._dh(e,t)}catch(n){throw new J(n)}}_serializePublicKey(e){return new Promise(t=>{t(e.key.buffer)})}_serializePrivateKey(e){return new Promise(t=>{t(e.key.buffer)})}_importRawKey(e,t){return new Promise((n,i)=>{t&&e.byteLength!==this._nPk&&i(new Error("Invalid length of the key")),!t&&e.byteLength!==this._nSk&&i(new Error("Invalid length of the key")),n(new F(at,new Uint8Array(e),t?"public":"private",t?[]:Bt))})}_derivePublicKey(e){return new Promise((t,n)=>{try{let i=Ge.getPublicKey(e.key);t(new F(at,i,"public"))}catch(i){n(i)}})}_dh(e,t){return new Promise((n,i)=>{try{n(Ge.getSharedSecret(e.key,t.key).buffer)}catch(o){i(o)}})}};var It=class extends xe{constructor(){let e=new Oe;super(ee.DhkemSecp256k1HkdfSha256,new ct(e),e),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:ee.DhkemSecp256k1HkdfSha256}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:32})}};export{It as DhkemSecp256k1HkdfSha256};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
