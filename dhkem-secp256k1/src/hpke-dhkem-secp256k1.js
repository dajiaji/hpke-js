var Q=class extends Error{constructor(e){let t;e instanceof Error?t=e.message:typeof e=="string"?t=e:t="",super(t),this.name=this.constructor.name}},he=class extends Q{};var F=class extends Q{},X=class extends Q{},We=class extends Q{},Ye=class extends Q{};var Ke=class extends Q{},ee=class extends Q{};var gr={},ut=_r(globalThis,gr);function _r(r,e){return new Proxy(r,{get(t,n,i){return n in e?e[n]:r[n]},set(t,n,i){return n in e&&delete e[n],r[n]=i,!0},deleteProperty(t,n){let i=!1;return n in e&&(delete e[n],i=!0),n in r&&(delete r[n],i=!0),i},ownKeys(t){let n=Reflect.ownKeys(r),i=Reflect.ownKeys(e),s=new Set(i);return[...n.filter(a=>!s.has(a)),...i]},defineProperty(t,n,i){return n in e&&delete e[n],Reflect.defineProperty(r,n,i),!0},getOwnPropertyDescriptor(t,n){return n in e?Reflect.getOwnPropertyDescriptor(e,n):Reflect.getOwnPropertyDescriptor(r,n)},has(t,n){return n in e||n in r}})}async function vr(){if(ut!==void 0&&globalThis.crypto!==void 0)return globalThis.crypto.subtle;try{let{webcrypto:r}=await import("crypto");return r.subtle}catch(r){throw new ee(r)}}var Pe=class{constructor(){Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}async _setup(){this._api===void 0&&(this._api=await vr())}};var ae={NotAssigned:0,DhkemP256HkdfSha256:16,DhkemP384HkdfSha384:17,DhkemP521HkdfSha512:18,DhkemSecp256k1HkdfSha256:19,DhkemX25519HkdfSha256:32,DhkemX448HkdfSha512:33,HybridkemX25519Kyber768:48,MlKem512:64,MlKem768:65,MlKem1024:66,XWing:25722},Xe={HkdfSha256:1,HkdfSha384:2,HkdfSha512:3};var G=new Uint8Array(0);var $e=new Uint8Array([75,69,77,0,0]);var ce=r=>typeof r=="object"&&r!==null&&typeof r.privateKey=="object"&&typeof r.publicKey=="object";function Ne(r,e){if(e<=0)throw new Error("i2Osp: too small size");if(r>=256**e)throw new Error("i2Osp: too large integer");let t=new Uint8Array(e);for(let n=0;n<e&&r;n++)t[e-(n+1)]=r%256,r=r>>8;return t}function de(r,e){let t=new Uint8Array(r.length+e.length);return t.set(r,0),t.set(e,r.length),t}var Er=new Uint8Array([101,97,101,95,112,114,107]),Ar=new Uint8Array([115,104,97,114,101,100,95,115,101,99,114,101,116]);function Sr(r,e,t){let n=new Uint8Array(r.length+e.length+t.length);return n.set(r,0),n.set(e,r.length),n.set(t,r.length+e.length),n}var Be=class{constructor(e,t,n){Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_prim",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.id=e,this._prim=t,this._kdf=n;let i=new Uint8Array($e);i.set(Ne(this.id,2),3),this._kdf.init(i)}async serializePublicKey(e){return await this._prim.serializePublicKey(e)}async deserializePublicKey(e){return await this._prim.deserializePublicKey(e)}async serializePrivateKey(e){return await this._prim.serializePrivateKey(e)}async deserializePrivateKey(e){return await this._prim.deserializePrivateKey(e)}async importKey(e,t,n=!0){return await this._prim.importKey(e,t,n)}async generateKeyPair(){return await this._prim.generateKeyPair()}async deriveKeyPair(e){if(e.byteLength>8192)throw new he("Too long ikm");return await this._prim.deriveKeyPair(e)}async encap(e){let t;e.ekm===void 0?t=await this.generateKeyPair():ce(e.ekm)?t=e.ekm:t=await this.deriveKeyPair(e.ekm);let n=await this._prim.serializePublicKey(t.publicKey),i=await this._prim.serializePublicKey(e.recipientPublicKey);try{let s;if(e.senderKey===void 0)s=new Uint8Array(await this._prim.dh(t.privateKey,e.recipientPublicKey));else{let o=ce(e.senderKey)?e.senderKey.privateKey:e.senderKey,f=new Uint8Array(await this._prim.dh(t.privateKey,e.recipientPublicKey)),d=new Uint8Array(await this._prim.dh(o,e.recipientPublicKey));s=de(f,d)}let a;if(e.senderKey===void 0)a=de(new Uint8Array(n),new Uint8Array(i));else{let o=ce(e.senderKey)?e.senderKey.publicKey:await this._prim.derivePublicKey(e.senderKey),f=await this._prim.serializePublicKey(o);a=Sr(new Uint8Array(n),new Uint8Array(i),new Uint8Array(f))}let c=await this._generateSharedSecret(s,a);return{enc:n,sharedSecret:c}}catch(s){throw new We(s)}}async decap(e){let t=await this._prim.deserializePublicKey(e.enc),n=ce(e.recipientKey)?e.recipientKey.privateKey:e.recipientKey,i=ce(e.recipientKey)?e.recipientKey.publicKey:await this._prim.derivePublicKey(e.recipientKey),s=await this._prim.serializePublicKey(i);try{let a;if(e.senderPublicKey===void 0)a=new Uint8Array(await this._prim.dh(n,t));else{let o=new Uint8Array(await this._prim.dh(n,t)),f=new Uint8Array(await this._prim.dh(n,e.senderPublicKey));a=de(o,f)}let c;if(e.senderPublicKey===void 0)c=de(new Uint8Array(e.enc),new Uint8Array(s));else{let o=await this._prim.serializePublicKey(e.senderPublicKey);c=new Uint8Array(e.enc.byteLength+s.byteLength+o.byteLength),c.set(new Uint8Array(e.enc),0),c.set(new Uint8Array(s),e.enc.byteLength),c.set(new Uint8Array(o),e.enc.byteLength+s.byteLength)}return await this._generateSharedSecret(a,c)}catch(a){throw new Ye(a)}}async _generateSharedSecret(e,t){let n=this._kdf.buildLabeledIkm(Er,e),i=this._kdf.buildLabeledInfo(Ar,t,this.secretSize);return await this._kdf.extractAndExpand(G.buffer,n.buffer,i.buffer,this.secretSize)}};var be=["deriveBits"],ke=new Uint8Array([100,107,112,95,112,114,107]),De=new Uint8Array([115,107]);var mn=new Uint8Array([99,97,110,100,105,100,97,116,101]),gn=new Uint8Array([255,255,255,255,0,0,0,0,255,255,255,255,255,255,255,255,188,230,250,173,167,23,158,132,243,185,202,194,252,99,37,81]),_n=new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,199,99,77,129,244,55,45,223,88,26,13,178,72,176,167,122,236,236,25,106,204,197,41,115]),vn=new Uint8Array([1,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,81,134,135,131,191,47,150,107,127,204,1,72,247,9,165,208,59,181,201,184,137,156,71,174,187,111,183,30,145,56,100,9]),En=new Uint8Array([48,65,2,1,0,48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7,4,39,48,37,2,1,1,4,32]),An=new Uint8Array([48,78,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,34,4,55,48,53,2,1,1,4,48]),Sn=new Uint8Array([48,96,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,35,4,73,48,71,2,1,1,4,66]);var $=class{constructor(e,t,n,i=[]){Object.defineProperty(this,"key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extractable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"algorithm",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"usages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.key=t,this.type=n,this.algorithm={name:e},this.usages=i,n==="public"&&(this.usages=[])}};var Rt=new Uint8Array([72,80,75,69,45,118,49]),lt=class extends Pe{constructor(){super(),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Xe.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_suiteId",{enumerable:!0,configurable:!0,writable:!0,value:G}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}init(e){this._suiteId=e}buildLabeledIkm(e,t){this._checkInit();let n=new Uint8Array(7+this._suiteId.byteLength+e.byteLength+t.byteLength);return n.set(Rt,0),n.set(this._suiteId,7),n.set(e,7+this._suiteId.byteLength),n.set(t,7+this._suiteId.byteLength+e.byteLength),n}buildLabeledInfo(e,t,n){this._checkInit();let i=new Uint8Array(9+this._suiteId.byteLength+e.byteLength+t.byteLength);return i.set(new Uint8Array([0,n]),0),i.set(Rt,2),i.set(this._suiteId,9),i.set(e,9+this._suiteId.byteLength),i.set(t,9+this._suiteId.byteLength+e.byteLength),i}async extract(e,t){if(await this._setup(),e.byteLength===0&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)throw new he("The salt length must be the same as the hashSize");let n=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,t)}async expand(e,t,n){await this._setup();let i=await this._api.importKey("raw",e,this.algHash,!1,["sign"]),s=new ArrayBuffer(n),a=new Uint8Array(s),c=G,o=new Uint8Array(t),f=new Uint8Array(1);if(n>255*this.hashSize)throw new Error("Entropy limit reached");let d=new Uint8Array(this.hashSize+o.length+1);for(let b=1,x=0;x<a.length;b++)f[0]=b,d.set(c,0),d.set(o,c.length),d.set(f,c.length+o.length),c=new Uint8Array(await this._api.sign("HMAC",i,d.slice(0,c.length+o.length+1))),a.length-x>=c.length?(a.set(c,x),x+=c.length):(a.set(c.slice(0,a.length-x),x),x+=a.length-x);return s}async extractAndExpand(e,t,n,i){await this._setup();let s=await this._api.importKey("raw",t,"HKDF",!1,["deriveBits"]);return await this._api.deriveBits({name:"HKDF",hash:this.algHash.hash,salt:e,info:n},s,i*8)}async labeledExtract(e,t,n){return await this.extract(e,this.buildLabeledIkm(t,n).buffer)}async labeledExpand(e,t,n,i){return await this.expand(e,this.buildLabeledInfo(t,n,i).buffer,i)}_checkInit(){if(this._suiteId===G)throw new Error("Not initialized. Call init()")}},Re=class extends lt{constructor(){super(...arguments),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Xe.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}};var ye=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function Kr(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Je(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function we(r,...e){if(!Kr(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function qt(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");Je(r.outputLen),Je(r.blockLen)}function Ue(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Mt(r,e){we(r);let t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function pe(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function Qe(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function W(r,e){return r<<32-e|r>>>e}function Pr(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function qe(r){return typeof r=="string"&&(r=Pr(r)),we(r),r}function jt(...r){let e=0;for(let n=0;n<r.length;n++){let i=r[n];we(i),e+=i.length}let t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){let s=r[n];t.set(s,i),i+=s.length}return t}var Ie=class{};function Gt(r){let e=n=>r().update(qe(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function Vt(r=32){if(ye&&typeof ye.getRandomValues=="function")return ye.getRandomValues(new Uint8Array(r));if(ye&&typeof ye.randomBytes=="function")return Uint8Array.from(ye.randomBytes(r));throw new Error("crypto.getRandomValues must be defined")}var Fe=class extends Ie{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,qt(e);let n=qe(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,s=new Uint8Array(i);s.set(n.length>i?e.create().update(n).digest():n);for(let a=0;a<s.length;a++)s[a]^=54;this.iHash.update(s),this.oHash=e.create();for(let a=0;a<s.length;a++)s[a]^=106;this.oHash.update(s),pe(s)}update(e){return Ue(this),this.iHash.update(e),this}digestInto(e){Ue(this),we(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:n,finished:i,destroyed:s,blockLen:a,outputLen:c}=this;return e=e,e.finished=i,e.destroyed=s,e.blockLen=a,e.outputLen=c,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},Me=(r,e,t)=>new Fe(r,e).update(t).digest();Me.create=(r,e)=>new Fe(r,e);function Br(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);let i=BigInt(32),s=BigInt(4294967295),a=Number(t>>i&s),c=Number(t&s),o=n?4:0,f=n?0:4;r.setUint32(e+o,a,n),r.setUint32(e+f,c,n)}function Zt(r,e,t){return r&e^~r&t}function Wt(r,e,t){return r&e^r&t^e&t}var et=class extends Ie{constructor(e,t,n,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=i,this.buffer=new Uint8Array(e),this.view=Qe(this.buffer)}update(e){Ue(this),e=qe(e),we(e);let{view:t,buffer:n,blockLen:i}=this,s=e.length;for(let a=0;a<s;){let c=Math.min(i-this.pos,s-a);if(c===i){let o=Qe(e);for(;i<=s-a;a+=i)this.process(o,a);continue}n.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Ue(this),Mt(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:i,isLE:s}=this,{pos:a}=this;t[a++]=128,pe(this.buffer.subarray(a)),this.padOffset>i-a&&(this.process(n,0),a=0);for(let b=a;b<i;b++)t[b]=0;Br(n,i-8,BigInt(this.length*8),s),this.process(n,0);let c=Qe(e),o=this.outputLen;if(o%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=o/4,d=this.get();if(f>d.length)throw new Error("_sha2: outputLen bigger than state");for(let b=0;b<f;b++)c.setUint32(4*b,d[b],s)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:i,finished:s,destroyed:a,pos:c}=this;return e.destroyed=a,e.finished=s,e.length=i,e.pos=c,i%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}},te=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var kr=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),fe=new Uint32Array(64),tt=class extends et{constructor(e=32){super(64,e,8,!1),this.A=te[0]|0,this.B=te[1]|0,this.C=te[2]|0,this.D=te[3]|0,this.E=te[4]|0,this.F=te[5]|0,this.G=te[6]|0,this.H=te[7]|0}get(){let{A:e,B:t,C:n,D:i,E:s,F:a,G:c,H:o}=this;return[e,t,n,i,s,a,c,o]}set(e,t,n,i,s,a,c,o){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=s|0,this.F=a|0,this.G=c|0,this.H=o|0}process(e,t){for(let b=0;b<16;b++,t+=4)fe[b]=e.getUint32(t,!1);for(let b=16;b<64;b++){let x=fe[b-15],k=fe[b-2],L=W(x,7)^W(x,18)^x>>>3,w=W(k,17)^W(k,19)^k>>>10;fe[b]=w+fe[b-7]+L+fe[b-16]|0}let{A:n,B:i,C:s,D:a,E:c,F:o,G:f,H:d}=this;for(let b=0;b<64;b++){let x=W(c,6)^W(c,11)^W(c,25),k=d+x+Zt(c,o,f)+kr[b]+fe[b]|0,w=(W(n,2)^W(n,13)^W(n,22))+Wt(n,i,s)|0;d=f,f=o,o=c,c=a+k|0,a=s,s=i,i=n,n=k+w|0}n=n+this.A|0,i=i+this.B|0,s=s+this.C|0,a=a+this.D|0,c=c+this.E|0,o=o+this.F|0,f=f+this.G|0,d=d+this.H|0,this.set(n,i,s,a,c,o,f,d)}roundClean(){pe(fe)}destroy(){this.set(0,0,0,0,0,0,0,0),pe(this.buffer)}};var rt=Gt(()=>new tt);var Yt=rt;var He=class extends Re{async extract(e,t){if(await this._setup(),e.byteLength===0&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)return Me(Yt,new Uint8Array(e),new Uint8Array(t)).buffer;let n=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,t)}};var yt=BigInt(0),bt=BigInt(1);function Le(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function wt(r){if(!Le(r))throw new Error("Uint8Array expected")}function Oe(r,e){if(typeof e!="boolean")throw new Error(r+" boolean expected, got "+e)}function je(r){let e=r.toString(16);return e.length&1?"0"+e:e}function Jt(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?yt:BigInt("0x"+r)}var Qt=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ir=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function ze(r){if(wt(r),Qt)return r.toHex();let e="";for(let t=0;t<r.length;t++)e+=Ir[r[t]];return e}var re={_0:48,_9:57,A:65,F:70,a:97,f:102};function Xt(r){if(r>=re._0&&r<=re._9)return r-re._0;if(r>=re.A&&r<=re.F)return r-(re.A-10);if(r>=re.a&&r<=re.f)return r-(re.a-10)}function Ge(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(Qt)return Uint8Array.fromHex(r);let e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);let n=new Uint8Array(t);for(let i=0,s=0;i<t;i++,s+=2){let a=Xt(r.charCodeAt(s)),c=Xt(r.charCodeAt(s+1));if(a===void 0||c===void 0){let o=r[s]+r[s+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+s)}n[i]=a*16+c}return n}function ne(r){return Jt(ze(r))}function pt(r){return wt(r),Jt(ze(Uint8Array.from(r).reverse()))}function xe(r,e){return Ge(r.toString(16).padStart(e*2,"0"))}function xt(r,e){return xe(r,e).reverse()}function j(r,e,t){let n;if(typeof e=="string")try{n=Ge(e)}catch(s){throw new Error(r+" must be hex string or Uint8Array, cause: "+s)}else if(Le(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");let i=n.length;if(typeof t=="number"&&i!==t)throw new Error(r+" of length "+t+" expected, got "+i);return n}function Ve(...r){let e=0;for(let n=0;n<r.length;n++){let i=r[n];wt(i),e+=i.length}let t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){let s=r[n];t.set(s,i),i+=s.length}return t}var ht=r=>typeof r=="bigint"&&yt<=r;function nt(r,e,t){return ht(r)&&ht(e)&&ht(t)&&e<=r&&r<t}function me(r,e,t,n){if(!nt(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function Ft(r){let e;for(e=0;r>yt;r>>=bt,e+=1);return e}var ge=r=>(bt<<BigInt(r))-bt,dt=r=>new Uint8Array(r),$t=r=>Uint8Array.from(r);function er(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=dt(r),i=dt(r),s=0,a=()=>{n.fill(1),i.fill(0),s=0},c=(...b)=>t(i,n,...b),o=(b=dt(0))=>{i=c($t([0]),b),n=c(),b.length!==0&&(i=c($t([1]),b),n=c())},f=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let b=0,x=[];for(;b<e;){n=c();let k=n.slice();x.push(k),b+=n.length}return Ve(...x)};return(b,x)=>{a(),o(b);let k;for(;!(k=x(f()));)o();return a(),k}}var Ur={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||Le(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function _e(r,e,t={}){let n=(i,s,a)=>{let c=Ur[s];if(typeof c!="function")throw new Error("invalid validator function");let o=r[i];if(!(a&&o===void 0)&&!c(o,r))throw new Error("param "+String(i)+" is invalid. Expected "+s+", got "+o)};for(let[i,s]of Object.entries(e))n(i,s,!1);for(let[i,s]of Object.entries(t))n(i,s,!0);return r}function mt(r){let e=new WeakMap;return(t,...n)=>{let i=e.get(t);if(i!==void 0)return i;let s=r(t,...n);return e.set(t,s),s}}var q=BigInt(0),N=BigInt(1),ve=BigInt(2),Hr=BigInt(3),rr=BigInt(4),nr=BigInt(5),ir=BigInt(8);function C(r,e){let t=r%e;return t>=q?t:e+t}function V(r,e,t){let n=r;for(;e-- >q;)n*=n,n%=t;return n}function it(r,e){if(r===q)throw new Error("invert: expected non-zero number");if(e<=q)throw new Error("invert: expected positive modulus, got "+e);let t=C(r,e),n=e,i=q,s=N,a=N,c=q;for(;t!==q;){let f=n/t,d=n%t,b=i-a*f,x=s-c*f;n=t,t=d,i=a,s=c,a=b,c=x}if(n!==N)throw new Error("invert: does not exist");return C(i,e)}function or(r,e){let t=(r.ORDER+N)/rr,n=r.pow(e,t);if(!r.eql(r.sqr(n),e))throw new Error("Cannot find square root");return n}function Lr(r,e){let t=(r.ORDER-nr)/ir,n=r.mul(e,ve),i=r.pow(n,t),s=r.mul(e,i),a=r.mul(r.mul(s,ve),i),c=r.mul(s,r.sub(a,r.ONE));if(!r.eql(r.sqr(c),e))throw new Error("Cannot find square root");return c}function Or(r){if(r<BigInt(3))throw new Error("sqrt is not defined for small field");let e=r-N,t=0;for(;e%ve===q;)e/=ve,t++;let n=ve,i=Ze(r);for(;tr(i,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return or;let s=i.pow(n,e),a=(e+N)/ve;return function(o,f){if(o.is0(f))return f;if(tr(o,f)!==1)throw new Error("Cannot find square root");let d=t,b=o.mul(o.ONE,s),x=o.pow(f,e),k=o.pow(f,a);for(;!o.eql(x,o.ONE);){if(o.is0(x))return o.ZERO;let L=1,w=o.sqr(x);for(;!o.eql(w,o.ONE);)if(L++,w=o.sqr(w),L===d)throw new Error("Cannot find square root");let D=N<<BigInt(d-L-1),O=o.pow(b,D);d=L,b=o.sqr(O),x=o.mul(x,b),k=o.mul(k,O)}return k}}function zr(r){return r%rr===Hr?or:r%ir===nr?Lr:Or(r)}var Tr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function gt(r){let e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Tr.reduce((n,i)=>(n[i]="function",n),e);return _e(r,t)}function Cr(r,e,t){if(t<q)throw new Error("invalid exponent, negatives unsupported");if(t===q)return r.ONE;if(t===N)return e;let n=r.ONE,i=e;for(;t>q;)t&N&&(n=r.mul(n,i)),i=r.sqr(i),t>>=N;return n}function _t(r,e,t=!1){let n=new Array(e.length).fill(t?r.ZERO:void 0),i=e.reduce((a,c,o)=>r.is0(c)?a:(n[o]=a,r.mul(a,c)),r.ONE),s=r.inv(i);return e.reduceRight((a,c,o)=>r.is0(c)?a:(n[o]=r.mul(a,n[o]),r.mul(a,c)),s),n}function tr(r,e){let t=(r.ORDER-N)/ve,n=r.pow(e,t),i=r.eql(n,r.ONE),s=r.eql(n,r.ZERO),a=r.eql(n,r.neg(r.ONE));if(!i&&!s&&!a)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function vt(r,e){e!==void 0&&Je(e);let t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function Ze(r,e,t=!1,n={}){if(r<=q)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:i,nByteLength:s}=vt(r,e);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a,c=Object.freeze({ORDER:r,isLE:t,BITS:i,BYTES:s,MASK:ge(i),ZERO:q,ONE:N,create:o=>C(o,r),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return q<=o&&o<r},is0:o=>o===q,isOdd:o=>(o&N)===N,neg:o=>C(-o,r),eql:(o,f)=>o===f,sqr:o=>C(o*o,r),add:(o,f)=>C(o+f,r),sub:(o,f)=>C(o-f,r),mul:(o,f)=>C(o*f,r),pow:(o,f)=>Cr(c,o,f),div:(o,f)=>C(o*it(f,r),r),sqrN:o=>o*o,addN:(o,f)=>o+f,subN:(o,f)=>o-f,mulN:(o,f)=>o*f,inv:o=>it(o,r),sqrt:n.sqrt||(o=>(a||(a=zr(r)),a(c,o))),toBytes:o=>t?xt(o,s):xe(o,s),fromBytes:o=>{if(o.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+o.length);return t?pt(o):ne(o)},invertBatch:o=>_t(c,o),cmov:(o,f,d)=>d?f:o});return Object.freeze(c)}function sr(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let e=r.toString(2).length;return Math.ceil(e/8)}function Et(r){let e=sr(r);return e+Math.ceil(e/2)}function ar(r,e,t=!1){let n=r.length,i=sr(e),s=Et(e);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);let a=t?pt(r):ne(r),c=C(a,e-N)+N;return t?xt(c,i):xe(c,i)}var cr=BigInt(0),Bt=BigInt(1);function At(r,e){let t=e.negate();return r?t:e}function ur(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function St(r,e){ur(r,e);let t=Math.ceil(e/r)+1,n=2**(r-1),i=2**r,s=ge(r),a=BigInt(r);return{windows:t,windowSize:n,mask:s,maxNumber:i,shiftBy:a}}function fr(r,e,t){let{windowSize:n,mask:i,maxNumber:s,shiftBy:a}=t,c=Number(r&i),o=r>>a;c>n&&(c-=s,o+=Bt);let f=e*n,d=f+Math.abs(c)-1,b=c===0,x=c<0,k=e%2!==0;return{nextN:o,offset:d,isZero:b,isNeg:x,isNegF:k,offsetF:f}}function Nr(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function Dr(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}var Kt=new WeakMap,lr=new WeakMap;function Pt(r){return lr.get(r)||1}function hr(r,e){return{constTimeNegate:At,hasPrecomputes(t){return Pt(t)!==1},unsafeLadder(t,n,i=r.ZERO){let s=t;for(;n>cr;)n&Bt&&(i=i.add(s)),s=s.double(),n>>=Bt;return i},precomputeWindow(t,n){let{windows:i,windowSize:s}=St(n,e),a=[],c=t,o=c;for(let f=0;f<i;f++){o=c,a.push(o);for(let d=1;d<s;d++)o=o.add(c),a.push(o);c=o.double()}return a},wNAF(t,n,i){let s=r.ZERO,a=r.BASE,c=St(t,e);for(let o=0;o<c.windows;o++){let{nextN:f,offset:d,isZero:b,isNeg:x,isNegF:k,offsetF:L}=fr(i,o,c);i=f,b?a=a.add(At(k,n[L])):s=s.add(At(x,n[d]))}return{p:s,f:a}},wNAFUnsafe(t,n,i,s=r.ZERO){let a=St(t,e);for(let c=0;c<a.windows&&i!==cr;c++){let{nextN:o,offset:f,isZero:d,isNeg:b}=fr(i,c,a);if(i=o,!d){let x=n[f];s=s.add(b?x.negate():x)}}return s},getPrecomputes(t,n,i){let s=Kt.get(n);return s||(s=this.precomputeWindow(n,t),t!==1&&Kt.set(n,i(s))),s},wNAFCached(t,n,i){let s=Pt(t);return this.wNAF(s,this.getPrecomputes(s,t,i),n)},wNAFCachedUnsafe(t,n,i,s){let a=Pt(t);return a===1?this.unsafeLadder(t,n,s):this.wNAFUnsafe(a,this.getPrecomputes(a,t,i),n,s)},setWindowSize(t,n){ur(n,e),lr.set(t,n),Kt.delete(t)}}}function dr(r,e,t,n){Nr(t,r),Dr(n,e);let i=t.length,s=n.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");let a=r.ZERO,c=Ft(BigInt(i)),o=1;c>12?o=c-3:c>4?o=c-2:c>0&&(o=2);let f=ge(o),d=new Array(Number(f)+1).fill(a),b=Math.floor((e.BITS-1)/o)*o,x=a;for(let k=b;k>=0;k-=o){d.fill(a);for(let w=0;w<s;w++){let D=n[w],O=Number(D>>BigInt(k)&f);d[O]=d[O].add(t[w])}let L=a;for(let w=d.length-1,D=a;w>0;w--)D=D.add(d[w]),L=L.add(D);if(x=x.add(L),k!==0)for(let w=0;w<o;w++)x=x.double()}return x}function kt(r){return gt(r.Fp),_e(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...vt(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}function br(r){r.lowS!==void 0&&Oe("lowS",r.lowS),r.prehash!==void 0&&Oe("prehash",r.prehash)}function qr(r){let e=kt(r);_e(e,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});let{endo:t,Fp:n,a:i}=e;if(t){if(!n.eql(i,n.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...e})}var Ht=class extends Error{constructor(e=""){super(e)}},ie={Err:Ht,_tlv:{encode:(r,e)=>{let{Err:t}=ie;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");let n=e.length/2,i=je(n);if(i.length/2&128)throw new t("tlv.encode: long form length too big");let s=n>127?je(i.length/2|128):"";return je(r)+s+i+e},decode(r,e){let{Err:t}=ie,n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");let i=e[n++],s=!!(i&128),a=0;if(!s)a=i;else{let o=i&127;if(!o)throw new t("tlv.decode(long): indefinite length not supported");if(o>4)throw new t("tlv.decode(long): byte length is too big");let f=e.subarray(n,n+o);if(f.length!==o)throw new t("tlv.decode: length bytes not complete");if(f[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(let d of f)a=a<<8|d;if(n+=o,a<128)throw new t("tlv.decode(long): not minimal encoding")}let c=e.subarray(n,n+a);if(c.length!==a)throw new t("tlv.decode: wrong value length");return{v:c,l:e.subarray(n+a)}}},_int:{encode(r){let{Err:e}=ie;if(r<oe)throw new e("integer: negative integers are not allowed");let t=je(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){let{Err:e}=ie;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return ne(r)}},toSig(r){let{Err:e,_int:t,_tlv:n}=ie,i=j("signature",r),{v:s,l:a}=n.decode(48,i);if(a.length)throw new e("invalid signature: left bytes after parsing");let{v:c,l:o}=n.decode(2,s),{v:f,l:d}=n.decode(2,o);if(d.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(c),s:t.decode(f)}},hexFromSig(r){let{_tlv:e,_int:t}=ie,n=e.encode(2,t.encode(r.r)),i=e.encode(2,t.encode(r.s)),s=n+i;return e.encode(48,s)}};function It(r,e){return ze(xe(r,e))}var oe=BigInt(0),z=BigInt(1),ao=BigInt(2),Ut=BigInt(3),Mr=BigInt(4);function jr(r){let e=qr(r),{Fp:t}=e,n=Ze(e.n,e.nBitLength),i=e.toBytes||((S,u,y)=>{let m=u.toAffine();return Ve(Uint8Array.from([4]),t.toBytes(m.x),t.toBytes(m.y))}),s=e.fromBytes||(S=>{let u=S.subarray(1),y=t.fromBytes(u.subarray(0,t.BYTES)),m=t.fromBytes(u.subarray(t.BYTES,2*t.BYTES));return{x:y,y:m}});function a(S){let{a:u,b:y}=e,m=t.sqr(S),E=t.mul(m,S);return t.add(t.add(E,t.mul(S,u)),y)}function c(S,u){let y=t.sqr(u),m=a(S);return t.eql(y,m)}if(!c(e.Gx,e.Gy))throw new Error("bad curve params: generator point");let o=t.mul(t.pow(e.a,Ut),Mr),f=t.mul(t.sqr(e.b),BigInt(27));if(t.is0(t.add(o,f)))throw new Error("bad curve params: a or b");function d(S){return nt(S,z,e.n)}function b(S){let{allowedPrivateKeyLengths:u,nByteLength:y,wrapPrivateKey:m,n:E}=e;if(u&&typeof S!="bigint"){if(Le(S)&&(S=ze(S)),typeof S!="string"||!u.includes(S.length))throw new Error("invalid private key");S=S.padStart(y*2,"0")}let B;try{B=typeof S=="bigint"?S:ne(j("private key",S,y))}catch{throw new Error("invalid private key, expected hex or "+y+" bytes, got "+typeof S)}return m&&(B=C(B,E)),me("private key",B,z,E),B}function x(S){if(!(S instanceof w))throw new Error("ProjectivePoint expected")}let k=mt((S,u)=>{let{px:y,py:m,pz:E}=S;if(t.eql(E,t.ONE))return{x:y,y:m};let B=S.is0();u==null&&(u=B?t.ONE:t.inv(E));let U=t.mul(y,u),I=t.mul(m,u),g=t.mul(E,u);if(B)return{x:t.ZERO,y:t.ZERO};if(!t.eql(g,t.ONE))throw new Error("invZ was invalid");return{x:U,y:I}}),L=mt(S=>{if(S.is0()){if(e.allowInfinityPoint&&!t.is0(S.py))return;throw new Error("bad point: ZERO")}let{x:u,y}=S.toAffine();if(!t.isValid(u)||!t.isValid(y))throw new Error("bad point: x or y not FE");if(!c(u,y))throw new Error("bad point: equation left != right");if(!S.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class w{constructor(u,y,m){if(u==null||!t.isValid(u))throw new Error("x required");if(y==null||!t.isValid(y)||t.is0(y))throw new Error("y required");if(m==null||!t.isValid(m))throw new Error("z required");this.px=u,this.py=y,this.pz=m,Object.freeze(this)}static fromAffine(u){let{x:y,y:m}=u||{};if(!u||!t.isValid(y)||!t.isValid(m))throw new Error("invalid affine point");if(u instanceof w)throw new Error("projective point not allowed");let E=B=>t.eql(B,t.ZERO);return E(y)&&E(m)?w.ZERO:new w(y,m,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){let y=_t(t,u.map(m=>m.pz));return u.map((m,E)=>m.toAffine(y[E])).map(w.fromAffine)}static fromHex(u){let y=w.fromAffine(s(j("pointHex",u)));return y.assertValidity(),y}static fromPrivateKey(u){return w.BASE.multiply(b(u))}static msm(u,y){return dr(w,n,u,y)}_setWindowSize(u){Y.setWindowSize(this,u)}assertValidity(){L(this)}hasEvenY(){let{y:u}=this.toAffine();if(t.isOdd)return!t.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){x(u);let{px:y,py:m,pz:E}=this,{px:B,py:U,pz:I}=u,g=t.eql(t.mul(y,I),t.mul(B,E)),P=t.eql(t.mul(m,I),t.mul(U,E));return g&&P}negate(){return new w(this.px,t.neg(this.py),this.pz)}double(){let{a:u,b:y}=e,m=t.mul(y,Ut),{px:E,py:B,pz:U}=this,I=t.ZERO,g=t.ZERO,P=t.ZERO,_=t.mul(E,E),T=t.mul(B,B),h=t.mul(U,U),l=t.mul(E,B);return l=t.add(l,l),P=t.mul(E,U),P=t.add(P,P),I=t.mul(u,P),g=t.mul(m,h),g=t.add(I,g),I=t.sub(T,g),g=t.add(T,g),g=t.mul(I,g),I=t.mul(l,I),P=t.mul(m,P),h=t.mul(u,h),l=t.sub(_,h),l=t.mul(u,l),l=t.add(l,P),P=t.add(_,_),_=t.add(P,_),_=t.add(_,h),_=t.mul(_,l),g=t.add(g,_),h=t.mul(B,U),h=t.add(h,h),_=t.mul(h,l),I=t.sub(I,_),P=t.mul(h,T),P=t.add(P,P),P=t.add(P,P),new w(I,g,P)}add(u){x(u);let{px:y,py:m,pz:E}=this,{px:B,py:U,pz:I}=u,g=t.ZERO,P=t.ZERO,_=t.ZERO,T=e.a,h=t.mul(e.b,Ut),l=t.mul(y,B),p=t.mul(m,U),K=t.mul(E,I),v=t.add(y,m),A=t.add(B,U);v=t.mul(v,A),A=t.add(l,p),v=t.sub(v,A),A=t.add(y,E);let H=t.add(B,I);return A=t.mul(A,H),H=t.add(l,K),A=t.sub(A,H),H=t.add(m,E),g=t.add(U,I),H=t.mul(H,g),g=t.add(p,K),H=t.sub(H,g),_=t.mul(T,A),g=t.mul(h,K),_=t.add(g,_),g=t.sub(p,_),_=t.add(p,_),P=t.mul(g,_),p=t.add(l,l),p=t.add(p,l),K=t.mul(T,K),A=t.mul(h,A),p=t.add(p,K),K=t.sub(l,K),K=t.mul(T,K),A=t.add(A,K),l=t.mul(p,A),P=t.add(P,l),l=t.mul(H,A),g=t.mul(v,g),g=t.sub(g,l),l=t.mul(v,p),_=t.mul(H,_),_=t.add(_,l),new w(g,P,_)}subtract(u){return this.add(u.negate())}is0(){return this.equals(w.ZERO)}wNAF(u){return Y.wNAFCached(this,u,w.normalizeZ)}multiplyUnsafe(u){let{endo:y,n:m}=e;me("scalar",u,oe,m);let E=w.ZERO;if(u===oe)return E;if(this.is0()||u===z)return this;if(!y||Y.hasPrecomputes(this))return Y.wNAFCachedUnsafe(this,u,w.normalizeZ);let{k1neg:B,k1:U,k2neg:I,k2:g}=y.splitScalar(u),P=E,_=E,T=this;for(;U>oe||g>oe;)U&z&&(P=P.add(T)),g&z&&(_=_.add(T)),T=T.double(),U>>=z,g>>=z;return B&&(P=P.negate()),I&&(_=_.negate()),_=new w(t.mul(_.px,y.beta),_.py,_.pz),P.add(_)}multiply(u){let{endo:y,n:m}=e;me("scalar",u,z,m);let E,B;if(y){let{k1neg:U,k1:I,k2neg:g,k2:P}=y.splitScalar(u),{p:_,f:T}=this.wNAF(I),{p:h,f:l}=this.wNAF(P);_=Y.constTimeNegate(U,_),h=Y.constTimeNegate(g,h),h=new w(t.mul(h.px,y.beta),h.py,h.pz),E=_.add(h),B=T.add(l)}else{let{p:U,f:I}=this.wNAF(u);E=U,B=I}return w.normalizeZ([E,B])[0]}multiplyAndAddUnsafe(u,y,m){let E=w.BASE,B=(I,g)=>g===oe||g===z||!I.equals(E)?I.multiplyUnsafe(g):I.multiply(g),U=B(this,y).add(B(u,m));return U.is0()?void 0:U}toAffine(u){return k(this,u)}isTorsionFree(){let{h:u,isTorsionFree:y}=e;if(u===z)return!0;if(y)return y(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:u,clearCofactor:y}=e;return u===z?this:y?y(w,this):this.multiplyUnsafe(e.h)}toRawBytes(u=!0){return Oe("isCompressed",u),this.assertValidity(),i(w,this,u)}toHex(u=!0){return Oe("isCompressed",u),ze(this.toRawBytes(u))}}w.BASE=new w(e.Gx,e.Gy,t.ONE),w.ZERO=new w(t.ZERO,t.ONE,t.ZERO);let{endo:D,nBitLength:O}=e,Y=hr(w,D?Math.ceil(O/2):O);return{CURVE:e,ProjectivePoint:w,normPrivateKeyToScalar:b,weierstrassEquation:a,isWithinCurveOrder:d}}function Gr(r){let e=kt(r);return _e(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function yr(r){let e=Gr(r),{Fp:t,n,nByteLength:i,nBitLength:s}=e,a=t.BYTES+1,c=2*t.BYTES+1;function o(h){return C(h,n)}function f(h){return it(h,n)}let{ProjectivePoint:d,normPrivateKeyToScalar:b,weierstrassEquation:x,isWithinCurveOrder:k}=jr({...e,toBytes(h,l,p){let K=l.toAffine(),v=t.toBytes(K.x),A=Ve;return Oe("isCompressed",p),p?A(Uint8Array.from([l.hasEvenY()?2:3]),v):A(Uint8Array.from([4]),v,t.toBytes(K.y))},fromBytes(h){let l=h.length,p=h[0],K=h.subarray(1);if(l===a&&(p===2||p===3)){let v=ne(K);if(!nt(v,z,t.ORDER))throw new Error("Point is not on curve");let A=x(v),H;try{H=t.sqrt(A)}catch(Z){let M=Z instanceof Error?": "+Z.message:"";throw new Error("Point is not on curve"+M)}let R=(H&z)===z;return(p&1)===1!==R&&(H=t.neg(H)),{x:v,y:H}}else if(l===c&&p===4){let v=t.fromBytes(K.subarray(0,t.BYTES)),A=t.fromBytes(K.subarray(t.BYTES,2*t.BYTES));return{x:v,y:A}}else{let v=a,A=c;throw new Error("invalid Point, expected length of "+v+", or uncompressed "+A+", got "+l)}}});function L(h){let l=n>>z;return h>l}function w(h){return L(h)?o(-h):h}let D=(h,l,p)=>ne(h.slice(l,p));class O{constructor(l,p,K){me("r",l,z,n),me("s",p,z,n),this.r=l,this.s=p,K!=null&&(this.recovery=K),Object.freeze(this)}static fromCompact(l){let p=i;return l=j("compactSignature",l,p*2),new O(D(l,0,p),D(l,p,2*p))}static fromDER(l){let{r:p,s:K}=ie.toSig(j("DER",l));return new O(p,K)}assertValidity(){}addRecoveryBit(l){return new O(this.r,this.s,l)}recoverPublicKey(l){let{r:p,s:K,recovery:v}=this,A=E(j("msgHash",l));if(v==null||![0,1,2,3].includes(v))throw new Error("recovery id invalid");let H=v===2||v===3?p+e.n:p;if(H>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");let R=(v&1)===0?"02":"03",J=d.fromHex(R+It(H,t.BYTES)),Z=f(H),M=o(-A*Z),Ee=o(K*Z),se=d.BASE.multiplyAndAddUnsafe(J,M,Ee);if(!se)throw new Error("point at infinify");return se.assertValidity(),se}hasHighS(){return L(this.s)}normalizeS(){return this.hasHighS()?new O(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return Ge(this.toDERHex())}toDERHex(){return ie.hexFromSig(this)}toCompactRawBytes(){return Ge(this.toCompactHex())}toCompactHex(){let l=i;return It(this.r,l)+It(this.s,l)}}let Y={isValidPrivateKey(h){try{return b(h),!0}catch{return!1}},normPrivateKeyToScalar:b,randomPrivateKey:()=>{let h=Et(e.n);return ar(e.randomBytes(h),e.n)},precompute(h=8,l=d.BASE){return l._setWindowSize(h),l.multiply(BigInt(3)),l}};function S(h,l=!0){return d.fromPrivateKey(h).toRawBytes(l)}function u(h){if(typeof h=="bigint")return!1;if(h instanceof d)return!0;let p=j("key",h).length,K=t.BYTES,v=K+1,A=2*K+1;if(!(e.allowedPrivateKeyLengths||i===v))return p===v||p===A}function y(h,l,p=!0){if(u(h)===!0)throw new Error("first arg must be private key");if(u(l)===!1)throw new Error("second arg must be public key");return d.fromHex(l).multiply(b(h)).toRawBytes(p)}let m=e.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");let l=ne(h),p=h.length*8-s;return p>0?l>>BigInt(p):l},E=e.bits2int_modN||function(h){return o(m(h))},B=ge(s);function U(h){return me("num < 2^"+s,h,oe,B),xe(h,i)}function I(h,l,p=g){if(["recovered","canonical"].some(ue=>ue in p))throw new Error("sign() legacy options not supported");let{hash:K,randomBytes:v}=e,{lowS:A,prehash:H,extraEntropy:R}=p;A==null&&(A=!0),h=j("msgHash",h),br(p),H&&(h=j("prehashed msgHash",K(h)));let J=E(h),Z=b(l),M=[U(Z),U(J)];if(R!=null&&R!==!1){let ue=R===!0?v(t.BYTES):R;M.push(j("extraEntropy",ue))}let Ee=Ve(...M),se=J;function ct(ue){let Ae=m(ue);if(!k(Ae))return;let ft=f(Ae),Te=d.BASE.multiply(Ae).toAffine(),le=o(Te.x);if(le===oe)return;let Ce=o(ft*o(se+le*Z));if(Ce===oe)return;let Se=(Te.x===le?0:2)|Number(Te.y&z),Tt=Ce;return A&&L(Ce)&&(Tt=w(Ce),Se^=1),new O(le,Tt,Se)}return{seed:Ee,k2sig:ct}}let g={lowS:e.lowS,prehash:!1},P={lowS:e.lowS,prehash:!1};function _(h,l,p=g){let{seed:K,k2sig:v}=I(h,l,p),A=e;return er(A.hash.outputLen,A.nByteLength,A.hmac)(K,v)}d.BASE._setWindowSize(8);function T(h,l,p,K=P){let v=h;l=j("msgHash",l),p=j("publicKey",p);let{lowS:A,prehash:H,format:R}=K;if(br(K),"strict"in K)throw new Error("options.strict was renamed to lowS");if(R!==void 0&&R!=="compact"&&R!=="der")throw new Error("format must be compact or der");let J=typeof v=="string"||Le(v),Z=!J&&!R&&typeof v=="object"&&v!==null&&typeof v.r=="bigint"&&typeof v.s=="bigint";if(!J&&!Z)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let M,Ee;try{if(Z&&(M=new O(v.r,v.s)),J){try{R!=="compact"&&(M=O.fromDER(v))}catch(Se){if(!(Se instanceof ie.Err))throw Se}!M&&R!=="der"&&(M=O.fromCompact(v))}Ee=d.fromHex(p)}catch{return!1}if(!M||A&&M.hasHighS())return!1;H&&(l=e.hash(l));let{r:se,s:ct}=M,ue=E(l),Ae=f(ct),ft=o(ue*Ae),Te=o(se*Ae),le=d.BASE.multiplyAndAddUnsafe(Ee,ft,Te)?.toAffine();return le?o(le.x)===se:!1}return{CURVE:e,getPublicKey:S,getSharedSecret:y,sign:_,verify:T,ProjectivePoint:d,Signature:O,utils:Y}}function Vr(r){return{hash:r,hmac:(e,...t)=>Me(r,e,jt(...t)),randomBytes:Vt}}function wr(r,e){let t=n=>yr({...r,...Vr(n)});return{...t(e),create:t}}var mr=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),pr=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Zr=BigInt(0),Wr=BigInt(1),Lt=BigInt(2),xr=(r,e)=>(r+e/Lt)/e;function Yr(r){let e=mr,t=BigInt(3),n=BigInt(6),i=BigInt(11),s=BigInt(22),a=BigInt(23),c=BigInt(44),o=BigInt(88),f=r*r*r%e,d=f*f*r%e,b=V(d,t,e)*d%e,x=V(b,t,e)*d%e,k=V(x,Lt,e)*f%e,L=V(k,i,e)*k%e,w=V(L,s,e)*L%e,D=V(w,c,e)*w%e,O=V(D,o,e)*D%e,Y=V(O,c,e)*w%e,S=V(Y,t,e)*d%e,u=V(S,a,e)*L%e,y=V(u,n,e)*f%e,m=V(y,Lt,e);if(!Ot.eql(Ot.sqr(m),r))throw new Error("Cannot find square root");return m}var Ot=Ze(mr,void 0,void 0,{sqrt:Yr}),ot=wr({a:Zr,b:BigInt(7),Fp:Ot,n:pr,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{let e=pr,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Wr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=t,a=BigInt("0x100000000000000000000000000000000"),c=xr(s*r,e),o=xr(-n*r,e),f=C(r-c*t-o*i,e),d=C(-c*n-o*s,e),b=f>a,x=d>a;if(b&&(f=e-f),x&&(d=e-d),f>a||d>a)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:b,k1:f,k2neg:x,k2:d}}}},rt);var st="ECDH",at=class{constructor(e){Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=e,this._nPk=33,this._nSk=32}async serializePublicKey(e){try{return await this._serializePublicKey(e)}catch(t){throw new F(t)}}async deserializePublicKey(e){try{return await this._importRawKey(e,!0)}catch(t){throw new X(t)}}async serializePrivateKey(e){try{return await this._serializePrivateKey(e)}catch(t){throw new F(t)}}async deserializePrivateKey(e){try{return await this._importRawKey(e,!1)}catch(t){throw new X(t)}}async importKey(e,t,n){try{if(e!=="raw")throw new Error("Unsupported format");return await this._importRawKey(t,n)}catch(i){throw new X(i)}}async generateKeyPair(){try{let e=ot.utils.randomPrivateKey(),t=new $(st,e,"private",be);return{publicKey:await this.derivePublicKey(t),privateKey:t}}catch(e){throw new ee(e)}}async deriveKeyPair(e){try{let t=await this._hkdf.labeledExtract(G.buffer,ke,new Uint8Array(e)),n=await this._hkdf.labeledExpand(t,De,G,this._nSk),i=new $(st,new Uint8Array(n),"private",be);return{privateKey:i,publicKey:await this.derivePublicKey(i)}}catch(t){throw new Ke(t)}}async derivePublicKey(e){try{return await this._derivePublicKey(e)}catch(t){throw new X(t)}}async dh(e,t){try{return await this._dh(e,t)}catch(n){throw new F(n)}}_serializePublicKey(e){return new Promise(t=>{t(e.key.buffer)})}_serializePrivateKey(e){return new Promise(t=>{t(e.key.buffer)})}_importRawKey(e,t){return new Promise((n,i)=>{t&&e.byteLength!==this._nPk&&i(new Error("Invalid length of the key")),!t&&e.byteLength!==this._nSk&&i(new Error("Invalid length of the key")),n(new $(st,new Uint8Array(e),t?"public":"private",t?[]:be))})}_derivePublicKey(e){return new Promise((t,n)=>{try{let i=ot.getPublicKey(e.key);t(new $(st,i,"public"))}catch(i){n(i)}})}_dh(e,t){return new Promise((n,i)=>{try{n(ot.getSharedSecret(e.key,t.key).buffer)}catch(s){i(s)}})}};var zt=class extends Be{constructor(){let e=new He;super(ae.DhkemSecp256k1HkdfSha256,new at(e),e),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:ae.DhkemSecp256k1HkdfSha256}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:32})}};export{zt as DhkemSecp256k1HkdfSha256};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
