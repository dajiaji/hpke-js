var er=Object.defineProperty;var tr=(r,e)=>{for(var t in e)er(r,t,{get:e[t],enumerable:!0})};var rr={},St=nr(globalThis,rr);function nr(r,e){return new Proxy(r,{get(t,n,i){return n in e?e[n]:r[n]},set(t,n,i){return n in e&&delete e[n],r[n]=i,!0},deleteProperty(t,n){let i=!1;return n in e&&(delete e[n],i=!0),n in r&&(delete r[n],i=!0),i},ownKeys(t){let n=Reflect.ownKeys(r),i=Reflect.ownKeys(e),o=new Set(i);return[...n.filter(c=>!o.has(c)),...i]},defineProperty(t,n,i){return n in e&&delete e[n],Reflect.defineProperty(r,n,i),!0},getOwnPropertyDescriptor(t,n){return n in e?Reflect.getOwnPropertyDescriptor(e,n):Reflect.getOwnPropertyDescriptor(r,n)},has(t,n){return n in e||n in r}})}var st=class extends Error{constructor(e){let t;e instanceof Error?t=e.message:typeof e=="string"?t=e:t="",super(t),this.name=this.constructor.name}},Q=class extends st{},J=class extends Q{};var F=class extends Q{},W=class extends Q{},Me=class extends Q{},$e=class extends Q{};var Se=class extends Q{},G=class extends Q{};async function or(){if(St!==void 0&&globalThis.crypto!==void 0)return globalThis.crypto.subtle;try{let{webcrypto:r}=await import("crypto");return r.subtle}catch(r){throw new G(r)}}var be=class{constructor(){Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}async _setup(){this._api===void 0&&(this._api=await or())}};var sr={NotAssigned:0,DhkemP256HkdfSha256:16,DhkemP384HkdfSha384:17,DhkemP521HkdfSha512:18,DhkemSecp256k1HkdfSha256:19,DhkemX25519HkdfSha256:32,DhkemX448HkdfSha512:33,HybridkemX25519Kyber768:48},ae=sr,ar={HkdfSha256:1,HkdfSha384:2,HkdfSha512:3},Ge=ar;var V=new Uint8Array(0);var wn=new Uint8Array([115,101,99]);var ce=r=>typeof r=="object"&&r!==null&&typeof r.privateKey=="object"&&typeof r.publicKey=="object";function pe(r,e){if(e<=0)throw new Error("i2Osp: too small size");if(r>=256**e)throw new Error("i2Osp: too large integer");let t=new Uint8Array(e);for(let n=0;n<e&&r;n++)t[e-(n+1)]=r%256,r=r>>8;return t}function we(r,e){let t=new Uint8Array(r.length+e.length);return t.set(r,0),t.set(e,r.length),t}var Xn=new Uint8Array([98,97,115,101,95,110,111,110,99,101]),Qn=new Uint8Array([101,120,112]),Jn=new Uint8Array([105,110,102,111,95,104,97,115,104]),Fn=new Uint8Array([107,101,121]),ei=new Uint8Array([112,115,107,95,105,100,95,104,97,115,104]),ti=new Uint8Array([115,101,99,114,101,116]),ri=new Uint8Array([72,80,75,69,0,0,0,0,0,0]);var At=new Uint8Array([72,80,75,69,45,118,49]),ct=class extends be{constructor(){super(),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Ge.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_suiteId",{enumerable:!0,configurable:!0,writable:!0,value:V}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}init(e){this._suiteId=e}buildLabeledIkm(e,t){this._checkInit();let n=new Uint8Array(7+this._suiteId.byteLength+e.byteLength+t.byteLength);return n.set(At,0),n.set(this._suiteId,7),n.set(e,7+this._suiteId.byteLength),n.set(t,7+this._suiteId.byteLength+e.byteLength),n}buildLabeledInfo(e,t,n){this._checkInit();let i=new Uint8Array(9+this._suiteId.byteLength+e.byteLength+t.byteLength);return i.set(new Uint8Array([0,n]),0),i.set(At,2),i.set(this._suiteId,9),i.set(e,9+this._suiteId.byteLength),i.set(t,9+this._suiteId.byteLength+e.byteLength),i}async extract(e,t){if(await this._setup(),e.byteLength===0&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)throw new J("The salt length must be the same as the hashSize");let n=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,t)}async expand(e,t,n){await this._setup();let i=await this._api.importKey("raw",e,this.algHash,!1,["sign"]),o=new ArrayBuffer(n),c=new Uint8Array(o),s=V,a=new Uint8Array(t),u=new Uint8Array(1);if(n>255*this.hashSize)throw new Error("Entropy limit reached");let y=new Uint8Array(this.hashSize+a.length+1);for(let l=1,g=0;g<c.length;l++)u[0]=l,y.set(s,0),y.set(a,s.length),y.set(u,s.length+a.length),s=new Uint8Array(await this._api.sign("HMAC",i,y.slice(0,s.length+a.length+1))),c.length-g>=s.length?(c.set(s,g),g+=s.length):(c.set(s.slice(0,c.length-g),g),g+=c.length-g);return o}async extractAndExpand(e,t,n,i){await this._setup();let o=await this._api.importKey("raw",t,"HKDF",!1,["deriveBits"]);return await this._api.deriveBits({name:"HKDF",hash:this.algHash.hash,salt:e,info:n},o,i*8)}async labeledExtract(e,t,n){return await this.extract(e,this.buildLabeledIkm(t,n))}async labeledExpand(e,t,n,i){return await this.expand(e,this.buildLabeledInfo(t,n,i),i)}_checkInit(){if(this._suiteId===V)throw new Error("Not initialized. Call init()")}},He=class extends ct{constructor(){super(...arguments),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Ge.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}};var Ze=new Uint8Array([75,69,77,0,0]);var ur=new Uint8Array([101,97,101,95,112,114,107]),fr=new Uint8Array([115,104,97,114,101,100,95,115,101,99,114,101,116]);function lr(r,e,t){let n=new Uint8Array(r.length+e.length+t.length);return n.set(r,0),n.set(e,r.length),n.set(t,r.length+e.length),n}var me=class{constructor(e,t,n){Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_prim",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.id=e,this._prim=t,this._kdf=n;let i=new Uint8Array(Ze);i.set(pe(this.id,2),3),this._kdf.init(i)}async serializePublicKey(e){return await this._prim.serializePublicKey(e)}async deserializePublicKey(e){return await this._prim.deserializePublicKey(e)}async serializePrivateKey(e){return await this._prim.serializePrivateKey(e)}async deserializePrivateKey(e){return await this._prim.deserializePrivateKey(e)}async importKey(e,t,n=!0){return await this._prim.importKey(e,t,n)}async generateKeyPair(){return await this._prim.generateKeyPair()}async deriveKeyPair(e){if(e.byteLength>8192)throw new J("Too long ikm");return await this._prim.deriveKeyPair(e)}async encap(e){let t;e.ekm===void 0?t=await this.generateKeyPair():ce(e.ekm)?t=e.ekm:t=await this.deriveKeyPair(e.ekm);let n=await this._prim.serializePublicKey(t.publicKey),i=await this._prim.serializePublicKey(e.recipientPublicKey);try{let o;if(e.senderKey===void 0)o=new Uint8Array(await this._prim.dh(t.privateKey,e.recipientPublicKey));else{let a=ce(e.senderKey)?e.senderKey.privateKey:e.senderKey,u=new Uint8Array(await this._prim.dh(t.privateKey,e.recipientPublicKey)),y=new Uint8Array(await this._prim.dh(a,e.recipientPublicKey));o=we(u,y)}let c;if(e.senderKey===void 0)c=we(new Uint8Array(n),new Uint8Array(i));else{let a=ce(e.senderKey)?e.senderKey.publicKey:await this._prim.derivePublicKey(e.senderKey),u=await this._prim.serializePublicKey(a);c=lr(new Uint8Array(n),new Uint8Array(i),new Uint8Array(u))}let s=await this._generateSharedSecret(o,c);return{enc:n,sharedSecret:s}}catch(o){throw new Me(o)}}async decap(e){let t=await this._prim.deserializePublicKey(e.enc),n=ce(e.recipientKey)?e.recipientKey.privateKey:e.recipientKey,i=ce(e.recipientKey)?e.recipientKey.publicKey:await this._prim.derivePublicKey(e.recipientKey),o=await this._prim.serializePublicKey(i);try{let c;if(e.senderPublicKey===void 0)c=new Uint8Array(await this._prim.dh(n,t));else{let a=new Uint8Array(await this._prim.dh(n,t)),u=new Uint8Array(await this._prim.dh(n,e.senderPublicKey));c=we(a,u)}let s;if(e.senderPublicKey===void 0)s=we(new Uint8Array(e.enc),new Uint8Array(o));else{let a=await this._prim.serializePublicKey(e.senderPublicKey);s=new Uint8Array(e.enc.byteLength+o.byteLength+a.byteLength),s.set(new Uint8Array(e.enc),0),s.set(new Uint8Array(o),e.enc.byteLength),s.set(new Uint8Array(a),e.enc.byteLength+o.byteLength)}return await this._generateSharedSecret(c,s)}catch(c){throw new $e(c)}}async _generateSharedSecret(e,t){let n=this._kdf.buildLabeledIkm(ur,e),i=this._kdf.buildLabeledInfo(fr,t,this.secretSize);return await this._kdf.extractAndExpand(V,n,i,this.secretSize)}};var ge=["deriveBits"],Ae=new Uint8Array([100,107,112,95,112,114,107]),Te=new Uint8Array([115,107]);var Pi=new Uint8Array([99,97,110,100,105,100,97,116,101]),Si=new Uint8Array([255,255,255,255,0,0,0,0,255,255,255,255,255,255,255,255,188,230,250,173,167,23,158,132,243,185,202,194,252,99,37,81]),Ai=new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,199,99,77,129,244,55,45,223,88,26,13,178,72,176,167,122,236,236,25,106,204,197,41,115]),Ki=new Uint8Array([1,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,81,134,135,131,191,47,150,107,127,204,1,72,247,9,165,208,59,181,201,184,137,156,71,174,187,111,183,30,145,56,100,9]),Bi=new Uint8Array([48,65,2,1,0,48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7,4,39,48,37,2,1,1,4,32]),Ii=new Uint8Array([48,78,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,34,4,55,48,53,2,1,1,4,48]),Li=new Uint8Array([48,96,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,35,4,73,48,71,2,1,1,4,66]);var Ne=class extends He{};var X=class{constructor(e,t,n,i=[]){Object.defineProperty(this,"key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extractable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"algorithm",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"usages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.key=t,this.type=n,this.algorithm={name:e},this.usages=i,n==="public"&&(this.usages=[])}};function Bt(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`positive integer expected, not ${r}`)}function br(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function Ke(r,...e){if(!br(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${r.length}`)}function It(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Bt(r.outputLen),Bt(r.blockLen)}function Be(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Lt(r,e){Ke(r);let t=e.outputLen;if(r.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var Ye=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var We=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),Z=(r,e)=>r<<32-e|r>>>e;var Io=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function pr(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function je(r){return typeof r=="string"&&(r=pr(r)),Ke(r),r}function Ot(...r){let e=0;for(let n=0;n<r.length;n++){let i=r[n];Ke(i),e+=i.length}let t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){let o=r[n];t.set(o,i),i+=o.length}return t}var Ie=class{clone(){return this._cloneInto()}},Lo={}.toString;function Ut(r){let e=n=>r().update(je(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function zt(r=32){if(Ye&&typeof Ye.getRandomValues=="function")return Ye.getRandomValues(new Uint8Array(r));throw new Error("crypto.getRandomValues must be defined")}var Xe=class extends Ie{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,It(e);let n=je(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,o=new Uint8Array(i);o.set(n.length>i?e.create().update(n).digest():n);for(let c=0;c<o.length;c++)o[c]^=54;this.iHash.update(o),this.oHash=e.create();for(let c=0;c<o.length;c++)o[c]^=106;this.oHash.update(o),o.fill(0)}update(e){return Be(this),this.iHash.update(e),this}digestInto(e){Be(this),Ke(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:n,finished:i,destroyed:o,blockLen:c,outputLen:s}=this;return e=e,e.finished=i,e.destroyed=o,e.blockLen=c,e.outputLen=s,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},Re=(r,e,t)=>new Xe(r,e).update(t).digest();Re.create=(r,e)=>new Xe(r,e);function wr(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);let i=BigInt(32),o=BigInt(4294967295),c=Number(t>>i&o),s=Number(t&o),a=n?4:0,u=n?0:4;r.setUint32(e+a,c,n),r.setUint32(e+u,s,n)}var Ht=(r,e,t)=>r&e^~r&t,Tt=(r,e,t)=>r&e^r&t^e&t,Qe=class extends Ie{constructor(e,t,n,i){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=We(this.buffer)}update(e){Be(this);let{view:t,buffer:n,blockLen:i}=this;e=je(e);let o=e.length;for(let c=0;c<o;){let s=Math.min(i-this.pos,o-c);if(s===i){let a=We(e);for(;i<=o-c;c+=i)this.process(a,c);continue}n.set(e.subarray(c,c+s),this.pos),this.pos+=s,c+=s,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Be(this),Lt(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:i,isLE:o}=this,{pos:c}=this;t[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>i-c&&(this.process(n,0),c=0);for(let l=c;l<i;l++)t[l]=0;wr(n,i-8,BigInt(this.length*8),o),this.process(n,0);let s=We(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let u=a/4,y=this.get();if(u>y.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<u;l++)s.setUint32(4*l,y[l],o)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:i,finished:o,destroyed:c,pos:s}=this;return e.length=i,e.pos=s,e.finished=o,e.destroyed=c,i%t&&e.buffer.set(n),e}};var mr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ue=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),fe=new Uint32Array(64),ut=class extends Qe{constructor(){super(64,32,8,!1),this.A=ue[0]|0,this.B=ue[1]|0,this.C=ue[2]|0,this.D=ue[3]|0,this.E=ue[4]|0,this.F=ue[5]|0,this.G=ue[6]|0,this.H=ue[7]|0}get(){let{A:e,B:t,C:n,D:i,E:o,F:c,G:s,H:a}=this;return[e,t,n,i,o,c,s,a]}set(e,t,n,i,o,c,s,a){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=o|0,this.F=c|0,this.G=s|0,this.H=a|0}process(e,t){for(let l=0;l<16;l++,t+=4)fe[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){let g=fe[l-15],S=fe[l-2],m=Z(g,7)^Z(g,18)^g>>>3,f=Z(S,17)^Z(S,19)^S>>>10;fe[l]=f+fe[l-7]+m+fe[l-16]|0}let{A:n,B:i,C:o,D:c,E:s,F:a,G:u,H:y}=this;for(let l=0;l<64;l++){let g=Z(s,6)^Z(s,11)^Z(s,25),S=y+g+Ht(s,a,u)+mr[l]+fe[l]|0,f=(Z(n,2)^Z(n,13)^Z(n,22))+Tt(n,i,o)|0;y=u,u=a,a=s,s=c+S|0,c=o,o=i,i=n,n=S+f|0}n=n+this.A|0,i=i+this.B|0,o=o+this.C|0,c=c+this.D|0,s=s+this.E|0,a=a+this.F|0,u=u+this.G|0,y=y+this.H|0,this.set(n,i,o,c,s,a,u,y)}roundClean(){fe.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var Je=Ut(()=>new ut);var Le=class extends Ne{async extract(e,t){if(await this._setup(),e.byteLength===0&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)return Re(Je,new Uint8Array(e),new Uint8Array(t));let n=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,t)}};var ht={};tr(ht,{abytes:()=>Oe,bitGet:()=>Pr,bitLen:()=>kr,bitMask:()=>De,bitSet:()=>Sr,bytesToHex:()=>xe,bytesToNumberBE:()=>te,bytesToNumberLE:()=>et,concatBytes:()=>Ue,createHmacDrbg:()=>dt,ensureBytes:()=>D,equalBytes:()=>vr,hexToBytes:()=>_e,hexToNumber:()=>lt,isBytes:()=>le,numberToBytesBE:()=>de,numberToBytesLE:()=>tt,numberToHexUnpadded:()=>Dt,numberToVarBytesBE:()=>_r,utf8ToBytes:()=>Er,validateObject:()=>he});var Rt=BigInt(0),Fe=BigInt(1),gr=BigInt(2);function le(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function Oe(r){if(!le(r))throw new Error("Uint8Array expected")}var xr=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function xe(r){Oe(r);let e="";for(let t=0;t<r.length;t++)e+=xr[r[t]];return e}function Dt(r){let e=r.toString(16);return e.length&1?`0${e}`:e}function lt(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}var ee={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Nt(r){if(r>=ee._0&&r<=ee._9)return r-ee._0;if(r>=ee._A&&r<=ee._F)return r-(ee._A-10);if(r>=ee._a&&r<=ee._f)return r-(ee._a-10)}function _e(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let e=r.length,t=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);let n=new Uint8Array(t);for(let i=0,o=0;i<t;i++,o+=2){let c=Nt(r.charCodeAt(o)),s=Nt(r.charCodeAt(o+1));if(c===void 0||s===void 0){let a=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+o)}n[i]=c*16+s}return n}function te(r){return lt(xe(r))}function et(r){return Oe(r),lt(xe(Uint8Array.from(r).reverse()))}function de(r,e){return _e(r.toString(16).padStart(e*2,"0"))}function tt(r,e){return de(r,e).reverse()}function _r(r){return _e(Dt(r))}function D(r,e,t){let n;if(typeof e=="string")try{n=_e(e)}catch(o){throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${o}`)}else if(le(e))n=Uint8Array.from(e);else throw new Error(`${r} must be hex string or Uint8Array`);let i=n.length;if(typeof t=="number"&&i!==t)throw new Error(`${r} expected ${t} bytes, got ${i}`);return n}function Ue(...r){let e=0;for(let n=0;n<r.length;n++){let i=r[n];Oe(i),e+=i.length}let t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){let o=r[n];t.set(o,i),i+=o.length}return t}function vr(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}function Er(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function kr(r){let e;for(e=0;r>Rt;r>>=Fe,e+=1);return e}function Pr(r,e){return r>>BigInt(e)&Fe}function Sr(r,e,t){return r|(t?Fe:Rt)<<BigInt(e)}var De=r=>(gr<<BigInt(r-1))-Fe,ft=r=>new Uint8Array(r),jt=r=>Uint8Array.from(r);function dt(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=ft(r),i=ft(r),o=0,c=()=>{n.fill(1),i.fill(0),o=0},s=(...l)=>t(i,n,...l),a=(l=ft())=>{i=s(jt([0]),l),n=s(),l.length!==0&&(i=s(jt([1]),l),n=s())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let l=0,g=[];for(;l<e;){n=s();let S=n.slice();g.push(S),l+=n.length}return Ue(...g)};return(l,g)=>{c(),a(l);let S;for(;!(S=g(u()));)a();return c(),S}}var Ar={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||le(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function he(r,e,t={}){let n=(i,o,c)=>{let s=Ar[o];if(typeof s!="function")throw new Error(`Invalid validator "${o}", expected function`);let a=r[i];if(!(c&&a===void 0)&&!s(a,r))throw new Error(`Invalid param ${String(i)}=${a} (${typeof a}), expected ${o}`)};for(let[i,o]of Object.entries(e))n(i,o,!1);for(let[i,o]of Object.entries(t))n(i,o,!0);return r}var U=BigInt(0),O=BigInt(1),ve=BigInt(2),Kr=BigInt(3),yt=BigInt(4),Ct=BigInt(5),qt=BigInt(8),Br=BigInt(9),Ir=BigInt(16);function H(r,e){let t=r%e;return t>=U?t:e+t}function Lr(r,e,t){if(t<=U||e<U)throw new Error("Expected power/modulo > 0");if(t===O)return U;let n=O;for(;e>U;)e&O&&(n=n*r%t),r=r*r%t,e>>=O;return n}function C(r,e,t){let n=r;for(;e-- >U;)n*=n,n%=t;return n}function rt(r,e){if(r===U||e<=U)throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);let t=H(r,e),n=e,i=U,o=O,c=O,s=U;for(;t!==U;){let u=n/t,y=n%t,l=i-c*u,g=o-s*u;n=t,t=y,i=c,o=s,c=l,s=g}if(n!==O)throw new Error("invert: does not exist");return H(i,e)}function Or(r){let e=(r-O)/ve,t,n,i;for(t=r-O,n=0;t%ve===U;t/=ve,n++);for(i=ve;i<r&&Lr(i,e,r)!==r-O;i++);if(n===1){let c=(r+O)/yt;return function(a,u){let y=a.pow(u,c);if(!a.eql(a.sqr(y),u))throw new Error("Cannot find square root");return y}}let o=(t+O)/ve;return function(s,a){if(s.pow(a,e)===s.neg(s.ONE))throw new Error("Cannot find square root");let u=n,y=s.pow(s.mul(s.ONE,i),t),l=s.pow(a,o),g=s.pow(a,t);for(;!s.eql(g,s.ONE);){if(s.eql(g,s.ZERO))return s.ZERO;let S=1;for(let f=s.sqr(g);S<u&&!s.eql(f,s.ONE);S++)f=s.sqr(f);let m=s.pow(y,O<<BigInt(u-S-1));y=s.sqr(m),l=s.mul(l,m),g=s.mul(g,y),u=S}return l}}function Ur(r){if(r%yt===Kr){let e=(r+O)/yt;return function(n,i){let o=n.pow(i,e);if(!n.eql(n.sqr(o),i))throw new Error("Cannot find square root");return o}}if(r%qt===Ct){let e=(r-Ct)/qt;return function(n,i){let o=n.mul(i,ve),c=n.pow(o,e),s=n.mul(i,c),a=n.mul(n.mul(s,ve),c),u=n.mul(s,n.sub(a,n.ONE));if(!n.eql(n.sqr(u),i))throw new Error("Cannot find square root");return u}}return r%Ir,Or(r)}var zr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function bt(r){let e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=zr.reduce((n,i)=>(n[i]="function",n),e);return he(r,t)}function Hr(r,e,t){if(t<U)throw new Error("Expected power > 0");if(t===U)return r.ONE;if(t===O)return e;let n=r.ONE,i=e;for(;t>U;)t&O&&(n=r.mul(n,i)),i=r.sqr(i),t>>=O;return n}function Tr(r,e){let t=new Array(e.length),n=e.reduce((o,c,s)=>r.is0(c)?o:(t[s]=o,r.mul(o,c)),r.ONE),i=r.inv(n);return e.reduceRight((o,c,s)=>r.is0(c)?o:(t[s]=r.mul(o,t[s]),r.mul(o,c)),i),t}function pt(r,e){let t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function Mt(r,e,t=!1,n={}){if(r<=U)throw new Error(`Expected Field ORDER > 0, got ${r}`);let{nBitLength:i,nByteLength:o}=pt(r,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");let c=Ur(r),s=Object.freeze({ORDER:r,BITS:i,BYTES:o,MASK:De(i),ZERO:U,ONE:O,create:a=>H(a,r),isValid:a=>{if(typeof a!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof a}`);return U<=a&&a<r},is0:a=>a===U,isOdd:a=>(a&O)===O,neg:a=>H(-a,r),eql:(a,u)=>a===u,sqr:a=>H(a*a,r),add:(a,u)=>H(a+u,r),sub:(a,u)=>H(a-u,r),mul:(a,u)=>H(a*u,r),pow:(a,u)=>Hr(s,a,u),div:(a,u)=>H(a*rt(u,r),r),sqrN:a=>a*a,addN:(a,u)=>a+u,subN:(a,u)=>a-u,mulN:(a,u)=>a*u,inv:a=>rt(a,r),sqrt:n.sqrt||(a=>c(s,a)),invertBatch:a=>Tr(s,a),cmov:(a,u,y)=>y?u:a,toBytes:a=>t?tt(a,o):de(a,o),fromBytes:a=>{if(a.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${a.length}`);return t?et(a):te(a)}});return Object.freeze(s)}function $t(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let e=r.toString(2).length;return Math.ceil(e/8)}function wt(r){let e=$t(r);return e+Math.ceil(e/2)}function Gt(r,e,t=!1){let n=r.length,i=$t(e),o=wt(e);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);let c=t?te(r):et(r),s=H(c,e-O)+O;return t?tt(s,i):de(s,i)}var jr=BigInt(0),mt=BigInt(1);function Vt(r,e){let t=(i,o)=>{let c=o.negate();return i?c:o},n=i=>{let o=Math.ceil(e/i)+1,c=2**(i-1);return{windows:o,windowSize:c}};return{constTimeNegate:t,unsafeLadder(i,o){let c=r.ZERO,s=i;for(;o>jr;)o&mt&&(c=c.add(s)),s=s.double(),o>>=mt;return c},precomputeWindow(i,o){let{windows:c,windowSize:s}=n(o),a=[],u=i,y=u;for(let l=0;l<c;l++){y=u,a.push(y);for(let g=1;g<s;g++)y=y.add(u),a.push(y);u=y.double()}return a},wNAF(i,o,c){let{windows:s,windowSize:a}=n(i),u=r.ZERO,y=r.BASE,l=BigInt(2**i-1),g=2**i,S=BigInt(i);for(let m=0;m<s;m++){let f=m*a,h=Number(c&l);c>>=S,h>a&&(h-=g,c+=mt);let b=f,x=f+Math.abs(h)-1,v=m%2!==0,A=h<0;h===0?y=y.add(t(v,o[b])):u=u.add(t(A,o[x]))}return{p:u,f:y}},wNAFCached(i,o,c,s){let a=i._WINDOW_SIZE||1,u=o.get(i);return u||(u=this.precomputeWindow(i,a),a!==1&&o.set(i,s(u))),this.wNAF(a,u,c)}}}function gt(r){return bt(r.Fp),he(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...pt(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var Qo=new Uint8Array;function Dr(r){let e=gt(r);he(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:t,Fp:n,a:i}=e;if(t){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}var{bytesToNumberBE:Cr,hexToBytes:qr}=ht,Ee={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(r){let{Err:e}=Ee;if(r.length<2||r[0]!==2)throw new e("Invalid signature integer tag");let t=r[1],n=r.subarray(2,t+2);if(!t||n.length!==t)throw new e("Invalid signature integer: wrong length");if(n[0]&128)throw new e("Invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Cr(n),l:r.subarray(t+2)}},toSig(r){let{Err:e}=Ee,t=typeof r=="string"?qr(r):r;Oe(t);let n=t.length;if(n<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==n-2)throw new e("Invalid signature: incorrect length");let{d:i,l:o}=Ee._parseInt(t.subarray(2)),{d:c,l:s}=Ee._parseInt(o);if(s.length)throw new e("Invalid signature: left bytes after parsing");return{r:i,s:c}},hexFromSig(r){let e=u=>Number.parseInt(u[0],16)&8?"00"+u:u,t=u=>{let y=u.toString(16);return y.length&1?`0${y}`:y},n=e(t(r.s)),i=e(t(r.r)),o=n.length/2,c=i.length/2,s=t(o),a=t(c);return`30${t(c+o+4)}02${a}${i}02${s}${n}`}},re=BigInt(0),M=BigInt(1),ls=BigInt(2),Zt=BigInt(3),ds=BigInt(4);function Mr(r){let e=Dr(r),{Fp:t}=e,n=e.toBytes||((m,f,h)=>{let b=f.toAffine();return Ue(Uint8Array.from([4]),t.toBytes(b.x),t.toBytes(b.y))}),i=e.fromBytes||(m=>{let f=m.subarray(1),h=t.fromBytes(f.subarray(0,t.BYTES)),b=t.fromBytes(f.subarray(t.BYTES,2*t.BYTES));return{x:h,y:b}});function o(m){let{a:f,b:h}=e,b=t.sqr(m),x=t.mul(b,m);return t.add(t.add(x,t.mul(m,f)),h)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function c(m){return typeof m=="bigint"&&re<m&&m<e.n}function s(m){if(!c(m))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function a(m){let{allowedPrivateKeyLengths:f,nByteLength:h,wrapPrivateKey:b,n:x}=e;if(f&&typeof m!="bigint"){if(le(m)&&(m=xe(m)),typeof m!="string"||!f.includes(m.length))throw new Error("Invalid key");m=m.padStart(h*2,"0")}let v;try{v=typeof m=="bigint"?m:te(D("private key",m,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof m}`)}return b&&(v=H(v,x)),s(v),v}let u=new Map;function y(m){if(!(m instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(f,h,b){if(this.px=f,this.py=h,this.pz=b,f==null||!t.isValid(f))throw new Error("x required");if(h==null||!t.isValid(h))throw new Error("y required");if(b==null||!t.isValid(b))throw new Error("z required")}static fromAffine(f){let{x:h,y:b}=f||{};if(!f||!t.isValid(h)||!t.isValid(b))throw new Error("invalid affine point");if(f instanceof l)throw new Error("projective point not allowed");let x=v=>t.eql(v,t.ZERO);return x(h)&&x(b)?l.ZERO:new l(h,b,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){let h=t.invertBatch(f.map(b=>b.pz));return f.map((b,x)=>b.toAffine(h[x])).map(l.fromAffine)}static fromHex(f){let h=l.fromAffine(i(D("pointHex",f)));return h.assertValidity(),h}static fromPrivateKey(f){return l.BASE.multiply(a(f))}_setWindowSize(f){this._WINDOW_SIZE=f,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!t.is0(this.py))return;throw new Error("bad point: ZERO")}let{x:f,y:h}=this.toAffine();if(!t.isValid(f)||!t.isValid(h))throw new Error("bad point: x or y not FE");let b=t.sqr(h),x=o(f);if(!t.eql(b,x))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){let{y:f}=this.toAffine();if(t.isOdd)return!t.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){y(f);let{px:h,py:b,pz:x}=this,{px:v,py:A,pz:P}=f,w=t.eql(t.mul(h,P),t.mul(v,x)),_=t.eql(t.mul(b,P),t.mul(A,x));return w&&_}negate(){return new l(this.px,t.neg(this.py),this.pz)}double(){let{a:f,b:h}=e,b=t.mul(h,Zt),{px:x,py:v,pz:A}=this,P=t.ZERO,w=t.ZERO,_=t.ZERO,k=t.mul(x,x),q=t.mul(v,v),L=t.mul(A,A),K=t.mul(x,v);return K=t.add(K,K),_=t.mul(x,A),_=t.add(_,_),P=t.mul(f,_),w=t.mul(b,L),w=t.add(P,w),P=t.sub(q,w),w=t.add(q,w),w=t.mul(P,w),P=t.mul(K,P),_=t.mul(b,_),L=t.mul(f,L),K=t.sub(k,L),K=t.mul(f,K),K=t.add(K,_),_=t.add(k,k),k=t.add(_,k),k=t.add(k,L),k=t.mul(k,K),w=t.add(w,k),L=t.mul(v,A),L=t.add(L,L),k=t.mul(L,K),P=t.sub(P,k),_=t.mul(L,q),_=t.add(_,_),_=t.add(_,_),new l(P,w,_)}add(f){y(f);let{px:h,py:b,pz:x}=this,{px:v,py:A,pz:P}=f,w=t.ZERO,_=t.ZERO,k=t.ZERO,q=e.a,L=t.mul(e.b,Zt),K=t.mul(h,v),j=t.mul(b,A),R=t.mul(x,P),ne=t.add(h,b),d=t.add(v,A);ne=t.mul(ne,d),d=t.add(K,j),ne=t.sub(ne,d),d=t.add(h,x);let p=t.add(v,P);return d=t.mul(d,p),p=t.add(K,R),d=t.sub(d,p),p=t.add(b,x),w=t.add(A,P),p=t.mul(p,w),w=t.add(j,R),p=t.sub(p,w),k=t.mul(q,d),w=t.mul(L,R),k=t.add(w,k),w=t.sub(j,k),k=t.add(j,k),_=t.mul(w,k),j=t.add(K,K),j=t.add(j,K),R=t.mul(q,R),d=t.mul(L,d),j=t.add(j,R),R=t.sub(K,R),R=t.mul(q,R),d=t.add(d,R),K=t.mul(j,d),_=t.add(_,K),K=t.mul(p,d),w=t.mul(ne,w),w=t.sub(w,K),K=t.mul(ne,j),k=t.mul(p,k),k=t.add(k,K),new l(w,_,k)}subtract(f){return this.add(f.negate())}is0(){return this.equals(l.ZERO)}wNAF(f){return S.wNAFCached(this,u,f,h=>{let b=t.invertBatch(h.map(x=>x.pz));return h.map((x,v)=>x.toAffine(b[v])).map(l.fromAffine)})}multiplyUnsafe(f){let h=l.ZERO;if(f===re)return h;if(s(f),f===M)return this;let{endo:b}=e;if(!b)return S.unsafeLadder(this,f);let{k1neg:x,k1:v,k2neg:A,k2:P}=b.splitScalar(f),w=h,_=h,k=this;for(;v>re||P>re;)v&M&&(w=w.add(k)),P&M&&(_=_.add(k)),k=k.double(),v>>=M,P>>=M;return x&&(w=w.negate()),A&&(_=_.negate()),_=new l(t.mul(_.px,b.beta),_.py,_.pz),w.add(_)}multiply(f){s(f);let h=f,b,x,{endo:v}=e;if(v){let{k1neg:A,k1:P,k2neg:w,k2:_}=v.splitScalar(h),{p:k,f:q}=this.wNAF(P),{p:L,f:K}=this.wNAF(_);k=S.constTimeNegate(A,k),L=S.constTimeNegate(w,L),L=new l(t.mul(L.px,v.beta),L.py,L.pz),b=k.add(L),x=q.add(K)}else{let{p:A,f:P}=this.wNAF(h);b=A,x=P}return l.normalizeZ([b,x])[0]}multiplyAndAddUnsafe(f,h,b){let x=l.BASE,v=(P,w)=>w===re||w===M||!P.equals(x)?P.multiplyUnsafe(w):P.multiply(w),A=v(this,h).add(v(f,b));return A.is0()?void 0:A}toAffine(f){let{px:h,py:b,pz:x}=this,v=this.is0();f==null&&(f=v?t.ONE:t.inv(x));let A=t.mul(h,f),P=t.mul(b,f),w=t.mul(x,f);if(v)return{x:t.ZERO,y:t.ZERO};if(!t.eql(w,t.ONE))throw new Error("invZ was invalid");return{x:A,y:P}}isTorsionFree(){let{h:f,isTorsionFree:h}=e;if(f===M)return!0;if(h)return h(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:f,clearCofactor:h}=e;return f===M?this:h?h(l,this):this.multiplyUnsafe(e.h)}toRawBytes(f=!0){return this.assertValidity(),n(l,this,f)}toHex(f=!0){return xe(this.toRawBytes(f))}}l.BASE=new l(e.Gx,e.Gy,t.ONE),l.ZERO=new l(t.ZERO,t.ONE,t.ZERO);let g=e.nBitLength,S=Vt(l,e.endo?Math.ceil(g/2):g);return{CURVE:e,ProjectivePoint:l,normPrivateKeyToScalar:a,weierstrassEquation:o,isWithinCurveOrder:c}}function $r(r){let e=gt(r);return he(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Yt(r){let e=$r(r),{Fp:t,n}=e,i=t.BYTES+1,o=2*t.BYTES+1;function c(d){return re<d&&d<t.ORDER}function s(d){return H(d,n)}function a(d){return rt(d,n)}let{ProjectivePoint:u,normPrivateKeyToScalar:y,weierstrassEquation:l,isWithinCurveOrder:g}=Mr({...e,toBytes(d,p,E){let I=p.toAffine(),B=t.toBytes(I.x),z=Ue;return E?z(Uint8Array.from([p.hasEvenY()?2:3]),B):z(Uint8Array.from([4]),B,t.toBytes(I.y))},fromBytes(d){let p=d.length,E=d[0],I=d.subarray(1);if(p===i&&(E===2||E===3)){let B=te(I);if(!c(B))throw new Error("Point is not on curve");let z=l(B),T;try{T=t.sqrt(z)}catch($){let oe=$ instanceof Error?": "+$.message:"";throw new Error("Point is not on curve"+oe)}let N=(T&M)===M;return(E&1)===1!==N&&(T=t.neg(T)),{x:B,y:T}}else if(p===o&&E===4){let B=t.fromBytes(I.subarray(0,t.BYTES)),z=t.fromBytes(I.subarray(t.BYTES,2*t.BYTES));return{x:B,y:z}}else throw new Error(`Point of length ${p} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}}),S=d=>xe(de(d,e.nByteLength));function m(d){let p=n>>M;return d>p}function f(d){return m(d)?s(-d):d}let h=(d,p,E)=>te(d.slice(p,E));class b{constructor(p,E,I){this.r=p,this.s=E,this.recovery=I,this.assertValidity()}static fromCompact(p){let E=e.nByteLength;return p=D("compactSignature",p,E*2),new b(h(p,0,E),h(p,E,2*E))}static fromDER(p){let{r:E,s:I}=Ee.toSig(D("DER",p));return new b(E,I)}assertValidity(){if(!g(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!g(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(p){return new b(this.r,this.s,p)}recoverPublicKey(p){let{r:E,s:I,recovery:B}=this,z=_(D("msgHash",p));if(B==null||![0,1,2,3].includes(B))throw new Error("recovery id invalid");let T=B===2||B===3?E+e.n:E;if(T>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");let N=B&1?"03":"02",ie=u.fromHex(N+S(T)),$=a(T),oe=s(-z*$),ze=s(I*$),se=u.BASE.multiplyAndAddUnsafe(ie,oe,ze);if(!se)throw new Error("point at infinify");return se.assertValidity(),se}hasHighS(){return m(this.s)}normalizeS(){return this.hasHighS()?new b(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return _e(this.toDERHex())}toDERHex(){return Ee.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return _e(this.toCompactHex())}toCompactHex(){return S(this.r)+S(this.s)}}let x={isValidPrivateKey(d){try{return y(d),!0}catch{return!1}},normPrivateKeyToScalar:y,randomPrivateKey:()=>{let d=wt(e.n);return Gt(e.randomBytes(d),e.n)},precompute(d=8,p=u.BASE){return p._setWindowSize(d),p.multiply(BigInt(3)),p}};function v(d,p=!0){return u.fromPrivateKey(d).toRawBytes(p)}function A(d){let p=le(d),E=typeof d=="string",I=(p||E)&&d.length;return p?I===i||I===o:E?I===2*i||I===2*o:d instanceof u}function P(d,p,E=!0){if(A(d))throw new Error("first arg must be private key");if(!A(p))throw new Error("second arg must be public key");return u.fromHex(p).multiply(y(d)).toRawBytes(E)}let w=e.bits2int||function(d){let p=te(d),E=d.length*8-e.nBitLength;return E>0?p>>BigInt(E):p},_=e.bits2int_modN||function(d){return s(w(d))},k=De(e.nBitLength);function q(d){if(typeof d!="bigint")throw new Error("bigint expected");if(!(re<=d&&d<k))throw new Error(`bigint expected < 2^${e.nBitLength}`);return de(d,e.nByteLength)}function L(d,p,E=K){if(["recovered","canonical"].some(ye=>ye in E))throw new Error("sign() legacy options not supported");let{hash:I,randomBytes:B}=e,{lowS:z,prehash:T,extraEntropy:N}=E;z==null&&(z=!0),d=D("msgHash",d),T&&(d=D("prehashed msgHash",I(d)));let ie=_(d),$=y(p),oe=[q($),q(ie)];if(N!=null&&N!==!1){let ye=N===!0?B(t.BYTES):N;oe.push(D("extraEntropy",ye))}let ze=Ue(...oe),se=ie;function ot(ye){let ke=w(ye);if(!g(ke))return;let Et=a(ke),Y=u.BASE.multiply(ke).toAffine(),Pe=s(Y.x);if(Pe===re)return;let qe=s(Et*s(se+Pe*$));if(qe===re)return;let kt=(Y.x===Pe?0:2)|Number(Y.y&M),Pt=qe;return z&&m(qe)&&(Pt=f(qe),kt^=1),new b(Pe,Pt,kt)}return{seed:ze,k2sig:ot}}let K={lowS:e.lowS,prehash:!1},j={lowS:e.lowS,prehash:!1};function R(d,p,E=K){let{seed:I,k2sig:B}=L(d,p,E),z=e;return dt(z.hash.outputLen,z.nByteLength,z.hmac)(I,B)}u.BASE._setWindowSize(8);function ne(d,p,E,I=j){let B=d;if(p=D("msgHash",p),E=D("publicKey",E),"strict"in I)throw new Error("options.strict was renamed to lowS");let{lowS:z,prehash:T}=I,N,ie;try{if(typeof B=="string"||le(B))try{N=b.fromDER(B)}catch(Y){if(!(Y instanceof Ee.Err))throw Y;N=b.fromCompact(B)}else if(typeof B=="object"&&typeof B.r=="bigint"&&typeof B.s=="bigint"){let{r:Y,s:Pe}=B;N=new b(Y,Pe)}else throw new Error("PARSE");ie=u.fromHex(E)}catch(Y){if(Y.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(z&&N.hasHighS())return!1;T&&(p=e.hash(p));let{r:$,s:oe}=N,ze=_(p),se=a(oe),ot=s(ze*se),ye=s($*se),ke=u.BASE.multiplyAndAddUnsafe(ie,ot,ye)?.toAffine();return ke?s(ke.x)===$:!1}return{CURVE:e,getPublicKey:v,getSharedSecret:P,sign:R,verify:ne,ProjectivePoint:u,Signature:b,utils:x}}function Gr(r){return{hash:r,hmac:(e,...t)=>Re(r,e,Ot(...t)),randomBytes:zt}}function Wt(r,e){let t=n=>Yt({...r,...Gr(n)});return Object.freeze({...t(e),create:t})}var Jt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Xt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Vr=BigInt(1),xt=BigInt(2),Qt=(r,e)=>(r+e/xt)/e;function Zr(r){let e=Jt,t=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),c=BigInt(23),s=BigInt(44),a=BigInt(88),u=r*r*r%e,y=u*u*r%e,l=C(y,t,e)*y%e,g=C(l,t,e)*y%e,S=C(g,xt,e)*u%e,m=C(S,i,e)*S%e,f=C(m,o,e)*m%e,h=C(f,s,e)*f%e,b=C(h,a,e)*h%e,x=C(b,s,e)*f%e,v=C(x,t,e)*y%e,A=C(v,c,e)*m%e,P=C(A,n,e)*u%e,w=C(P,xt,e);if(!_t.eql(_t.sqr(w),r))throw new Error("Cannot find square root");return w}var _t=Mt(Jt,void 0,void 0,{sqrt:Zr}),Ce=Wt({a:BigInt(0),b:BigInt(7),Fp:_t,n:Xt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{let e=Xt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Vr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,c=BigInt("0x100000000000000000000000000000000"),s=Qt(o*r,e),a=Qt(-n*r,e),u=H(r-s*t-a*i,e),y=H(-s*n-a*o,e),l=u>c,g=y>c;if(l&&(u=e-u),g&&(y=e-y),u>c||y>c)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:l,k1:u,k2neg:g,k2:y}}}},Je),_s=BigInt(0);var vs=Ce.ProjectivePoint;var nt="ECDH",Ft=new Uint8Array,it=class{constructor(e){Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=e,this._nPk=33,this._nSk=32}async serializePublicKey(e){try{return await this._serializePublicKey(e)}catch(t){throw new F(t)}}async deserializePublicKey(e){try{return await this._importRawKey(e,!0)}catch(t){throw new W(t)}}async serializePrivateKey(e){try{return await this._serializePrivateKey(e)}catch(t){throw new F(t)}}async deserializePrivateKey(e){try{return await this._importRawKey(e,!1)}catch(t){throw new W(t)}}async importKey(e,t,n){try{if(e!=="raw")throw new Error("Unsupported format");return await this._importRawKey(t,n)}catch(i){throw new W(i)}}async generateKeyPair(){try{let e=Ce.utils.randomPrivateKey(),t=new X(nt,e,"private",ge);return{publicKey:await this.derivePublicKey(t),privateKey:t}}catch(e){throw new G(e)}}async deriveKeyPair(e){try{let t=await this._hkdf.labeledExtract(Ft,Ae,new Uint8Array(e)),n=await this._hkdf.labeledExpand(t,Te,Ft,this._nSk),i=new X(nt,new Uint8Array(n),"private",ge);return{privateKey:i,publicKey:await this.derivePublicKey(i)}}catch(t){throw new Se(t)}}async derivePublicKey(e){try{return await this._derivePublicKey(e)}catch(t){throw new W(t)}}async dh(e,t){try{return await this._dh(e,t)}catch(n){throw new F(n)}}_serializePublicKey(e){return new Promise(t=>{t(e.key.buffer)})}_serializePrivateKey(e){return new Promise(t=>{t(e.key.buffer)})}_importRawKey(e,t){return new Promise((n,i)=>{t&&e.byteLength!==this._nPk&&i(new Error("Invalid length of the key")),!t&&e.byteLength!==this._nSk&&i(new Error("Invalid length of the key")),n(new X(nt,new Uint8Array(e),t?"public":"private",t?[]:ge))})}_derivePublicKey(e){return new Promise((t,n)=>{try{let i=Ce.getPublicKey(e.key);t(new X(nt,i,"public"))}catch(i){n(i)}})}_dh(e,t){return new Promise((n,i)=>{try{n(Ce.getSharedSecret(e.key,t.key).buffer)}catch(o){i(o)}})}};var vt=class extends me{constructor(){let e=new Le;super(ae.DhkemSecp256k1HkdfSha256,new it(e),e),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:ae.DhkemSecp256k1HkdfSha256}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:32})}};export{vt as DhkemSecp256k1HkdfSha256};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
