var Ge=Object.defineProperty;var Ye=(r,t)=>{for(var e in t)Ge(r,e,{get:t[e],enumerable:!0})};var We={NotAssigned:0,DhkemP256HkdfSha256:16,DhkemP384HkdfSha384:17,DhkemP521HkdfSha512:18,DhkemSecp256k1HkdfSha256:19,DhkemX25519HkdfSha256:32,DhkemX448HkdfSha512:33,HybridkemX25519Kyber768:48},Xt=We,Xe={HkdfSha256:1,HkdfSha384:2,HkdfSha512:3},Qt=Xe;function ge(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`Wrong positive integer: ${r}`)}function Qe(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function Jt(r,...t){if(!Qe(r))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(r.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${r.length}`)}function me(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ge(r.outputLen),ge(r.blockLen)}function wt(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function xe(r,t){Jt(r);let e=t.outputLen;if(r.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}var kt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function Ee(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}var Lt=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),$=(r,t)=>r<<32-t|r>>>t,Je=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Je)throw new Error("Non little-endian hardware is not supported");function Fe(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function _t(r){if(typeof r=="string"&&(r=Fe(r)),!Ee(r))throw new Error(`expected Uint8Array, got ${typeof r}`);return r}function ve(...r){let t=0;for(let n=0;n<r.length;n++){let i=r[n];if(!Ee(i))throw new Error("Uint8Array expected");t+=i.length}let e=new Uint8Array(t);for(let n=0,i=0;n<r.length;n++){let o=r[n];e.set(o,i),i+=o.length}return e}var pt=class{clone(){return this._cloneInto()}},Vr={}.toString;function Be(r){let t=n=>r().update(_t(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function _e(r=32){if(kt&&typeof kt.getRandomValues=="function")return kt.getRandomValues(new Uint8Array(r));throw new Error("crypto.getRandomValues must be defined")}var Ut=class extends pt{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,me(t);let n=_t(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,o=new Uint8Array(i);o.set(n.length>i?t.create().update(n).digest():n);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=t.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),o.fill(0)}update(t){return wt(this),this.iHash.update(t),this}digestInto(t){wt(this),Jt(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:e,iHash:n,finished:i,destroyed:o,blockLen:a,outputLen:s}=this;return t=t,t.finished=i,t.destroyed=o,t.blockLen=a,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},At=(r,t,e)=>new Ut(r,t).update(e).digest();At.create=(r,t)=>new Ut(r,t);function tr(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let i=BigInt(32),o=BigInt(4294967295),a=Number(e>>i&o),s=Number(e&o),c=n?4:0,u=n?0:4;r.setUint32(t+c,a,n),r.setUint32(t+u,s,n)}var Ot=class extends pt{constructor(t,e,n,i){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Lt(this.buffer)}update(t){wt(this);let{view:e,buffer:n,blockLen:i}=this;t=_t(t);let o=t.length;for(let a=0;a<o;){let s=Math.min(i-this.pos,o-a);if(s===i){let c=Lt(t);for(;i<=o-a;a+=i)this.process(c,a);continue}n.set(t.subarray(a,a+s),this.pos),this.pos+=s,a+=s,this.pos===i&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){wt(this),xe(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:i,isLE:o}=this,{pos:a}=this;e[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>i-a&&(this.process(n,0),a=0);for(let l=a;l<i;l++)e[l]=0;tr(n,i-8,BigInt(this.length*8),o),this.process(n,0);let s=Lt(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let u=c/4,y=this.get();if(u>y.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<u;l++)s.setUint32(4*l,y[l],o)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:i,finished:o,destroyed:a,pos:s}=this;return t.length=i,t.pos=s,t.finished=o,t.destroyed=a,i%e&&t.buffer.set(n),t}};var er=(r,t,e)=>r&t^~r&e,rr=(r,t,e)=>r&t^r&e^t&e,nr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),rt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),nt=new Uint32Array(64),Ft=class extends Ot{constructor(){super(64,32,8,!1),this.A=rt[0]|0,this.B=rt[1]|0,this.C=rt[2]|0,this.D=rt[3]|0,this.E=rt[4]|0,this.F=rt[5]|0,this.G=rt[6]|0,this.H=rt[7]|0}get(){let{A:t,B:e,C:n,D:i,E:o,F:a,G:s,H:c}=this;return[t,e,n,i,o,a,s,c]}set(t,e,n,i,o,a,s,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=i|0,this.E=o|0,this.F=a|0,this.G=s|0,this.H=c|0}process(t,e){for(let l=0;l<16;l++,e+=4)nt[l]=t.getUint32(e,!1);for(let l=16;l<64;l++){let m=nt[l-15],S=nt[l-2],g=$(m,7)^$(m,18)^m>>>3,f=$(S,17)^$(S,19)^S>>>10;nt[l]=f+nt[l-7]+g+nt[l-16]|0}let{A:n,B:i,C:o,D:a,E:s,F:c,G:u,H:y}=this;for(let l=0;l<64;l++){let m=$(s,6)^$(s,11)^$(s,25),S=y+m+er(s,c,u)+nr[l]+nt[l]|0,f=($(n,2)^$(n,13)^$(n,22))+rr(n,i,o)|0;y=u,u=c,c=s,s=a+S|0,a=o,o=i,i=n,n=S+f|0}n=n+this.A|0,i=i+this.B|0,o=o+this.C|0,a=a+this.D|0,s=s+this.E|0,c=c+this.F|0,u=u+this.G|0,y=y+this.H|0,this.set(n,i,o,a,s,c,u,y)}roundClean(){nt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var Tt=Be(()=>new Ft);var ir={},Ae=or(globalThis,ir);function or(r,t){return new Proxy(r,{get(e,n,i){return n in t?t[n]:r[n]},set(e,n,i){return n in t&&delete t[n],r[n]=i,!0},deleteProperty(e,n){let i=!1;return n in t&&(delete t[n],i=!0),n in r&&(delete r[n],i=!0),i},ownKeys(e){let n=Reflect.ownKeys(r),i=Reflect.ownKeys(t),o=new Set(i);return[...n.filter(a=>!o.has(a)),...i]},defineProperty(e,n,i){return n in t&&delete t[n],Reflect.defineProperty(r,n,i),!0},getOwnPropertyDescriptor(e,n){return n in t?Reflect.getOwnPropertyDescriptor(t,n):Reflect.getOwnPropertyDescriptor(r,n)},has(e,n){return n in t||n in r}})}var te=class extends Error{constructor(t){let e;t instanceof Error?e=t.message:typeof t=="string"?e=t:e="",super(e),this.name=this.constructor.name}},G=class extends te{},gt=class extends G{};var mt=class extends G{},ct=class extends G{},Ht=class extends G{},Nt=class extends G{};var qt=class extends G{},xt=class extends G{};async function cr(){if(Ae!==void 0&&globalThis.crypto!==void 0)return globalThis.crypto.subtle;try{let{webcrypto:r}=await import("crypto");return r.subtle}catch(r){throw new xt(r)}}var Rt=class{constructor(){Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}async _setup(){this._api===void 0&&(this._api=await cr())}};var Y=new Uint8Array(0);var Se=new Uint8Array([72,80,75,69,45,118,49]),ee=class extends Rt{constructor(){super(),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Qt.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_suiteId",{enumerable:!0,configurable:!0,writable:!0,value:Y}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}init(t){this._suiteId=t}buildLabeledIkm(t,e){this._checkInit();let n=new Uint8Array(7+this._suiteId.byteLength+t.byteLength+e.byteLength);return n.set(Se,0),n.set(this._suiteId,7),n.set(t,7+this._suiteId.byteLength),n.set(e,7+this._suiteId.byteLength+t.byteLength),n}buildLabeledInfo(t,e,n){this._checkInit();let i=new Uint8Array(9+this._suiteId.byteLength+t.byteLength+e.byteLength);return i.set(new Uint8Array([0,n]),0),i.set(Se,2),i.set(this._suiteId,9),i.set(t,9+this._suiteId.byteLength),i.set(e,9+this._suiteId.byteLength+t.byteLength),i}async extract(t,e){if(await this._setup(),t.byteLength===0&&(t=new ArrayBuffer(this.hashSize)),t.byteLength!==this.hashSize)throw new gt("The salt length must be the same as the hashSize");let n=await this._api.importKey("raw",t,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,e)}async expand(t,e,n){await this._setup();let i=await this._api.importKey("raw",t,this.algHash,!1,["sign"]),o=new ArrayBuffer(n),a=new Uint8Array(o),s=Y,c=new Uint8Array(e),u=new Uint8Array(1);if(n>255*this.hashSize)throw new Error("Entropy limit reached");let y=new Uint8Array(this.hashSize+c.length+1);for(let l=1,m=0;m<a.length;l++)u[0]=l,y.set(s,0),y.set(c,s.length),y.set(u,s.length+c.length),s=new Uint8Array(await this._api.sign("HMAC",i,y.slice(0,s.length+c.length+1))),a.length-m>=s.length?(a.set(s,m),m+=s.length):(a.set(s.slice(0,a.length-m),m),m+=a.length-m);return o}async extractAndExpand(t,e,n,i){await this._setup();let o=await this._api.importKey("raw",e,"HKDF",!1,["deriveBits"]);return await this._api.deriveBits({name:"HKDF",hash:this.algHash.hash,salt:t,info:n},o,i*8)}async labeledExtract(t,e,n){return await this.extract(t,this.buildLabeledIkm(e,n))}async labeledExpand(t,e,n,i){return await this.expand(t,this.buildLabeledInfo(e,n,i),i)}_checkInit(){if(this._suiteId===Y)throw new Error("Not initialized. Call init()")}},zt=class extends ee{constructor(){super(...arguments),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Qt.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}};var Ct=class extends zt{async extract(t,e){if(await this._setup(),t.byteLength===0&&(t=new ArrayBuffer(this.hashSize)),t.byteLength!==this.hashSize)return At(Tt,new Uint8Array(t),new Uint8Array(e));let n=await this._api.importKey("raw",t,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,e)}};var Ie=new Uint8Array([75,69,77,0,0]);var Et=r=>typeof r=="object"&&r!==null&&typeof r.privateKey=="object"&&typeof r.publicKey=="object";function Pe(r,t){if(t<=0)throw new Error("i2Osp: too small size");if(r>=256**t)throw new Error("i2Osp: too large integer");let e=new Uint8Array(t);for(let n=0;n<t&&r;n++)e[t-(n+1)]=r%256,r=r>>8;return e}function St(r,t){let e=new Uint8Array(r.length+t.length);return e.set(r,0),e.set(t,r.length),e}var ur=new Uint8Array([101,97,101,95,112,114,107]),fr=new Uint8Array([115,104,97,114,101,100,95,115,101,99,114,101,116]);function lr(r,t,e){let n=new Uint8Array(r.length+t.length+e.length);return n.set(r,0),n.set(t,r.length),n.set(e,r.length+t.length),n}var Dt=class{constructor(t,e,n){Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_prim",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.id=t,this._prim=e,this._kdf=n;let i=new Uint8Array(Ie);i.set(Pe(this.id,2),3),this._kdf.init(i)}async serializePublicKey(t){return await this._prim.serializePublicKey(t)}async deserializePublicKey(t){return await this._prim.deserializePublicKey(t)}async serializePrivateKey(t){return await this._prim.serializePrivateKey(t)}async deserializePrivateKey(t){return await this._prim.deserializePrivateKey(t)}async importKey(t,e,n=!0){return await this._prim.importKey(t,e,n)}async generateKeyPair(){return await this._prim.generateKeyPair()}async deriveKeyPair(t){if(t.byteLength>8192)throw new gt("Too long ikm");return await this._prim.deriveKeyPair(t)}async encap(t){let e;t.ekm===void 0?e=await this.generateKeyPair():Et(t.ekm)?e=t.ekm:e=await this.deriveKeyPair(t.ekm);let n=await this._prim.serializePublicKey(e.publicKey),i=await this._prim.serializePublicKey(t.recipientPublicKey);try{let o;if(t.senderKey===void 0)o=new Uint8Array(await this._prim.dh(e.privateKey,t.recipientPublicKey));else{let c=Et(t.senderKey)?t.senderKey.privateKey:t.senderKey,u=new Uint8Array(await this._prim.dh(e.privateKey,t.recipientPublicKey)),y=new Uint8Array(await this._prim.dh(c,t.recipientPublicKey));o=St(u,y)}let a;if(t.senderKey===void 0)a=St(new Uint8Array(n),new Uint8Array(i));else{let c=Et(t.senderKey)?t.senderKey.publicKey:await this._prim.derivePublicKey(t.senderKey),u=await this._prim.serializePublicKey(c);a=lr(new Uint8Array(n),new Uint8Array(i),new Uint8Array(u))}let s=await this._generateSharedSecret(o,a);return{enc:n,sharedSecret:s}}catch(o){throw new Ht(o)}}async decap(t){let e=await this._prim.deserializePublicKey(t.enc),n=Et(t.recipientKey)?t.recipientKey.privateKey:t.recipientKey,i=Et(t.recipientKey)?t.recipientKey.publicKey:await this._prim.derivePublicKey(t.recipientKey),o=await this._prim.serializePublicKey(i);try{let a;if(t.senderPublicKey===void 0)a=new Uint8Array(await this._prim.dh(n,e));else{let c=new Uint8Array(await this._prim.dh(n,e)),u=new Uint8Array(await this._prim.dh(n,t.senderPublicKey));a=St(c,u)}let s;if(t.senderPublicKey===void 0)s=St(new Uint8Array(t.enc),new Uint8Array(o));else{let c=await this._prim.serializePublicKey(t.senderPublicKey);s=new Uint8Array(t.enc.byteLength+o.byteLength+c.byteLength),s.set(new Uint8Array(t.enc),0),s.set(new Uint8Array(o),t.enc.byteLength),s.set(new Uint8Array(c),t.enc.byteLength+o.byteLength)}return await this._generateSharedSecret(a,s)}catch(a){throw new Nt(a)}}async _generateSharedSecret(t,e){let n=this._kdf.buildLabeledIkm(ur,t),i=this._kdf.buildLabeledInfo(fr,e,this.secretSize);return await this._kdf.extractAndExpand(Y,n,i,this.secretSize)}};var oe={};Ye(oe,{bitGet:()=>gr,bitLen:()=>pr,bitMask:()=>It,bitSet:()=>mr,bytesToHex:()=>at,bytesToNumberBE:()=>X,bytesToNumberLE:()=>Mt,concatBytes:()=>vt,createHmacDrbg:()=>ie,ensureBytes:()=>C,equalBytes:()=>br,hexToBytes:()=>ut,hexToNumber:()=>ne,isBytes:()=>V,numberToBytesBE:()=>it,numberToBytesLE:()=>$t,numberToHexUnpadded:()=>Ue,numberToVarBytesBE:()=>yr,utf8ToBytes:()=>wr,validateObject:()=>ot});var Le=BigInt(0),jt=BigInt(1),dr=BigInt(2);function V(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}var hr=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function at(r){if(!V(r))throw new Error("Uint8Array expected");let t="";for(let e=0;e<r.length;e++)t+=hr[r[e]];return t}function Ue(r){let t=r.toString(16);return t.length&1?`0${t}`:t}function ne(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}var W={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Ke(r){if(r>=W._0&&r<=W._9)return r-W._0;if(r>=W._A&&r<=W._F)return r-(W._A-10);if(r>=W._a&&r<=W._f)return r-(W._a-10)}function ut(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length,e=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);let n=new Uint8Array(e);for(let i=0,o=0;i<e;i++,o+=2){let a=Ke(r.charCodeAt(o)),s=Ke(r.charCodeAt(o+1));if(a===void 0||s===void 0){let c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[i]=a*16+s}return n}function X(r){return ne(at(r))}function Mt(r){if(!V(r))throw new Error("Uint8Array expected");return ne(at(Uint8Array.from(r).reverse()))}function it(r,t){return ut(r.toString(16).padStart(t*2,"0"))}function $t(r,t){return it(r,t).reverse()}function yr(r){return ut(Ue(r))}function C(r,t,e){let n;if(typeof t=="string")try{n=ut(t)}catch(o){throw new Error(`${r} must be valid hex string, got "${t}". Cause: ${o}`)}else if(V(t))n=Uint8Array.from(t);else throw new Error(`${r} must be hex string or Uint8Array`);let i=n.length;if(typeof e=="number"&&i!==e)throw new Error(`${r} expected ${e} bytes, got ${i}`);return n}function vt(...r){let t=0;for(let i=0;i<r.length;i++){let o=r[i];if(!V(o))throw new Error("Uint8Array expected");t+=o.length}let e=new Uint8Array(t),n=0;for(let i=0;i<r.length;i++){let o=r[i];e.set(o,n),n+=o.length}return e}function br(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}function wr(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function pr(r){let t;for(t=0;r>Le;r>>=jt,t+=1);return t}function gr(r,t){return r>>BigInt(t)&jt}var mr=(r,t,e)=>r|(e?jt:Le)<<BigInt(t),It=r=>(dr<<BigInt(r-1))-jt,re=r=>new Uint8Array(r),ke=r=>Uint8Array.from(r);function ie(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=re(r),i=re(r),o=0,a=()=>{n.fill(1),i.fill(0),o=0},s=(...l)=>e(i,n,...l),c=(l=re())=>{i=s(ke([0]),l),n=s(),l.length!==0&&(i=s(ke([1]),l),n=s())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let l=0,m=[];for(;l<t;){n=s();let S=n.slice();m.push(S),l+=n.length}return vt(...m)};return(l,m)=>{a(),c(l);let S;for(;!(S=m(u()));)c();return a(),S}}var xr={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||V(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function ot(r,t,e={}){let n=(i,o,a)=>{let s=xr[o];if(typeof s!="function")throw new Error(`Invalid validator "${o}", expected function`);let c=r[i];if(!(a&&c===void 0)&&!s(c,r))throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${o}`)};for(let[i,o]of Object.entries(t))n(i,o,!1);for(let[i,o]of Object.entries(e))n(i,o,!0);return r}var O=BigInt(0),U=BigInt(1),ft=BigInt(2),Er=BigInt(3),se=BigInt(4),Oe=BigInt(5),Te=BigInt(8),vr=BigInt(9),Br=BigInt(16);function H(r,t){let e=r%t;return e>=O?e:t+e}function _r(r,t,e){if(e<=O||t<O)throw new Error("Expected power/modulo > 0");if(e===U)return O;let n=U;for(;t>O;)t&U&&(n=n*r%e),r=r*r%e,t>>=U;return n}function D(r,t,e){let n=r;for(;t-- >O;)n*=n,n%=e;return n}function Vt(r,t){if(r===O||t<=O)throw new Error(`invert: expected positive integers, got n=${r} mod=${t}`);let e=H(r,t),n=t,i=O,o=U,a=U,s=O;for(;e!==O;){let u=n/e,y=n%e,l=i-a*u,m=o-s*u;n=e,e=y,i=a,o=s,a=l,s=m}if(n!==U)throw new Error("invert: does not exist");return H(i,t)}function Ar(r){let t=(r-U)/ft,e,n,i;for(e=r-U,n=0;e%ft===O;e/=ft,n++);for(i=ft;i<r&&_r(i,t,r)!==r-U;i++);if(n===1){let a=(r+U)/se;return function(c,u){let y=c.pow(u,a);if(!c.eql(c.sqr(y),u))throw new Error("Cannot find square root");return y}}let o=(e+U)/ft;return function(s,c){if(s.pow(c,t)===s.neg(s.ONE))throw new Error("Cannot find square root");let u=n,y=s.pow(s.mul(s.ONE,i),e),l=s.pow(c,o),m=s.pow(c,e);for(;!s.eql(m,s.ONE);){if(s.eql(m,s.ZERO))return s.ZERO;let S=1;for(let f=s.sqr(m);S<u&&!s.eql(f,s.ONE);S++)f=s.sqr(f);let g=s.pow(y,U<<BigInt(u-S-1));y=s.sqr(g),l=s.mul(l,g),m=s.mul(m,y),u=S}return l}}function Sr(r){if(r%se===Er){let t=(r+U)/se;return function(n,i){let o=n.pow(i,t);if(!n.eql(n.sqr(o),i))throw new Error("Cannot find square root");return o}}if(r%Te===Oe){let t=(r-Oe)/Te;return function(n,i){let o=n.mul(i,ft),a=n.pow(o,t),s=n.mul(i,a),c=n.mul(n.mul(s,ft),a),u=n.mul(s,n.sub(c,n.ONE));if(!n.eql(n.sqr(u),i))throw new Error("Cannot find square root");return u}}return r%Br,Ar(r)}var Ir=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ce(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Ir.reduce((n,i)=>(n[i]="function",n),t);return ot(r,e)}function Pr(r,t,e){if(e<O)throw new Error("Expected power > 0");if(e===O)return r.ONE;if(e===U)return t;let n=r.ONE,i=t;for(;e>O;)e&U&&(n=r.mul(n,i)),i=r.sqr(i),e>>=U;return n}function Kr(r,t){let e=new Array(t.length),n=t.reduce((o,a,s)=>r.is0(a)?o:(e[s]=o,r.mul(o,a)),r.ONE),i=r.inv(n);return t.reduceRight((o,a,s)=>r.is0(a)?o:(e[s]=r.mul(o,e[s]),r.mul(o,a)),i),e}function ae(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function He(r,t,e=!1,n={}){if(r<=O)throw new Error(`Expected Field ORDER > 0, got ${r}`);let{nBitLength:i,nByteLength:o}=ae(r,t);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");let a=Sr(r),s=Object.freeze({ORDER:r,BITS:i,BYTES:o,MASK:It(i),ZERO:O,ONE:U,create:c=>H(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return O<=c&&c<r},is0:c=>c===O,isOdd:c=>(c&U)===U,neg:c=>H(-c,r),eql:(c,u)=>c===u,sqr:c=>H(c*c,r),add:(c,u)=>H(c+u,r),sub:(c,u)=>H(c-u,r),mul:(c,u)=>H(c*u,r),pow:(c,u)=>Pr(s,c,u),div:(c,u)=>H(c*Vt(u,r),r),sqrN:c=>c*c,addN:(c,u)=>c+u,subN:(c,u)=>c-u,mulN:(c,u)=>c*u,inv:c=>Vt(c,r),sqrt:n.sqrt||(c=>a(s,c)),invertBatch:c=>Kr(s,c),cmov:(c,u,y)=>y?u:c,toBytes:c=>e?$t(c,o):it(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return e?Mt(c):X(c)}});return Object.freeze(s)}function Ne(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let t=r.toString(2).length;return Math.ceil(t/8)}function ue(r){let t=Ne(r);return t+Math.ceil(t/2)}function qe(r,t,e=!1){let n=r.length,i=Ne(t),o=ue(t);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);let a=e?X(r):Mt(r),s=H(a,t-U)+U;return e?$t(s,i):it(s,i)}var Lr=BigInt(0),fe=BigInt(1);function Re(r,t){let e=(i,o)=>{let a=o.negate();return i?a:o},n=i=>{let o=Math.ceil(t/i)+1,a=2**(i-1);return{windows:o,windowSize:a}};return{constTimeNegate:e,unsafeLadder(i,o){let a=r.ZERO,s=i;for(;o>Lr;)o&fe&&(a=a.add(s)),s=s.double(),o>>=fe;return a},precomputeWindow(i,o){let{windows:a,windowSize:s}=n(o),c=[],u=i,y=u;for(let l=0;l<a;l++){y=u,c.push(y);for(let m=1;m<s;m++)y=y.add(u),c.push(y);u=y.double()}return c},wNAF(i,o,a){let{windows:s,windowSize:c}=n(i),u=r.ZERO,y=r.BASE,l=BigInt(2**i-1),m=2**i,S=BigInt(i);for(let g=0;g<s;g++){let f=g*c,h=Number(a&l);a>>=S,h>c&&(h-=m,a+=fe);let b=f,x=f+Math.abs(h)-1,v=g%2!==0,I=h<0;h===0?y=y.add(e(v,o[b])):u=u.add(e(I,o[x]))}return{p:u,f:y}},wNAFCached(i,o,a,s){let c=i._WINDOW_SIZE||1,u=o.get(i);return u||(u=this.precomputeWindow(i,c),c!==1&&o.set(i,s(u))),this.wNAF(c,u,a)}}}function le(r){return ce(r.Fp),ot(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ae(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}function Ur(r){let t=le(r);ot(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:e,Fp:n,a:i}=t;if(e){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}var{bytesToNumberBE:Or,hexToBytes:Tr}=oe,lt={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(r){let{Err:t}=lt;if(r.length<2||r[0]!==2)throw new t("Invalid signature integer tag");let e=r[1],n=r.subarray(2,e+2);if(!e||n.length!==e)throw new t("Invalid signature integer: wrong length");if(n[0]&128)throw new t("Invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:Or(n),l:r.subarray(e+2)}},toSig(r){let{Err:t}=lt,e=typeof r=="string"?Tr(r):r;if(!V(e))throw new Error("ui8a expected");let n=e.length;if(n<2||e[0]!=48)throw new t("Invalid signature tag");if(e[1]!==n-2)throw new t("Invalid signature: incorrect length");let{d:i,l:o}=lt._parseInt(e.subarray(2)),{d:a,l:s}=lt._parseInt(o);if(s.length)throw new t("Invalid signature: left bytes after parsing");return{r:i,s:a}},hexFromSig(r){let t=u=>Number.parseInt(u[0],16)&8?"00"+u:u,e=u=>{let y=u.toString(16);return y.length&1?`0${y}`:y},n=t(e(r.s)),i=t(e(r.r)),o=n.length/2,a=i.length/2,s=e(o),c=e(a);return`30${e(a+o+4)}02${c}${i}02${s}${n}`}},Q=BigInt(0),M=BigInt(1),kn=BigInt(2),ze=BigInt(3),Ln=BigInt(4);function Hr(r){let t=Ur(r),{Fp:e}=t,n=t.toBytes||((g,f,h)=>{let b=f.toAffine();return vt(Uint8Array.from([4]),e.toBytes(b.x),e.toBytes(b.y))}),i=t.fromBytes||(g=>{let f=g.subarray(1),h=e.fromBytes(f.subarray(0,e.BYTES)),b=e.fromBytes(f.subarray(e.BYTES,2*e.BYTES));return{x:h,y:b}});function o(g){let{a:f,b:h}=t,b=e.sqr(g),x=e.mul(b,g);return e.add(e.add(x,e.mul(g,f)),h)}if(!e.eql(e.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function a(g){return typeof g=="bigint"&&Q<g&&g<t.n}function s(g){if(!a(g))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(g){let{allowedPrivateKeyLengths:f,nByteLength:h,wrapPrivateKey:b,n:x}=t;if(f&&typeof g!="bigint"){if(V(g)&&(g=at(g)),typeof g!="string"||!f.includes(g.length))throw new Error("Invalid key");g=g.padStart(h*2,"0")}let v;try{v=typeof g=="bigint"?g:X(C("private key",g,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof g}`)}return b&&(v=H(v,x)),s(v),v}let u=new Map;function y(g){if(!(g instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(f,h,b){if(this.px=f,this.py=h,this.pz=b,f==null||!e.isValid(f))throw new Error("x required");if(h==null||!e.isValid(h))throw new Error("y required");if(b==null||!e.isValid(b))throw new Error("z required")}static fromAffine(f){let{x:h,y:b}=f||{};if(!f||!e.isValid(h)||!e.isValid(b))throw new Error("invalid affine point");if(f instanceof l)throw new Error("projective point not allowed");let x=v=>e.eql(v,e.ZERO);return x(h)&&x(b)?l.ZERO:new l(h,b,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){let h=e.invertBatch(f.map(b=>b.pz));return f.map((b,x)=>b.toAffine(h[x])).map(l.fromAffine)}static fromHex(f){let h=l.fromAffine(i(C("pointHex",f)));return h.assertValidity(),h}static fromPrivateKey(f){return l.BASE.multiply(c(f))}_setWindowSize(f){this._WINDOW_SIZE=f,u.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}let{x:f,y:h}=this.toAffine();if(!e.isValid(f)||!e.isValid(h))throw new Error("bad point: x or y not FE");let b=e.sqr(h),x=o(f);if(!e.eql(b,x))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){let{y:f}=this.toAffine();if(e.isOdd)return!e.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){y(f);let{px:h,py:b,pz:x}=this,{px:v,py:I,pz:A}=f,p=e.eql(e.mul(h,A),e.mul(v,x)),E=e.eql(e.mul(b,A),e.mul(I,x));return p&&E}negate(){return new l(this.px,e.neg(this.py),this.pz)}double(){let{a:f,b:h}=t,b=e.mul(h,ze),{px:x,py:v,pz:I}=this,A=e.ZERO,p=e.ZERO,E=e.ZERO,_=e.mul(x,x),j=e.mul(v,v),L=e.mul(I,I),P=e.mul(x,v);return P=e.add(P,P),E=e.mul(x,I),E=e.add(E,E),A=e.mul(f,E),p=e.mul(b,L),p=e.add(A,p),A=e.sub(j,p),p=e.add(j,p),p=e.mul(A,p),A=e.mul(P,A),E=e.mul(b,E),L=e.mul(f,L),P=e.sub(_,L),P=e.mul(f,P),P=e.add(P,E),E=e.add(_,_),_=e.add(E,_),_=e.add(_,L),_=e.mul(_,P),p=e.add(p,_),L=e.mul(v,I),L=e.add(L,L),_=e.mul(L,P),A=e.sub(A,_),E=e.mul(L,j),E=e.add(E,E),E=e.add(E,E),new l(A,p,E)}add(f){y(f);let{px:h,py:b,pz:x}=this,{px:v,py:I,pz:A}=f,p=e.ZERO,E=e.ZERO,_=e.ZERO,j=t.a,L=e.mul(t.b,ze),P=e.mul(h,v),N=e.mul(b,I),q=e.mul(x,A),J=e.add(h,b),d=e.add(v,I);J=e.mul(J,d),d=e.add(P,N),J=e.sub(J,d),d=e.add(h,x);let w=e.add(v,A);return d=e.mul(d,w),w=e.add(P,q),d=e.sub(d,w),w=e.add(b,x),p=e.add(I,A),w=e.mul(w,p),p=e.add(N,q),w=e.sub(w,p),_=e.mul(j,d),p=e.mul(L,q),_=e.add(p,_),p=e.sub(N,_),_=e.add(N,_),E=e.mul(p,_),N=e.add(P,P),N=e.add(N,P),q=e.mul(j,q),d=e.mul(L,d),N=e.add(N,q),q=e.sub(P,q),q=e.mul(j,q),d=e.add(d,q),P=e.mul(N,d),E=e.add(E,P),P=e.mul(w,d),p=e.mul(J,p),p=e.sub(p,P),P=e.mul(J,N),_=e.mul(w,_),_=e.add(_,P),new l(p,E,_)}subtract(f){return this.add(f.negate())}is0(){return this.equals(l.ZERO)}wNAF(f){return S.wNAFCached(this,u,f,h=>{let b=e.invertBatch(h.map(x=>x.pz));return h.map((x,v)=>x.toAffine(b[v])).map(l.fromAffine)})}multiplyUnsafe(f){let h=l.ZERO;if(f===Q)return h;if(s(f),f===M)return this;let{endo:b}=t;if(!b)return S.unsafeLadder(this,f);let{k1neg:x,k1:v,k2neg:I,k2:A}=b.splitScalar(f),p=h,E=h,_=this;for(;v>Q||A>Q;)v&M&&(p=p.add(_)),A&M&&(E=E.add(_)),_=_.double(),v>>=M,A>>=M;return x&&(p=p.negate()),I&&(E=E.negate()),E=new l(e.mul(E.px,b.beta),E.py,E.pz),p.add(E)}multiply(f){s(f);let h=f,b,x,{endo:v}=t;if(v){let{k1neg:I,k1:A,k2neg:p,k2:E}=v.splitScalar(h),{p:_,f:j}=this.wNAF(A),{p:L,f:P}=this.wNAF(E);_=S.constTimeNegate(I,_),L=S.constTimeNegate(p,L),L=new l(e.mul(L.px,v.beta),L.py,L.pz),b=_.add(L),x=j.add(P)}else{let{p:I,f:A}=this.wNAF(h);b=I,x=A}return l.normalizeZ([b,x])[0]}multiplyAndAddUnsafe(f,h,b){let x=l.BASE,v=(A,p)=>p===Q||p===M||!A.equals(x)?A.multiplyUnsafe(p):A.multiply(p),I=v(this,h).add(v(f,b));return I.is0()?void 0:I}toAffine(f){let{px:h,py:b,pz:x}=this,v=this.is0();f==null&&(f=v?e.ONE:e.inv(x));let I=e.mul(h,f),A=e.mul(b,f),p=e.mul(x,f);if(v)return{x:e.ZERO,y:e.ZERO};if(!e.eql(p,e.ONE))throw new Error("invZ was invalid");return{x:I,y:A}}isTorsionFree(){let{h:f,isTorsionFree:h}=t;if(f===M)return!0;if(h)return h(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:f,clearCofactor:h}=t;return f===M?this:h?h(l,this):this.multiplyUnsafe(t.h)}toRawBytes(f=!0){return this.assertValidity(),n(l,this,f)}toHex(f=!0){return at(this.toRawBytes(f))}}l.BASE=new l(t.Gx,t.Gy,e.ONE),l.ZERO=new l(e.ZERO,e.ONE,e.ZERO);let m=t.nBitLength,S=Re(l,t.endo?Math.ceil(m/2):m);return{CURVE:t,ProjectivePoint:l,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:a}}function Nr(r){let t=le(r);return ot(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function Ce(r){let t=Nr(r),{Fp:e,n}=t,i=e.BYTES+1,o=2*e.BYTES+1;function a(d){return Q<d&&d<e.ORDER}function s(d){return H(d,n)}function c(d){return Vt(d,n)}let{ProjectivePoint:u,normPrivateKeyToScalar:y,weierstrassEquation:l,isWithinCurveOrder:m}=Hr({...t,toBytes(d,w,B){let k=w.toAffine(),K=e.toBytes(k.x),T=vt;return B?T(Uint8Array.from([w.hasEvenY()?2:3]),K):T(Uint8Array.from([4]),K,e.toBytes(k.y))},fromBytes(d){let w=d.length,B=d[0],k=d.subarray(1);if(w===i&&(B===2||B===3)){let K=X(k);if(!a(K))throw new Error("Point is not on curve");let T=l(K),R=e.sqrt(T),z=(R&M)===M;return(B&1)===1!==z&&(R=e.neg(R)),{x:K,y:R}}else if(w===o&&B===4){let K=e.fromBytes(k.subarray(0,e.BYTES)),T=e.fromBytes(k.subarray(e.BYTES,2*e.BYTES));return{x:K,y:T}}else throw new Error(`Point of length ${w} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}}),S=d=>at(it(d,t.nByteLength));function g(d){let w=n>>M;return d>w}function f(d){return g(d)?s(-d):d}let h=(d,w,B)=>X(d.slice(w,B));class b{constructor(w,B,k){this.r=w,this.s=B,this.recovery=k,this.assertValidity()}static fromCompact(w){let B=t.nByteLength;return w=C("compactSignature",w,B*2),new b(h(w,0,B),h(w,B,2*B))}static fromDER(w){let{r:B,s:k}=lt.toSig(C("DER",w));return new b(B,k)}assertValidity(){if(!m(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!m(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(w){return new b(this.r,this.s,w)}recoverPublicKey(w){let{r:B,s:k,recovery:K}=this,T=E(C("msgHash",w));if(K==null||![0,1,2,3].includes(K))throw new Error("recovery id invalid");let R=K===2||K===3?B+t.n:B;if(R>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");let z=K&1?"03":"02",F=u.fromHex(z+S(R)),tt=c(R),ht=s(-T*tt),Bt=s(k*tt),et=u.BASE.multiplyAndAddUnsafe(F,ht,Bt);if(!et)throw new Error("point at infinify");return et.assertValidity(),et}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new b(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return ut(this.toDERHex())}toDERHex(){return lt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ut(this.toCompactHex())}toCompactHex(){return S(this.r)+S(this.s)}}let x={isValidPrivateKey(d){try{return y(d),!0}catch{return!1}},normPrivateKeyToScalar:y,randomPrivateKey:()=>{let d=ue(t.n);return qe(t.randomBytes(d),t.n)},precompute(d=8,w=u.BASE){return w._setWindowSize(d),w.multiply(BigInt(3)),w}};function v(d,w=!0){return u.fromPrivateKey(d).toRawBytes(w)}function I(d){let w=V(d),B=typeof d=="string",k=(w||B)&&d.length;return w?k===i||k===o:B?k===2*i||k===2*o:d instanceof u}function A(d,w,B=!0){if(I(d))throw new Error("first arg must be private key");if(!I(w))throw new Error("second arg must be public key");return u.fromHex(w).multiply(y(d)).toRawBytes(B)}let p=t.bits2int||function(d){let w=X(d),B=d.length*8-t.nBitLength;return B>0?w>>BigInt(B):w},E=t.bits2int_modN||function(d){return s(p(d))},_=It(t.nBitLength);function j(d){if(typeof d!="bigint")throw new Error("bigint expected");if(!(Q<=d&&d<_))throw new Error(`bigint expected < 2^${t.nBitLength}`);return it(d,t.nByteLength)}function L(d,w,B=P){if(["recovered","canonical"].some(st=>st in B))throw new Error("sign() legacy options not supported");let{hash:k,randomBytes:K}=t,{lowS:T,prehash:R,extraEntropy:z}=B;T==null&&(T=!0),d=C("msgHash",d),R&&(d=C("prehashed msgHash",k(d)));let F=E(d),tt=y(w),ht=[j(tt),j(F)];if(z!=null){let st=z===!0?K(e.BYTES):z;ht.push(C("extraEntropy",st))}let Bt=vt(...ht),et=F;function Wt(st){let yt=p(st);if(!m(yt))return;let be=c(yt),Z=u.BASE.multiply(yt).toAffine(),bt=s(Z.x);if(bt===Q)return;let Kt=s(be*s(et+bt*tt));if(Kt===Q)return;let we=(Z.x===bt?0:2)|Number(Z.y&M),pe=Kt;return T&&g(Kt)&&(pe=f(Kt),we^=1),new b(bt,pe,we)}return{seed:Bt,k2sig:Wt}}let P={lowS:t.lowS,prehash:!1},N={lowS:t.lowS,prehash:!1};function q(d,w,B=P){let{seed:k,k2sig:K}=L(d,w,B),T=t;return ie(T.hash.outputLen,T.nByteLength,T.hmac)(k,K)}u.BASE._setWindowSize(8);function J(d,w,B,k=N){let K=d;if(w=C("msgHash",w),B=C("publicKey",B),"strict"in k)throw new Error("options.strict was renamed to lowS");let{lowS:T,prehash:R}=k,z,F;try{if(typeof K=="string"||V(K))try{z=b.fromDER(K)}catch(Z){if(!(Z instanceof lt.Err))throw Z;z=b.fromCompact(K)}else if(typeof K=="object"&&typeof K.r=="bigint"&&typeof K.s=="bigint"){let{r:Z,s:bt}=K;z=new b(Z,bt)}else throw new Error("PARSE");F=u.fromHex(B)}catch(Z){if(Z.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(T&&z.hasHighS())return!1;R&&(w=t.hash(w));let{r:tt,s:ht}=z,Bt=E(w),et=c(ht),Wt=s(Bt*et),st=s(tt*et),yt=u.BASE.multiplyAndAddUnsafe(F,Wt,st)?.toAffine();return yt?s(yt.x)===tt:!1}return{CURVE:t,getPublicKey:v,getSharedSecret:A,sign:q,verify:J,ProjectivePoint:u,Signature:b,utils:x}}function qr(r){return{hash:r,hmac:(t,...e)=>At(r,t,ve(...e)),randomBytes:_e}}function De(r,t){let e=n=>Ce({...r,...qr(n)});return Object.freeze({...e(t),create:e})}var $e=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),je=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Rr=BigInt(1),de=BigInt(2),Me=(r,t)=>(r+t/de)/t;function zr(r){let t=$e,e=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),a=BigInt(23),s=BigInt(44),c=BigInt(88),u=r*r*r%t,y=u*u*r%t,l=D(y,e,t)*y%t,m=D(l,e,t)*y%t,S=D(m,de,t)*u%t,g=D(S,i,t)*S%t,f=D(g,o,t)*g%t,h=D(f,s,t)*f%t,b=D(h,c,t)*h%t,x=D(b,s,t)*f%t,v=D(x,e,t)*y%t,I=D(v,a,t)*g%t,A=D(I,n,t)*u%t,p=D(A,de,t);if(!he.eql(he.sqr(p),r))throw new Error("Cannot find square root");return p}var he=He($e,void 0,void 0,{sqrt:zr}),Pt=De({a:BigInt(0),b:BigInt(7),Fp:he,n:je,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{let t=je,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Rr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,a=BigInt("0x100000000000000000000000000000000"),s=Me(o*r,t),c=Me(-n*r,t),u=H(r-s*e-c*i,t),y=H(-s*n-c*o,t),l=u>a,m=y>a;if(l&&(u=t-u),m&&(y=t-y),u>a||y>a)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:l,k1:u,k2neg:m,k2:y}}}},Tt),Cn=BigInt(0);var Dn=Pt.ProjectivePoint;var Zt=["deriveBits"],Ve=new Uint8Array([100,107,112,95,112,114,107]),Ze=new Uint8Array([115,107]);var dt=class{constructor(t,e,n,i=[]){Object.defineProperty(this,"key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extractable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"algorithm",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"usages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.key=e,this.type=n,this.algorithm={name:t},this.usages=i,n==="public"&&(this.usages=[])}};var Gt="ECDH",Yt=class{constructor(t){Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=t,this._nPk=33,this._nSk=32}async serializePublicKey(t){try{return await this._serializePublicKey(t)}catch(e){throw new mt(e)}}async deserializePublicKey(t){try{return await this._importRawKey(t,!0)}catch(e){throw new ct(e)}}async serializePrivateKey(t){try{return await this._serializePrivateKey(t)}catch(e){throw new mt(e)}}async deserializePrivateKey(t){try{return await this._importRawKey(t,!1)}catch(e){throw new ct(e)}}async importKey(t,e,n){try{if(t!=="raw")throw new Error("Unsupported format");return await this._importRawKey(e,n)}catch(i){throw new ct(i)}}async generateKeyPair(){try{let t=Pt.utils.randomPrivateKey(),e=new dt(Gt,t,"private",Zt);return{publicKey:await this.derivePublicKey(e),privateKey:e}}catch(t){throw new xt(t)}}async deriveKeyPair(t){try{let e=await this._hkdf.labeledExtract(Y,Ve,new Uint8Array(t)),n=await this._hkdf.labeledExpand(e,Ze,Y,this._nSk),i=new dt(Gt,new Uint8Array(n),"private",Zt);return{privateKey:i,publicKey:await this.derivePublicKey(i)}}catch(e){throw new qt(e)}}async derivePublicKey(t){try{return await this._derivePublicKey(t)}catch(e){throw new ct(e)}}async dh(t,e){try{return await this._dh(t,e)}catch(n){throw new mt(n)}}_serializePublicKey(t){return new Promise(e=>{e(t.key.buffer)})}_serializePrivateKey(t){return new Promise(e=>{e(t.key.buffer)})}_importRawKey(t,e){return new Promise((n,i)=>{e&&t.byteLength!==this._nPk&&i(new Error("Invalid length of the key")),!e&&t.byteLength!==this._nSk&&i(new Error("Invalid length of the key")),n(new dt(Gt,new Uint8Array(t),e?"public":"private",e?[]:Zt))})}_derivePublicKey(t){return new Promise((e,n)=>{try{let i=Pt.getPublicKey(t.key);e(new dt(Gt,i,"public"))}catch(i){n(i)}})}_dh(t,e){return new Promise((n,i)=>{try{n(Pt.getSharedSecret(t.key,e.key).buffer)}catch(o){i(o)}})}};var ye=class extends Dt{constructor(){let t=new Ct;super(Xt.DhkemSecp256k1HkdfSha256,new Yt(t),t),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Xt.DhkemSecp256k1HkdfSha256}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:32})}};export{ye as DhkemSecp256k1HkdfSha256};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
