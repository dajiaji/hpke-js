var kr=Object.defineProperty;var Ar=(r,e)=>{for(var t in e)kr(r,t,{get:e[t],enumerable:!0})};var Sr={},Dt=Pr(globalThis,Sr);function Pr(r,e){return new Proxy(r,{get(t,n,i){return n in e?e[n]:r[n]},set(t,n,i){return n in e&&delete e[n],r[n]=i,!0},deleteProperty(t,n){let i=!1;return n in e&&(delete e[n],i=!0),n in r&&(delete r[n],i=!0),i},ownKeys(t){let n=Reflect.ownKeys(r),i=Reflect.ownKeys(e),o=new Set(i);return[...n.filter(s=>!o.has(s)),...i]},defineProperty(t,n,i){return n in e&&delete e[n],Reflect.defineProperty(r,n,i),!0},getOwnPropertyDescriptor(t,n){return n in e?Reflect.getOwnPropertyDescriptor(e,n):Reflect.getOwnPropertyDescriptor(r,n)},has(t,n){return n in e||n in r}})}var dt=class extends Error{constructor(e){let t;e instanceof Error?t=e.message:typeof e=="string"?t=e:t="",super(t),this.name=this.constructor.name}},J=class extends dt{},F=class extends J{};var ee=class extends J{},X=class extends J{},Ye=class extends J{},We=class extends J{};var Pe=class extends J{},G=class extends J{};async function Br(){if(Dt!==void 0&&globalThis.crypto!==void 0)return globalThis.crypto.subtle;try{let{webcrypto:r}=await import("crypto");return r.subtle}catch(r){throw new G(r)}}var we=class{constructor(){Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}async _setup(){this._api===void 0&&(this._api=await Br())}};var se={NotAssigned:0,DhkemP256HkdfSha256:16,DhkemP384HkdfSha384:17,DhkemP521HkdfSha512:18,DhkemSecp256k1HkdfSha256:19,DhkemX25519HkdfSha256:32,DhkemX448HkdfSha512:33,HybridkemX25519Kyber768:48},Xe={HkdfSha256:1,HkdfSha384:2,HkdfSha512:3};var V=new Uint8Array(0);var Zn=new Uint8Array([115,101,99]);var me=r=>typeof r=="object"&&r!==null&&typeof r.privateKey=="object"&&typeof r.publicKey=="object";function Ke(r,e){if(e<=0)throw new Error("i2Osp: too small size");if(r>=256**e)throw new Error("i2Osp: too large integer");let t=new Uint8Array(e);for(let n=0;n<e&&r;n++)t[e-(n+1)]=r%256,r=r>>8;return t}function Be(r,e){let t=new Uint8Array(r.length+e.length);return t.set(r,0),t.set(e,r.length),t}var Si=new Uint8Array([98,97,115,101,95,110,111,110,99,101]),Pi=new Uint8Array([101,120,112]),Ki=new Uint8Array([105,110,102,111,95,104,97,115,104]),Bi=new Uint8Array([107,101,121]),Ii=new Uint8Array([112,115,107,95,105,100,95,104,97,115,104]),Li=new Uint8Array([115,101,99,114,101,116]),Ui=new Uint8Array([72,80,75,69,0,0,0,0,0,0]);var qt=new Uint8Array([72,80,75,69,45,118,49]),bt=class extends we{constructor(){super(),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Xe.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_suiteId",{enumerable:!0,configurable:!0,writable:!0,value:V}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}init(e){this._suiteId=e}buildLabeledIkm(e,t){this._checkInit();let n=new Uint8Array(7+this._suiteId.byteLength+e.byteLength+t.byteLength);return n.set(qt,0),n.set(this._suiteId,7),n.set(e,7+this._suiteId.byteLength),n.set(t,7+this._suiteId.byteLength+e.byteLength),n}buildLabeledInfo(e,t,n){this._checkInit();let i=new Uint8Array(9+this._suiteId.byteLength+e.byteLength+t.byteLength);return i.set(new Uint8Array([0,n]),0),i.set(qt,2),i.set(this._suiteId,9),i.set(e,9+this._suiteId.byteLength),i.set(t,9+this._suiteId.byteLength+e.byteLength),i}async extract(e,t){if(await this._setup(),e.byteLength===0&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)throw new F("The salt length must be the same as the hashSize");let n=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,t)}async expand(e,t,n){await this._setup();let i=await this._api.importKey("raw",e,this.algHash,!1,["sign"]),o=new ArrayBuffer(n),s=new Uint8Array(o),a=V,c=new Uint8Array(t),f=new Uint8Array(1);if(n>255*this.hashSize)throw new Error("Entropy limit reached");let y=new Uint8Array(this.hashSize+c.length+1);for(let u=1,w=0;w<s.length;u++)f[0]=u,y.set(a,0),y.set(c,a.length),y.set(f,a.length+c.length),a=new Uint8Array(await this._api.sign("HMAC",i,y.slice(0,a.length+c.length+1))),s.length-w>=a.length?(s.set(a,w),w+=a.length):(s.set(a.slice(0,s.length-w),w),w+=s.length-w);return o}async extractAndExpand(e,t,n,i){await this._setup();let o=await this._api.importKey("raw",t,"HKDF",!1,["deriveBits"]);return await this._api.deriveBits({name:"HKDF",hash:this.algHash.hash,salt:e,info:n},o,i*8)}async labeledExtract(e,t,n){return await this.extract(e,this.buildLabeledIkm(t,n))}async labeledExpand(e,t,n,i){return await this.expand(e,this.buildLabeledInfo(t,n,i),i)}_checkInit(){if(this._suiteId===V)throw new Error("Not initialized. Call init()")}},Re=class extends bt{constructor(){super(...arguments),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Xe.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}};var pt=new Uint8Array([75,69,77,0,0]);var Lr=new Uint8Array([101,97,101,95,112,114,107]),Ur=new Uint8Array([115,104,97,114,101,100,95,115,101,99,114,101,116]);function Or(r,e,t){let n=new Uint8Array(r.length+e.length+t.length);return n.set(r,0),n.set(e,r.length),n.set(t,r.length+e.length),n}var xe=class{constructor(e,t,n){Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_prim",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.id=e,this._prim=t,this._kdf=n;let i=new Uint8Array(pt);i.set(Ke(this.id,2),3),this._kdf.init(i)}async serializePublicKey(e){return await this._prim.serializePublicKey(e)}async deserializePublicKey(e){return await this._prim.deserializePublicKey(e)}async serializePrivateKey(e){return await this._prim.serializePrivateKey(e)}async deserializePrivateKey(e){return await this._prim.deserializePrivateKey(e)}async importKey(e,t,n=!0){return await this._prim.importKey(e,t,n)}async generateKeyPair(){return await this._prim.generateKeyPair()}async deriveKeyPair(e){if(e.byteLength>8192)throw new F("Too long ikm");return await this._prim.deriveKeyPair(e)}async encap(e){let t;e.ekm===void 0?t=await this.generateKeyPair():me(e.ekm)?t=e.ekm:t=await this.deriveKeyPair(e.ekm);let n=await this._prim.serializePublicKey(t.publicKey),i=await this._prim.serializePublicKey(e.recipientPublicKey);try{let o;if(e.senderKey===void 0)o=new Uint8Array(await this._prim.dh(t.privateKey,e.recipientPublicKey));else{let c=me(e.senderKey)?e.senderKey.privateKey:e.senderKey,f=new Uint8Array(await this._prim.dh(t.privateKey,e.recipientPublicKey)),y=new Uint8Array(await this._prim.dh(c,e.recipientPublicKey));o=Be(f,y)}let s;if(e.senderKey===void 0)s=Be(new Uint8Array(n),new Uint8Array(i));else{let c=me(e.senderKey)?e.senderKey.publicKey:await this._prim.derivePublicKey(e.senderKey),f=await this._prim.serializePublicKey(c);s=Or(new Uint8Array(n),new Uint8Array(i),new Uint8Array(f))}let a=await this._generateSharedSecret(o,s);return{enc:n,sharedSecret:a}}catch(o){throw new Ye(o)}}async decap(e){let t=await this._prim.deserializePublicKey(e.enc),n=me(e.recipientKey)?e.recipientKey.privateKey:e.recipientKey,i=me(e.recipientKey)?e.recipientKey.publicKey:await this._prim.derivePublicKey(e.recipientKey),o=await this._prim.serializePublicKey(i);try{let s;if(e.senderPublicKey===void 0)s=new Uint8Array(await this._prim.dh(n,t));else{let c=new Uint8Array(await this._prim.dh(n,t)),f=new Uint8Array(await this._prim.dh(n,e.senderPublicKey));s=Be(c,f)}let a;if(e.senderPublicKey===void 0)a=Be(new Uint8Array(e.enc),new Uint8Array(o));else{let c=await this._prim.serializePublicKey(e.senderPublicKey);a=new Uint8Array(e.enc.byteLength+o.byteLength+c.byteLength),a.set(new Uint8Array(e.enc),0),a.set(new Uint8Array(o),e.enc.byteLength),a.set(new Uint8Array(c),e.enc.byteLength+o.byteLength)}return await this._generateSharedSecret(s,a)}catch(s){throw new We(s)}}async _generateSharedSecret(e,t){let n=this._kdf.buildLabeledIkm(Lr,e),i=this._kdf.buildLabeledInfo(Ur,t,this.secretSize);return await this._kdf.extractAndExpand(V,n,i,this.secretSize)}};var Mt=new Uint8Array([100,107,112,95,112,114,107]),zr=new Uint8Array([115,107]);var no=new Uint8Array([99,97,110,100,105,100,97,116,101]),io=new Uint8Array([255,255,255,255,0,0,0,0,255,255,255,255,255,255,255,255,188,230,250,173,167,23,158,132,243,185,202,194,252,99,37,81]),oo=new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,199,99,77,129,244,55,45,223,88,26,13,178,72,176,167,122,236,236,25,106,204,197,41,115]),so=new Uint8Array([1,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,81,134,135,131,191,47,150,107,127,204,1,72,247,9,165,208,59,181,201,184,137,156,71,174,187,111,183,30,145,56,100,9]),ao=new Uint8Array([48,65,2,1,0,48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7,4,39,48,37,2,1,1,4,32]),co=new Uint8Array([48,78,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,34,4,55,48,53,2,1,1,4,48]),uo=new Uint8Array([48,96,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,35,4,73,48,71,2,1,1,4,66]);var Ce=class extends Re{};var Q=class{constructor(e,t,n,i=[]){Object.defineProperty(this,"key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extractable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"algorithm",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"usages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.key=t,this.type=n,this.algorithm={name:e},this.usages=i,n==="public"&&(this.usages=[])}};function $t(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`positive integer expected, not ${r}`)}function jr(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function De(r,...e){if(!jr(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${r.length}`)}function Gt(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");$t(r.outputLen),$t(r.blockLen)}function Ie(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Vt(r,e){De(r);let t=e.outputLen;if(r.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var Je=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),Z=(r,e)=>r<<32-e|r>>>e;var ns=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Rr(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function qe(r){return typeof r=="string"&&(r=Rr(r)),De(r),r}var Le=class{clone(){return this._cloneInto()}},is={}.toString;function Zt(r){let e=n=>r().update(qe(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}var Fe=class extends Le{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Gt(e);let n=qe(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,o=new Uint8Array(i);o.set(n.length>i?e.create().update(n).digest():n);for(let s=0;s<o.length;s++)o[s]^=54;this.iHash.update(o),this.oHash=e.create();for(let s=0;s<o.length;s++)o[s]^=106;this.oHash.update(o),o.fill(0)}update(e){return Ie(this),this.iHash.update(e),this}digestInto(e){Ie(this),De(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:n,finished:i,destroyed:o,blockLen:s,outputLen:a}=this;return e=e,e.finished=i,e.destroyed=o,e.blockLen=s,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},wt=(r,e,t)=>new Fe(r,e).update(t).digest();wt.create=(r,e)=>new Fe(r,e);function Cr(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);let i=BigInt(32),o=BigInt(4294967295),s=Number(t>>i&o),a=Number(t&o),c=n?4:0,f=n?0:4;r.setUint32(e+c,s,n),r.setUint32(e+f,a,n)}var Yt=(r,e,t)=>r&e^~r&t,Wt=(r,e,t)=>r&e^r&t^e&t,et=class extends Le{constructor(e,t,n,i){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Je(this.buffer)}update(e){Ie(this);let{view:t,buffer:n,blockLen:i}=this;e=qe(e);let o=e.length;for(let s=0;s<o;){let a=Math.min(i-this.pos,o-s);if(a===i){let c=Je(e);for(;i<=o-s;s+=i)this.process(c,s);continue}n.set(e.subarray(s,s+a),this.pos),this.pos+=a,s+=a,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Ie(this),Vt(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:i,isLE:o}=this,{pos:s}=this;t[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>i-s&&(this.process(n,0),s=0);for(let u=s;u<i;u++)t[u]=0;Cr(n,i-8,BigInt(this.length*8),o),this.process(n,0);let a=Je(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=c/4,y=this.get();if(f>y.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)a.setUint32(4*u,y[u],o)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:i,finished:o,destroyed:s,pos:a}=this;return e.length=i,e.pos=a,e.finished=o,e.destroyed=s,i%t&&e.buffer.set(n),e}};var Dr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ae=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ce=new Uint32Array(64),mt=class extends et{constructor(){super(64,32,8,!1),this.A=ae[0]|0,this.B=ae[1]|0,this.C=ae[2]|0,this.D=ae[3]|0,this.E=ae[4]|0,this.F=ae[5]|0,this.G=ae[6]|0,this.H=ae[7]|0}get(){let{A:e,B:t,C:n,D:i,E:o,F:s,G:a,H:c}=this;return[e,t,n,i,o,s,a,c]}set(e,t,n,i,o,s,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=o|0,this.F=s|0,this.G=a|0,this.H=c|0}process(e,t){for(let u=0;u<16;u++,t+=4)ce[u]=e.getUint32(t,!1);for(let u=16;u<64;u++){let w=ce[u-15],_=ce[u-2],g=Z(w,7)^Z(w,18)^w>>>3,l=Z(_,17)^Z(_,19)^_>>>10;ce[u]=l+ce[u-7]+g+ce[u-16]|0}let{A:n,B:i,C:o,D:s,E:a,F:c,G:f,H:y}=this;for(let u=0;u<64;u++){let w=Z(a,6)^Z(a,11)^Z(a,25),_=y+w+Yt(a,c,f)+Dr[u]+ce[u]|0,l=(Z(n,2)^Z(n,13)^Z(n,22))+Wt(n,i,o)|0;y=f,f=c,c=a,a=s+_|0,s=o,o=i,i=n,n=_+l|0}n=n+this.A|0,i=i+this.B|0,o=o+this.C|0,s=s+this.D|0,a=a+this.E|0,c=c+this.F|0,f=f+this.G|0,y=y+this.H|0,this.set(n,i,o,s,a,c,f,y)}roundClean(){ce.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var Xt=Zt(()=>new mt);var Ue=class extends Ce{async extract(e,t){if(await this._setup(),e.byteLength===0&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)return wt(Xt,new Uint8Array(e),new Uint8Array(t));let n=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,t)}};function Qt(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`positive integer expected, not ${r}`)}function qr(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function Oe(r,...e){if(!qr(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${r.length}`)}function Jt(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Qt(r.outputLen),Qt(r.blockLen)}function ze(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Ft(r,e){Oe(r);let t=e.outputLen;if(r.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var tt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var rt=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),Y=(r,e)=>r<<32-e|r>>>e;var Es=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Mr(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function Me(r){return typeof r=="string"&&(r=Mr(r)),Oe(r),r}function er(...r){let e=0;for(let n=0;n<r.length;n++){let i=r[n];Oe(i),e+=i.length}let t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){let o=r[n];t.set(o,i),i+=o.length}return t}var He=class{clone(){return this._cloneInto()}},ks={}.toString;function tr(r){let e=n=>r().update(Me(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function rr(r=32){if(tt&&typeof tt.getRandomValues=="function")return tt.getRandomValues(new Uint8Array(r));throw new Error("crypto.getRandomValues must be defined")}function $r(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);let i=BigInt(32),o=BigInt(4294967295),s=Number(t>>i&o),a=Number(t&o),c=n?4:0,f=n?0:4;r.setUint32(e+c,s,n),r.setUint32(e+f,a,n)}var nr=(r,e,t)=>r&e^~r&t,ir=(r,e,t)=>r&e^r&t^e&t,nt=class extends He{constructor(e,t,n,i){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=rt(this.buffer)}update(e){ze(this);let{view:t,buffer:n,blockLen:i}=this;e=Me(e);let o=e.length;for(let s=0;s<o;){let a=Math.min(i-this.pos,o-s);if(a===i){let c=rt(e);for(;i<=o-s;s+=i)this.process(c,s);continue}n.set(e.subarray(s,s+a),this.pos),this.pos+=a,s+=a,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){ze(this),Ft(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:i,isLE:o}=this,{pos:s}=this;t[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>i-s&&(this.process(n,0),s=0);for(let u=s;u<i;u++)t[u]=0;$r(n,i-8,BigInt(this.length*8),o),this.process(n,0);let a=rt(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=c/4,y=this.get();if(f>y.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)a.setUint32(4*u,y[u],o)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:i,finished:o,destroyed:s,pos:a}=this;return e.length=i,e.pos=a,e.finished=o,e.destroyed=s,i%t&&e.buffer.set(n),e}};var kt={};Ar(kt,{aInRange:()=>le,abool:()=>ge,abytes:()=>Te,bitGet:()=>Qr,bitLen:()=>Xr,bitMask:()=>Ge,bitSet:()=>Jr,bytesToHex:()=>_e,bytesToNumberBE:()=>re,bytesToNumberLE:()=>ot,concatBytes:()=>Ne,createHmacDrbg:()=>Et,ensureBytes:()=>D,equalBytes:()=>Yr,hexToBytes:()=>ve,hexToNumber:()=>vt,inRange:()=>$e,isBytes:()=>ue,memoized:()=>at,notImplemented:()=>en,numberToBytesBE:()=>fe,numberToBytesLE:()=>st,numberToHexUnpadded:()=>ar,numberToVarBytesBE:()=>Zr,utf8ToBytes:()=>Wr,validateObject:()=>he});var _t=BigInt(0),it=BigInt(1),Gr=BigInt(2);function ue(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function Te(r){if(!ue(r))throw new Error("Uint8Array expected")}function ge(r,e){if(typeof e!="boolean")throw new Error(`${r} must be valid boolean, got "${e}".`)}var Vr=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function _e(r){Te(r);let e="";for(let t=0;t<r.length;t++)e+=Vr[r[t]];return e}function ar(r){let e=r.toString(16);return e.length&1?`0${e}`:e}function vt(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}var te={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function or(r){if(r>=te._0&&r<=te._9)return r-te._0;if(r>=te._A&&r<=te._F)return r-(te._A-10);if(r>=te._a&&r<=te._f)return r-(te._a-10)}function ve(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let e=r.length,t=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);let n=new Uint8Array(t);for(let i=0,o=0;i<t;i++,o+=2){let s=or(r.charCodeAt(o)),a=or(r.charCodeAt(o+1));if(s===void 0||a===void 0){let c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[i]=s*16+a}return n}function re(r){return vt(_e(r))}function ot(r){return Te(r),vt(_e(Uint8Array.from(r).reverse()))}function fe(r,e){return ve(r.toString(16).padStart(e*2,"0"))}function st(r,e){return fe(r,e).reverse()}function Zr(r){return ve(ar(r))}function D(r,e,t){let n;if(typeof e=="string")try{n=ve(e)}catch(o){throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${o}`)}else if(ue(e))n=Uint8Array.from(e);else throw new Error(`${r} must be hex string or Uint8Array`);let i=n.length;if(typeof t=="number"&&i!==t)throw new Error(`${r} expected ${t} bytes, got ${i}`);return n}function Ne(...r){let e=0;for(let n=0;n<r.length;n++){let i=r[n];Te(i),e+=i.length}let t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){let o=r[n];t.set(o,i),i+=o.length}return t}function Yr(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}function Wr(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}var xt=r=>typeof r=="bigint"&&_t<=r;function $e(r,e,t){return xt(r)&&xt(e)&&xt(t)&&e<=r&&r<t}function le(r,e,t,n){if(!$e(e,t,n))throw new Error(`expected valid ${r}: ${t} <= n < ${n}, got ${typeof e} ${e}`)}function Xr(r){let e;for(e=0;r>_t;r>>=it,e+=1);return e}function Qr(r,e){return r>>BigInt(e)&it}function Jr(r,e,t){return r|(t?it:_t)<<BigInt(e)}var Ge=r=>(Gr<<BigInt(r-1))-it,gt=r=>new Uint8Array(r),sr=r=>Uint8Array.from(r);function Et(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=gt(r),i=gt(r),o=0,s=()=>{n.fill(1),i.fill(0),o=0},a=(...u)=>t(i,n,...u),c=(u=gt())=>{i=a(sr([0]),u),n=a(),u.length!==0&&(i=a(sr([1]),u),n=a())},f=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let u=0,w=[];for(;u<e;){n=a();let _=n.slice();w.push(_),u+=n.length}return Ne(...w)};return(u,w)=>{s(),c(u);let _;for(;!(_=w(f()));)c();return s(),_}}var Fr={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||ue(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function he(r,e,t={}){let n=(i,o,s)=>{let a=Fr[o];if(typeof a!="function")throw new Error(`Invalid validator "${o}", expected function`);let c=r[i];if(!(s&&c===void 0)&&!a(c,r))throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${o}`)};for(let[i,o]of Object.entries(e))n(i,o,!1);for(let[i,o]of Object.entries(t))n(i,o,!0);return r}var en=()=>{throw new Error("not implemented")};function at(r){let e=new WeakMap;return(t,...n)=>{let i=e.get(t);if(i!==void 0)return i;let o=r(t,...n);return e.set(t,o),o}}var O=BigInt(0),U=BigInt(1),Ee=BigInt(2),tn=BigInt(3),At=BigInt(4),cr=BigInt(5),ur=BigInt(8),rn=BigInt(9),nn=BigInt(16);function T(r,e){let t=r%e;return t>=O?t:e+t}function on(r,e,t){if(t<=O||e<O)throw new Error("Expected power/modulo > 0");if(t===U)return O;let n=U;for(;e>O;)e&U&&(n=n*r%t),r=r*r%t,e>>=U;return n}function q(r,e,t){let n=r;for(;e-- >O;)n*=n,n%=t;return n}function ct(r,e){if(r===O||e<=O)throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);let t=T(r,e),n=e,i=O,o=U,s=U,a=O;for(;t!==O;){let f=n/t,y=n%t,u=i-s*f,w=o-a*f;n=t,t=y,i=s,o=a,s=u,a=w}if(n!==U)throw new Error("invert: does not exist");return T(i,e)}function sn(r){let e=(r-U)/Ee,t,n,i;for(t=r-U,n=0;t%Ee===O;t/=Ee,n++);for(i=Ee;i<r&&on(i,e,r)!==r-U;i++);if(n===1){let s=(r+U)/At;return function(c,f){let y=c.pow(f,s);if(!c.eql(c.sqr(y),f))throw new Error("Cannot find square root");return y}}let o=(t+U)/Ee;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let f=n,y=a.pow(a.mul(a.ONE,i),t),u=a.pow(c,o),w=a.pow(c,t);for(;!a.eql(w,a.ONE);){if(a.eql(w,a.ZERO))return a.ZERO;let _=1;for(let l=a.sqr(w);_<f&&!a.eql(l,a.ONE);_++)l=a.sqr(l);let g=a.pow(y,U<<BigInt(f-_-1));y=a.sqr(g),u=a.mul(u,g),w=a.mul(w,y),f=_}return u}}function an(r){if(r%At===tn){let e=(r+U)/At;return function(n,i){let o=n.pow(i,e);if(!n.eql(n.sqr(o),i))throw new Error("Cannot find square root");return o}}if(r%ur===cr){let e=(r-cr)/ur;return function(n,i){let o=n.mul(i,Ee),s=n.pow(o,e),a=n.mul(i,s),c=n.mul(n.mul(a,Ee),s),f=n.mul(a,n.sub(c,n.ONE));if(!n.eql(n.sqr(f),i))throw new Error("Cannot find square root");return f}}return r%nn,sn(r)}var cn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function St(r){let e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=cn.reduce((n,i)=>(n[i]="function",n),e);return he(r,t)}function un(r,e,t){if(t<O)throw new Error("Expected power > 0");if(t===O)return r.ONE;if(t===U)return e;let n=r.ONE,i=e;for(;t>O;)t&U&&(n=r.mul(n,i)),i=r.sqr(i),t>>=U;return n}function fn(r,e){let t=new Array(e.length),n=e.reduce((o,s,a)=>r.is0(s)?o:(t[a]=o,r.mul(o,s)),r.ONE),i=r.inv(n);return e.reduceRight((o,s,a)=>r.is0(s)?o:(t[a]=r.mul(o,t[a]),r.mul(o,s)),i),t}function Pt(r,e){let t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function fr(r,e,t=!1,n={}){if(r<=O)throw new Error(`Expected Field ORDER > 0, got ${r}`);let{nBitLength:i,nByteLength:o}=Pt(r,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");let s=an(r),a=Object.freeze({ORDER:r,BITS:i,BYTES:o,MASK:Ge(i),ZERO:O,ONE:U,create:c=>T(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return O<=c&&c<r},is0:c=>c===O,isOdd:c=>(c&U)===U,neg:c=>T(-c,r),eql:(c,f)=>c===f,sqr:c=>T(c*c,r),add:(c,f)=>T(c+f,r),sub:(c,f)=>T(c-f,r),mul:(c,f)=>T(c*f,r),pow:(c,f)=>un(a,c,f),div:(c,f)=>T(c*ct(f,r),r),sqrN:c=>c*c,addN:(c,f)=>c+f,subN:(c,f)=>c-f,mulN:(c,f)=>c*f,inv:c=>ct(c,r),sqrt:n.sqrt||(c=>s(a,c)),invertBatch:c=>fn(a,c),cmov:(c,f,y)=>y?f:c,toBytes:c=>t?st(c,o):fe(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return t?ot(c):re(c)}});return Object.freeze(a)}function lr(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let e=r.toString(2).length;return Math.ceil(e/8)}function Kt(r){let e=lr(r);return e+Math.ceil(e/2)}function hr(r,e,t=!1){let n=r.length,i=lr(e),o=Kt(e);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);let s=t?re(r):ot(r),a=T(s,e-U)+U;return t?st(a,i):fe(a,i)}var hn=BigInt(0),Bt=BigInt(1),It=new WeakMap,dr=new WeakMap;function yr(r,e){let t=(o,s)=>{let a=s.negate();return o?a:s},n=o=>{if(!Number.isSafeInteger(o)||o<=0||o>e)throw new Error(`Wrong window size=${o}, should be [1..${e}]`)},i=o=>{n(o);let s=Math.ceil(e/o)+1,a=2**(o-1);return{windows:s,windowSize:a}};return{constTimeNegate:t,unsafeLadder(o,s){let a=r.ZERO,c=o;for(;s>hn;)s&Bt&&(a=a.add(c)),c=c.double(),s>>=Bt;return a},precomputeWindow(o,s){let{windows:a,windowSize:c}=i(s),f=[],y=o,u=y;for(let w=0;w<a;w++){u=y,f.push(u);for(let _=1;_<c;_++)u=u.add(y),f.push(u);y=u.double()}return f},wNAF(o,s,a){let{windows:c,windowSize:f}=i(o),y=r.ZERO,u=r.BASE,w=BigInt(2**o-1),_=2**o,g=BigInt(o);for(let l=0;l<c;l++){let h=l*f,p=Number(a&w);a>>=g,p>f&&(p-=_,a+=Bt);let v=h,E=h+Math.abs(p)-1,P=l%2!==0,A=p<0;p===0?u=u.add(t(P,s[v])):y=y.add(t(A,s[E]))}return{p:y,f:u}},wNAFCached(o,s,a){let c=dr.get(o)||1,f=It.get(o);return f||(f=this.precomputeWindow(o,c),c!==1&&It.set(o,a(f))),this.wNAF(c,f,s)},setWindowSize(o,s){n(s),dr.set(o,s),It.delete(o)}}}function Lt(r){return St(r.Fp),he(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Pt(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var zs=new Uint8Array;var Hs=new Uint8Array([100,107,112,95,112,114,107]),Ts=new Uint8Array([115,107]);var yn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),de=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ye=new Uint32Array(64),Ut=class extends nt{constructor(){super(64,32,8,!1),this.A=de[0]|0,this.B=de[1]|0,this.C=de[2]|0,this.D=de[3]|0,this.E=de[4]|0,this.F=de[5]|0,this.G=de[6]|0,this.H=de[7]|0}get(){let{A:e,B:t,C:n,D:i,E:o,F:s,G:a,H:c}=this;return[e,t,n,i,o,s,a,c]}set(e,t,n,i,o,s,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=o|0,this.F=s|0,this.G=a|0,this.H=c|0}process(e,t){for(let u=0;u<16;u++,t+=4)ye[u]=e.getUint32(t,!1);for(let u=16;u<64;u++){let w=ye[u-15],_=ye[u-2],g=Y(w,7)^Y(w,18)^w>>>3,l=Y(_,17)^Y(_,19)^_>>>10;ye[u]=l+ye[u-7]+g+ye[u-16]|0}let{A:n,B:i,C:o,D:s,E:a,F:c,G:f,H:y}=this;for(let u=0;u<64;u++){let w=Y(a,6)^Y(a,11)^Y(a,25),_=y+w+nr(a,c,f)+yn[u]+ye[u]|0,l=(Y(n,2)^Y(n,13)^Y(n,22))+ir(n,i,o)|0;y=f,f=c,c=a,a=s+_|0,s=o,o=i,i=n,n=_+l|0}n=n+this.A|0,i=i+this.B|0,o=o+this.C|0,s=s+this.D|0,a=a+this.E|0,c=c+this.F|0,f=f+this.G|0,y=y+this.H|0,this.set(n,i,o,s,a,c,f,y)}roundClean(){ye.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var br=tr(()=>new Ut);var ut=class extends He{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Jt(e);let n=Me(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,o=new Uint8Array(i);o.set(n.length>i?e.create().update(n).digest():n);for(let s=0;s<o.length;s++)o[s]^=54;this.iHash.update(o),this.oHash=e.create();for(let s=0;s<o.length;s++)o[s]^=106;this.oHash.update(o),o.fill(0)}update(e){return ze(this),this.iHash.update(e),this}digestInto(e){ze(this),Oe(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:n,finished:i,destroyed:o,blockLen:s,outputLen:a}=this;return e=e,e.finished=i,e.destroyed=o,e.blockLen=s,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},Ot=(r,e,t)=>new ut(r,e).update(t).digest();Ot.create=(r,e)=>new ut(r,e);function pr(r){r.lowS!==void 0&&ge("lowS",r.lowS),r.prehash!==void 0&&ge("prehash",r.prehash)}function bn(r){let e=Lt(r);he(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:t,Fp:n,a:i}=e;if(t){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}var{bytesToNumberBE:pn,hexToBytes:wn}=kt,ke={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(r){let{Err:e}=ke;if(r.length<2||r[0]!==2)throw new e("Invalid signature integer tag");let t=r[1],n=r.subarray(2,t+2);if(!t||n.length!==t)throw new e("Invalid signature integer: wrong length");if(n[0]&128)throw new e("Invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:pn(n),l:r.subarray(t+2)}},toSig(r){let{Err:e}=ke,t=typeof r=="string"?wn(r):r;Te(t);let n=t.length;if(n<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==n-2)throw new e("Invalid signature: incorrect length");let{d:i,l:o}=ke._parseInt(t.subarray(2)),{d:s,l:a}=ke._parseInt(o);if(a.length)throw new e("Invalid signature: left bytes after parsing");return{r:i,s}},hexFromSig(r){let e=f=>Number.parseInt(f[0],16)&8?"00"+f:f,t=f=>{let y=f.toString(16);return y.length&1?`0${y}`:y},n=e(t(r.s)),i=e(t(r.r)),o=n.length/2,s=i.length/2,a=t(o),c=t(s);return`30${t(s+o+4)}02${c}${i}02${a}${n}`}},be=BigInt(0),H=BigInt(1),ra=BigInt(2),wr=BigInt(3),na=BigInt(4);function mn(r){let e=bn(r),{Fp:t}=e,n=e.toBytes||((g,l,h)=>{let p=l.toAffine();return Ne(Uint8Array.from([4]),t.toBytes(p.x),t.toBytes(p.y))}),i=e.fromBytes||(g=>{let l=g.subarray(1),h=t.fromBytes(l.subarray(0,t.BYTES)),p=t.fromBytes(l.subarray(t.BYTES,2*t.BYTES));return{x:h,y:p}});function o(g){let{a:l,b:h}=e,p=t.sqr(g),v=t.mul(p,g);return t.add(t.add(v,t.mul(g,l)),h)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function s(g){return $e(g,H,e.n)}function a(g){let{allowedPrivateKeyLengths:l,nByteLength:h,wrapPrivateKey:p,n:v}=e;if(l&&typeof g!="bigint"){if(ue(g)&&(g=_e(g)),typeof g!="string"||!l.includes(g.length))throw new Error("Invalid key");g=g.padStart(h*2,"0")}let E;try{E=typeof g=="bigint"?g:re(D("private key",g,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof g}`)}return p&&(E=T(E,v)),le("private key",E,H,v),E}function c(g){if(!(g instanceof u))throw new Error("ProjectivePoint expected")}let f=at((g,l)=>{let{px:h,py:p,pz:v}=g;if(t.eql(v,t.ONE))return{x:h,y:p};let E=g.is0();l==null&&(l=E?t.ONE:t.inv(v));let P=t.mul(h,l),A=t.mul(p,l),x=t.mul(v,l);if(E)return{x:t.ZERO,y:t.ZERO};if(!t.eql(x,t.ONE))throw new Error("invZ was invalid");return{x:P,y:A}}),y=at(g=>{if(g.is0()){if(e.allowInfinityPoint&&!t.is0(g.py))return;throw new Error("bad point: ZERO")}let{x:l,y:h}=g.toAffine();if(!t.isValid(l)||!t.isValid(h))throw new Error("bad point: x or y not FE");let p=t.sqr(h),v=o(l);if(!t.eql(p,v))throw new Error("bad point: equation left != right");if(!g.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class u{constructor(l,h,p){if(this.px=l,this.py=h,this.pz=p,l==null||!t.isValid(l))throw new Error("x required");if(h==null||!t.isValid(h))throw new Error("y required");if(p==null||!t.isValid(p))throw new Error("z required");Object.freeze(this)}static fromAffine(l){let{x:h,y:p}=l||{};if(!l||!t.isValid(h)||!t.isValid(p))throw new Error("invalid affine point");if(l instanceof u)throw new Error("projective point not allowed");let v=E=>t.eql(E,t.ZERO);return v(h)&&v(p)?u.ZERO:new u(h,p,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){let h=t.invertBatch(l.map(p=>p.pz));return l.map((p,v)=>p.toAffine(h[v])).map(u.fromAffine)}static fromHex(l){let h=u.fromAffine(i(D("pointHex",l)));return h.assertValidity(),h}static fromPrivateKey(l){return u.BASE.multiply(a(l))}_setWindowSize(l){_.setWindowSize(this,l)}assertValidity(){y(this)}hasEvenY(){let{y:l}=this.toAffine();if(t.isOdd)return!t.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){c(l);let{px:h,py:p,pz:v}=this,{px:E,py:P,pz:A}=l,x=t.eql(t.mul(h,A),t.mul(E,v)),k=t.eql(t.mul(p,A),t.mul(P,v));return x&&k}negate(){return new u(this.px,t.neg(this.py),this.pz)}double(){let{a:l,b:h}=e,p=t.mul(h,wr),{px:v,py:E,pz:P}=this,A=t.ZERO,x=t.ZERO,k=t.ZERO,S=t.mul(v,v),M=t.mul(E,E),L=t.mul(P,P),K=t.mul(v,E);return K=t.add(K,K),k=t.mul(v,P),k=t.add(k,k),A=t.mul(l,k),x=t.mul(p,L),x=t.add(A,x),A=t.sub(M,x),x=t.add(M,x),x=t.mul(A,x),A=t.mul(K,A),k=t.mul(p,k),L=t.mul(l,L),K=t.sub(S,L),K=t.mul(l,K),K=t.add(K,k),k=t.add(S,S),S=t.add(k,S),S=t.add(S,L),S=t.mul(S,K),x=t.add(x,S),L=t.mul(E,P),L=t.add(L,L),S=t.mul(L,K),A=t.sub(A,S),k=t.mul(L,M),k=t.add(k,k),k=t.add(k,k),new u(A,x,k)}add(l){c(l);let{px:h,py:p,pz:v}=this,{px:E,py:P,pz:A}=l,x=t.ZERO,k=t.ZERO,S=t.ZERO,M=e.a,L=t.mul(e.b,wr),K=t.mul(h,E),R=t.mul(p,P),C=t.mul(v,A),b=t.add(h,p),d=t.add(E,P);b=t.mul(b,d),d=t.add(K,R),b=t.sub(b,d),d=t.add(h,v);let m=t.add(E,A);return d=t.mul(d,m),m=t.add(K,C),d=t.sub(d,m),m=t.add(p,v),x=t.add(P,A),m=t.mul(m,x),x=t.add(R,C),m=t.sub(m,x),S=t.mul(M,d),x=t.mul(L,C),S=t.add(x,S),x=t.sub(R,S),S=t.add(R,S),k=t.mul(x,S),R=t.add(K,K),R=t.add(R,K),C=t.mul(M,C),d=t.mul(L,d),R=t.add(R,C),C=t.sub(K,C),C=t.mul(M,C),d=t.add(d,C),K=t.mul(R,d),k=t.add(k,K),K=t.mul(m,d),x=t.mul(b,x),x=t.sub(x,K),K=t.mul(b,R),S=t.mul(m,S),S=t.add(S,K),new u(x,k,S)}subtract(l){return this.add(l.negate())}is0(){return this.equals(u.ZERO)}wNAF(l){return _.wNAFCached(this,l,u.normalizeZ)}multiplyUnsafe(l){le("scalar",l,be,e.n);let h=u.ZERO;if(l===be)return h;if(l===H)return this;let{endo:p}=e;if(!p)return _.unsafeLadder(this,l);let{k1neg:v,k1:E,k2neg:P,k2:A}=p.splitScalar(l),x=h,k=h,S=this;for(;E>be||A>be;)E&H&&(x=x.add(S)),A&H&&(k=k.add(S)),S=S.double(),E>>=H,A>>=H;return v&&(x=x.negate()),P&&(k=k.negate()),k=new u(t.mul(k.px,p.beta),k.py,k.pz),x.add(k)}multiply(l){let{endo:h,n:p}=e;le("scalar",l,H,p);let v,E;if(h){let{k1neg:P,k1:A,k2neg:x,k2:k}=h.splitScalar(l),{p:S,f:M}=this.wNAF(A),{p:L,f:K}=this.wNAF(k);S=_.constTimeNegate(P,S),L=_.constTimeNegate(x,L),L=new u(t.mul(L.px,h.beta),L.py,L.pz),v=S.add(L),E=M.add(K)}else{let{p:P,f:A}=this.wNAF(l);v=P,E=A}return u.normalizeZ([v,E])[0]}multiplyAndAddUnsafe(l,h,p){let v=u.BASE,E=(A,x)=>x===be||x===H||!A.equals(v)?A.multiplyUnsafe(x):A.multiply(x),P=E(this,h).add(E(l,p));return P.is0()?void 0:P}toAffine(l){return f(this,l)}isTorsionFree(){let{h:l,isTorsionFree:h}=e;if(l===H)return!0;if(h)return h(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:l,clearCofactor:h}=e;return l===H?this:h?h(u,this):this.multiplyUnsafe(e.h)}toRawBytes(l=!0){return ge("isCompressed",l),this.assertValidity(),n(u,this,l)}toHex(l=!0){return ge("isCompressed",l),_e(this.toRawBytes(l))}}u.BASE=new u(e.Gx,e.Gy,t.ONE),u.ZERO=new u(t.ZERO,t.ONE,t.ZERO);let w=e.nBitLength,_=yr(u,e.endo?Math.ceil(w/2):w);return{CURVE:e,ProjectivePoint:u,normPrivateKeyToScalar:a,weierstrassEquation:o,isWithinCurveOrder:s}}function xn(r){let e=Lt(r);return he(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function mr(r){let e=xn(r),{Fp:t,n}=e,i=t.BYTES+1,o=2*t.BYTES+1;function s(b){return T(b,n)}function a(b){return ct(b,n)}let{ProjectivePoint:c,normPrivateKeyToScalar:f,weierstrassEquation:y,isWithinCurveOrder:u}=mn({...e,toBytes(b,d,m){let I=d.toAffine(),B=t.toBytes(I.x),z=Ne;return ge("isCompressed",m),m?z(Uint8Array.from([d.hasEvenY()?2:3]),B):z(Uint8Array.from([4]),B,t.toBytes(I.y))},fromBytes(b){let d=b.length,m=b[0],I=b.subarray(1);if(d===i&&(m===2||m===3)){let B=re(I);if(!$e(B,H,t.ORDER))throw new Error("Point is not on curve");let z=y(B),N;try{N=t.sqrt(z)}catch($){let ie=$ instanceof Error?": "+$.message:"";throw new Error("Point is not on curve"+ie)}let j=(N&H)===H;return(m&1)===1!==j&&(N=t.neg(N)),{x:B,y:N}}else if(d===o&&m===4){let B=t.fromBytes(I.subarray(0,t.BYTES)),z=t.fromBytes(I.subarray(t.BYTES,2*t.BYTES));return{x:B,y:z}}else throw new Error(`Point of length ${d} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}}),w=b=>_e(fe(b,e.nByteLength));function _(b){let d=n>>H;return b>d}function g(b){return _(b)?s(-b):b}let l=(b,d,m)=>re(b.slice(d,m));class h{constructor(d,m,I){this.r=d,this.s=m,this.recovery=I,this.assertValidity()}static fromCompact(d){let m=e.nByteLength;return d=D("compactSignature",d,m*2),new h(l(d,0,m),l(d,m,2*m))}static fromDER(d){let{r:m,s:I}=ke.toSig(D("DER",d));return new h(m,I)}assertValidity(){le("r",this.r,H,n),le("s",this.s,H,n)}addRecoveryBit(d){return new h(this.r,this.s,d)}recoverPublicKey(d){let{r:m,s:I,recovery:B}=this,z=x(D("msgHash",d));if(B==null||![0,1,2,3].includes(B))throw new Error("recovery id invalid");let N=B===2||B===3?m+e.n:m;if(N>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");let j=B&1?"03":"02",ne=c.fromHex(j+w(N)),$=a(N),ie=s(-z*$),je=s(I*$),oe=c.BASE.multiplyAndAddUnsafe(ne,ie,je);if(!oe)throw new Error("point at infinify");return oe.assertValidity(),oe}hasHighS(){return _(this.s)}normalizeS(){return this.hasHighS()?new h(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return ve(this.toDERHex())}toDERHex(){return ke.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ve(this.toCompactHex())}toCompactHex(){return w(this.r)+w(this.s)}}let p={isValidPrivateKey(b){try{return f(b),!0}catch{return!1}},normPrivateKeyToScalar:f,randomPrivateKey:()=>{let b=Kt(e.n);return hr(e.randomBytes(b),e.n)},precompute(b=8,d=c.BASE){return d._setWindowSize(b),d.multiply(BigInt(3)),d}};function v(b,d=!0){return c.fromPrivateKey(b).toRawBytes(d)}function E(b){let d=ue(b),m=typeof b=="string",I=(d||m)&&b.length;return d?I===i||I===o:m?I===2*i||I===2*o:b instanceof c}function P(b,d,m=!0){if(E(b))throw new Error("first arg must be private key");if(!E(d))throw new Error("second arg must be public key");return c.fromHex(d).multiply(f(b)).toRawBytes(m)}let A=e.bits2int||function(b){let d=re(b),m=b.length*8-e.nBitLength;return m>0?d>>BigInt(m):d},x=e.bits2int_modN||function(b){return s(A(b))},k=Ge(e.nBitLength);function S(b){return le(`num < 2^${e.nBitLength}`,b,be,k),fe(b,e.nByteLength)}function M(b,d,m=L){if(["recovered","canonical"].some(pe=>pe in m))throw new Error("sign() legacy options not supported");let{hash:I,randomBytes:B}=e,{lowS:z,prehash:N,extraEntropy:j}=m;z==null&&(z=!0),b=D("msgHash",b),pr(m),N&&(b=D("prehashed msgHash",I(b)));let ne=x(b),$=f(d),ie=[S($),S(ne)];if(j!=null&&j!==!1){let pe=j===!0?B(t.BYTES):j;ie.push(D("extraEntropy",pe))}let je=Ne(...ie),oe=ne;function ht(pe){let Ae=A(pe);if(!u(Ae))return;let jt=a(Ae),W=c.BASE.multiply(Ae).toAffine(),Se=s(W.x);if(Se===be)return;let Ze=s(jt*s(oe+Se*$));if(Ze===be)return;let Rt=(W.x===Se?0:2)|Number(W.y&H),Ct=Ze;return z&&_(Ze)&&(Ct=g(Ze),Rt^=1),new h(Se,Ct,Rt)}return{seed:je,k2sig:ht}}let L={lowS:e.lowS,prehash:!1},K={lowS:e.lowS,prehash:!1};function R(b,d,m=L){let{seed:I,k2sig:B}=M(b,d,m),z=e;return Et(z.hash.outputLen,z.nByteLength,z.hmac)(I,B)}c.BASE._setWindowSize(8);function C(b,d,m,I=K){let B=b;if(d=D("msgHash",d),m=D("publicKey",m),"strict"in I)throw new Error("options.strict was renamed to lowS");pr(I);let{lowS:z,prehash:N}=I,j,ne;try{if(typeof B=="string"||ue(B))try{j=h.fromDER(B)}catch(W){if(!(W instanceof ke.Err))throw W;j=h.fromCompact(B)}else if(typeof B=="object"&&typeof B.r=="bigint"&&typeof B.s=="bigint"){let{r:W,s:Se}=B;j=new h(W,Se)}else throw new Error("PARSE");ne=c.fromHex(m)}catch(W){if(W.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(z&&j.hasHighS())return!1;N&&(d=e.hash(d));let{r:$,s:ie}=j,je=x(d),oe=a(ie),ht=s(je*oe),pe=s($*oe),Ae=c.BASE.multiplyAndAddUnsafe(ne,ht,pe)?.toAffine();return Ae?s(Ae.x)===$:!1}return{CURVE:e,getPublicKey:v,getSharedSecret:P,sign:R,verify:C,ProjectivePoint:c,Signature:h,utils:p}}function gn(r){return{hash:r,hmac:(e,...t)=>Ot(r,e,er(...t)),randomBytes:rr}}function xr(r,e){let t=n=>mr({...r,...gn(n)});return Object.freeze({...t(e),create:t})}var vr=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),gr=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_n=BigInt(1),zt=BigInt(2),_r=(r,e)=>(r+e/zt)/e;function vn(r){let e=vr,t=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),s=BigInt(23),a=BigInt(44),c=BigInt(88),f=r*r*r%e,y=f*f*r%e,u=q(y,t,e)*y%e,w=q(u,t,e)*y%e,_=q(w,zt,e)*f%e,g=q(_,i,e)*_%e,l=q(g,o,e)*g%e,h=q(l,a,e)*l%e,p=q(h,c,e)*h%e,v=q(p,a,e)*l%e,E=q(v,t,e)*y%e,P=q(E,s,e)*g%e,A=q(P,n,e)*f%e,x=q(A,zt,e);if(!Ht.eql(Ht.sqr(x),r))throw new Error("Cannot find square root");return x}var Ht=fr(vr,void 0,void 0,{sqrt:vn}),Ve=xr({a:BigInt(0),b:BigInt(7),Fp:Ht,n:gr,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{let e=gr,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-_n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,s=BigInt("0x100000000000000000000000000000000"),a=_r(o*r,e),c=_r(-n*r,e),f=T(r-a*t-c*i,e),y=T(-a*n-c*o,e),u=f>s,w=y>s;if(u&&(f=e-f),w&&(y=e-y),f>s||y>s)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:u,k1:f,k2neg:w,k2:y}}}},br),ha=BigInt(0);var da=Ve.ProjectivePoint;var ft="ECDH",Er=new Uint8Array,Tt=["deriveBits"],En=new Uint8Array([100,107,112,95,112,114,107]),kn=new Uint8Array([115,107]),lt=class{constructor(e){Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=e,this._nPk=33,this._nSk=32}async serializePublicKey(e){try{return await this._serializePublicKey(e)}catch(t){throw new ee(t)}}async deserializePublicKey(e){try{return await this._importRawKey(e,!0)}catch(t){throw new X(t)}}async serializePrivateKey(e){try{return await this._serializePrivateKey(e)}catch(t){throw new ee(t)}}async deserializePrivateKey(e){try{return await this._importRawKey(e,!1)}catch(t){throw new X(t)}}async importKey(e,t,n){try{if(e!=="raw")throw new Error("Unsupported format");return await this._importRawKey(t,n)}catch(i){throw new X(i)}}async generateKeyPair(){try{let e=Ve.utils.randomPrivateKey(),t=new Q(ft,e,"private",Tt);return{publicKey:await this.derivePublicKey(t),privateKey:t}}catch(e){throw new G(e)}}async deriveKeyPair(e){try{let t=await this._hkdf.labeledExtract(Er,En,new Uint8Array(e)),n=await this._hkdf.labeledExpand(t,kn,Er,this._nSk),i=new Q(ft,new Uint8Array(n),"private",Tt);return{privateKey:i,publicKey:await this.derivePublicKey(i)}}catch(t){throw new Pe(t)}}async derivePublicKey(e){try{return await this._derivePublicKey(e)}catch(t){throw new X(t)}}async dh(e,t){try{return await this._dh(e,t)}catch(n){throw new ee(n)}}_serializePublicKey(e){return new Promise(t=>{t(e.key.buffer)})}_serializePrivateKey(e){return new Promise(t=>{t(e.key.buffer)})}_importRawKey(e,t){return new Promise((n,i)=>{t&&e.byteLength!==this._nPk&&i(new Error("Invalid length of the key")),!t&&e.byteLength!==this._nSk&&i(new Error("Invalid length of the key")),n(new Q(ft,new Uint8Array(e),t?"public":"private",t?[]:Tt))})}_derivePublicKey(e){return new Promise((t,n)=>{try{let i=Ve.getPublicKey(e.key);t(new Q(ft,i,"public"))}catch(i){n(i)}})}_dh(e,t){return new Promise((n,i)=>{try{n(Ve.getSharedSecret(e.key,t.key).buffer)}catch(o){i(o)}})}};var Nt=class extends xe{constructor(){let e=new Ue;super(se.DhkemSecp256k1HkdfSha256,new lt(e),e),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:se.DhkemSecp256k1HkdfSha256}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:32})}};export{Nt as DhkemSecp256k1HkdfSha256};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
