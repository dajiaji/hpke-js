var yt=e=>e instanceof Uint8Array;var R=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),ft=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),gt=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!gt)throw new Error("Non little-endian hardware is not supported");function J(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function Q(e){if(typeof e=="string"&&(e=J(e)),!yt(e))throw new Error(`expected Uint8Array, got ${typeof e}`);return e}var wt=e=>Object.prototype.toString.call(e)==="[object Object]"&&e.constructor===Object;function st(e,t){if(t!==void 0&&(typeof t!="object"||!wt(t)))throw new Error("options must be object or undefined");return Object.assign(e,t)}function M(e,t){if(!(e instanceof Uint8Array))throw new Error("Uint8Array expected");if(typeof t=="number"&&e.length!==t)throw new Error(`Uint8Array length ${t} expected`)}function it(e,t){if(e.length!==t.length)throw new Error("equalBytes: Different size of Uint8Arrays");let n=!0;for(let r=0;r<e.length;r++)n&&(n=e[r]===t[r]);return n}function Y(e,t,n,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,n,r);let c=BigInt(32),f=BigInt(4294967295),s=Number(n>>c&f),o=Number(n&f),y=r?4:0,l=r?0:4;e.setUint32(t+y,s,r),e.setUint32(t+l,o,r)}function tt(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function dt(e){if(typeof e!="boolean")throw new Error(`Expected boolean, not ${e}`)}function ct(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}function bt(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("hash must be wrapped by utils.wrapConstructor");tt(e.outputLen),tt(e.blockLen)}function mt(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Ut(e,t){ct(e);let n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}var At={number:tt,bool:dt,bytes:ct,hash:bt,exists:mt,output:Ut},K=At;var H=(e,t)=>e[t++]&255|(e[t++]&255)<<8,et=class{constructor(t){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,t=Q(t),M(t,32);let n=H(t,0),r=H(t,2),c=H(t,4),f=H(t,6),s=H(t,8),o=H(t,10),y=H(t,12),l=H(t,14);this.r[0]=n&8191,this.r[1]=(n>>>13|r<<3)&8191,this.r[2]=(r>>>10|c<<6)&7939,this.r[3]=(c>>>7|f<<9)&8191,this.r[4]=(f>>>4|s<<12)&255,this.r[5]=s>>>1&8190,this.r[6]=(s>>>14|o<<2)&8191,this.r[7]=(o>>>11|y<<5)&8065,this.r[8]=(y>>>8|l<<8)&8191,this.r[9]=l>>>5&127;for(let u=0;u<8;u++)this.pad[u]=H(t,16+2*u)}process(t,n,r=!1){let c=r?0:2048,{h:f,r:s}=this,o=s[0],y=s[1],l=s[2],u=s[3],d=s[4],L=s[5],P=s[6],O=s[7],B=s[8],$=s[9],N=H(t,n+0),D=H(t,n+2),T=H(t,n+4),F=H(t,n+6),z=H(t,n+8),_=H(t,n+10),j=H(t,n+12),I=H(t,n+14),h=f[0]+(N&8191),g=f[1]+((N>>>13|D<<3)&8191),w=f[2]+((D>>>10|T<<6)&8191),a=f[3]+((T>>>7|F<<9)&8191),p=f[4]+((F>>>4|z<<12)&8191),b=f[5]+(z>>>1&8191),m=f[6]+((z>>>14|_<<2)&8191),U=f[7]+((_>>>11|j<<5)&8191),A=f[8]+((j>>>8|I<<8)&8191),E=f[9]+(I>>>5|c),i=0,C=i+h*o+g*(5*$)+w*(5*B)+a*(5*O)+p*(5*P);i=C>>>13,C&=8191,C+=b*(5*L)+m*(5*d)+U*(5*u)+A*(5*l)+E*(5*y),i+=C>>>13,C&=8191;let k=i+h*y+g*o+w*(5*$)+a*(5*B)+p*(5*O);i=k>>>13,k&=8191,k+=b*(5*P)+m*(5*L)+U*(5*d)+A*(5*u)+E*(5*l),i+=k>>>13,k&=8191;let S=i+h*l+g*y+w*o+a*(5*$)+p*(5*B);i=S>>>13,S&=8191,S+=b*(5*O)+m*(5*P)+U*(5*L)+A*(5*d)+E*(5*u),i+=S>>>13,S&=8191;let v=i+h*u+g*l+w*y+a*o+p*(5*$);i=v>>>13,v&=8191,v+=b*(5*B)+m*(5*O)+U*(5*P)+A*(5*L)+E*(5*d),i+=v>>>13,v&=8191;let q=i+h*d+g*u+w*l+a*y+p*o;i=q>>>13,q&=8191,q+=b*(5*$)+m*(5*B)+U*(5*O)+A*(5*P)+E*(5*L),i+=q>>>13,q&=8191;let V=i+h*L+g*d+w*u+a*l+p*y;i=V>>>13,V&=8191,V+=b*o+m*(5*$)+U*(5*B)+A*(5*O)+E*(5*P),i+=V>>>13,V&=8191;let X=i+h*P+g*L+w*d+a*u+p*l;i=X>>>13,X&=8191,X+=b*y+m*o+U*(5*$)+A*(5*B)+E*(5*O),i+=X>>>13,X&=8191;let G=i+h*O+g*P+w*L+a*d+p*u;i=G>>>13,G&=8191,G+=b*l+m*y+U*o+A*(5*$)+E*(5*B),i+=G>>>13,G&=8191;let W=i+h*B+g*O+w*P+a*L+p*d;i=W>>>13,W&=8191,W+=b*u+m*l+U*y+A*o+E*(5*$),i+=W>>>13,W&=8191;let Z=i+h*$+g*B+w*O+a*P+p*L;i=Z>>>13,Z&=8191,Z+=b*d+m*u+U*l+A*y+E*o,i+=Z>>>13,Z&=8191,i=(i<<2)+i|0,i=i+C|0,C=i&8191,i=i>>>13,k+=i,f[0]=C,f[1]=k,f[2]=S,f[3]=v,f[4]=q,f[5]=V,f[6]=X,f[7]=G,f[8]=W,f[9]=Z}finalize(){let{h:t,pad:n}=this,r=new Uint16Array(10),c=t[1]>>>13;t[1]&=8191;for(let o=2;o<10;o++)t[o]+=c,c=t[o]>>>13,t[o]&=8191;t[0]+=c*5,c=t[0]>>>13,t[0]&=8191,t[1]+=c,c=t[1]>>>13,t[1]&=8191,t[2]+=c,r[0]=t[0]+5,c=r[0]>>>13,r[0]&=8191;for(let o=1;o<10;o++)r[o]=t[o]+c,c=r[o]>>>13,r[o]&=8191;r[9]-=8192;let f=(c^1)-1;for(let o=0;o<10;o++)r[o]&=f;f=~f;for(let o=0;o<10;o++)t[o]=t[o]&f|r[o];t[0]=(t[0]|t[1]<<13)&65535,t[1]=(t[1]>>>3|t[2]<<10)&65535,t[2]=(t[2]>>>6|t[3]<<7)&65535,t[3]=(t[3]>>>9|t[4]<<4)&65535,t[4]=(t[4]>>>12|t[5]<<1|t[6]<<14)&65535,t[5]=(t[6]>>>2|t[7]<<11)&65535,t[6]=(t[7]>>>5|t[8]<<8)&65535,t[7]=(t[8]>>>8|t[9]<<5)&65535;let s=t[0]+n[0];t[0]=s&65535;for(let o=1;o<8;o++)s=(t[o]+n[o]|0)+(s>>>16)|0,t[o]=s&65535}update(t){K.exists(this);let{buffer:n,blockLen:r}=this;t=Q(t);let c=t.length;for(let f=0;f<c;){let s=Math.min(r-this.pos,c-f);if(s===r){for(;r<=c-f;f+=r)this.process(t,f);continue}n.set(t.subarray(f,f+s),this.pos),this.pos+=s,f+=s,this.pos===r&&(this.process(n,0,!1),this.pos=0)}return this}destroy(){this.h.fill(0),this.r.fill(0),this.buffer.fill(0),this.pad.fill(0)}digestInto(t){K.exists(this),K.output(t,this),this.finished=!0;let{buffer:n,h:r}=this,{pos:c}=this;if(c){for(n[c++]=1;c<16;c++)n[c]=0;this.process(n,0,!0)}this.finalize();let f=0;for(let s=0;s<8;s++)t[f++]=r[s]>>>0,t[f++]=r[s]>>>8;return t}digest(){let{buffer:t,outputLen:n}=this;this.digestInto(t);let r=t.slice(0,n);return this.destroy(),r}};function Et(e){let t=(r,c)=>e(c).update(Q(r)).digest(),n=e(new Uint8Array(32));return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=r=>e(r),t}var ht=Et(e=>new et(e));var Lt=J("expand 16-byte k"),Bt=J("expand 32-byte k"),St=R(Lt),Ct=R(Bt),lt=e=>!(e.byteOffset%4),at=e=>{let{core:t,rounds:n,counterRight:r,counterLen:c,allow128bitKeys:f,extendNonceFn:s,blockLen:o}=st({rounds:20,counterRight:!1,counterLen:8,allow128bitKeys:!0,blockLen:64},e);K.number(c),K.number(n),K.number(o),K.bool(r),K.bool(f);let y=o/4;if(o%4!==0)throw new Error("Salsa/ChaCha: blockLen must be aligned to 4 bytes");return(l,u,d,L,P=0)=>{if(K.bytes(l),K.bytes(u),K.bytes(d),L||(L=new Uint8Array(d.length)),K.bytes(L),K.number(P),P<0||P>=2**32-1)throw new Error("Salsa/ChaCha: counter overflow");if(L.length<d.length)throw new Error(`Salsa/ChaCha: output (${L.length}) is shorter than data (${d.length})`);let O=[],B,$;if(l.length===32)B=l,$=Ct;else if(l.length===16&&f)B=new Uint8Array(32),B.set(l),B.set(l,16),$=St,O.push(B);else throw new Error(`Salsa/ChaCha: invalid 32-byte key, got length=${l.length}`);if(s){if(u.length<=16)throw new Error("Salsa/ChaCha: extended nonce must be bigger than 16 bytes");B=s($,B,u.subarray(0,16),new Uint8Array(32)),O.push(B),u=u.subarray(16)}let N=16-c;if(u.length!==N)throw new Error(`Salsa/ChaCha: nonce must be ${N} or 16 bytes`);if(N!==12){let h=new Uint8Array(12);h.set(u,r?0:12-u.length),O.push(u=h)}let D=new Uint8Array(o),T=R(D),F=R(B),z=R(u),_=lt(d)&&R(d),j=lt(L)&&R(L);O.push(T);let I=d.length;for(let h=0,g=P;h<I;g++){if(t($,F,z,T,g,n),g>=2**32-1)throw new Error("Salsa/ChaCha: counter overflow");let w=Math.min(o,I-h);if(w===o&&j&&_){let a=h/4;if(h%4!==0)throw new Error("Salsa/ChaCha: invalid block position");for(let p=0;p<y;p++)j[a+p]=_[a+p]^T[p];h+=o;continue}for(let a=0;a<w;a++)L[h+a]=d[h+a]^D[a];h+=w}for(let h=0;h<O.length;h++)O[h].fill(0);return L}};var x=(e,t)=>e<<t|e>>>32-t;function kt(e,t,n,r,c,f=20){let s=e[0],o=e[1],y=e[2],l=e[3],u=t[0],d=t[1],L=t[2],P=t[3],O=t[4],B=t[5],$=t[6],N=t[7],D=c,T=n[0],F=n[1],z=n[2],_=s,j=o,I=y,h=l,g=u,w=d,a=L,p=P,b=O,m=B,U=$,A=N,E=D,i=T,C=F,k=z;for(let v=0;v<f;v+=2)_=_+g|0,E=x(E^_,16),b=b+E|0,g=x(g^b,12),_=_+g|0,E=x(E^_,8),b=b+E|0,g=x(g^b,7),j=j+w|0,i=x(i^j,16),m=m+i|0,w=x(w^m,12),j=j+w|0,i=x(i^j,8),m=m+i|0,w=x(w^m,7),I=I+a|0,C=x(C^I,16),U=U+C|0,a=x(a^U,12),I=I+a|0,C=x(C^I,8),U=U+C|0,a=x(a^U,7),h=h+p|0,k=x(k^h,16),A=A+k|0,p=x(p^A,12),h=h+p|0,k=x(k^h,8),A=A+k|0,p=x(p^A,7),_=_+w|0,k=x(k^_,16),U=U+k|0,w=x(w^U,12),_=_+w|0,k=x(k^_,8),U=U+k|0,w=x(w^U,7),j=j+a|0,E=x(E^j,16),A=A+E|0,a=x(a^A,12),j=j+a|0,E=x(E^j,8),A=A+E|0,a=x(a^A,7),I=I+p|0,i=x(i^I,16),b=b+i|0,p=x(p^b,12),I=I+p|0,i=x(i^I,8),b=b+i|0,p=x(p^b,7),h=h+g|0,C=x(C^h,16),m=m+C|0,g=x(g^m,12),h=h+g|0,C=x(C^h,8),m=m+C|0,g=x(g^m,7);let S=0;r[S++]=s+_|0,r[S++]=o+j|0,r[S++]=y+I|0,r[S++]=l+h|0,r[S++]=u+g|0,r[S++]=d+w|0,r[S++]=L+a|0,r[S++]=P+p|0,r[S++]=O+b|0,r[S++]=B+m|0,r[S++]=$+U|0,r[S++]=N+A|0,r[S++]=D+E|0,r[S++]=T+i|0,r[S++]=F+C|0,r[S++]=z+k|0}var Ot=at({core:kt,counterRight:!1,counterLen:4,allow128bitKeys:!1});var _t=new Uint8Array(16),xt=(e,t)=>{e.update(t);let n=t.length%16;n&&e.update(_t.subarray(n))},ut=(e,t,n,r,c)=>{let f=e(t,n,new Uint8Array(32)),s=ht.create(f);c&&xt(s,c),xt(s,r);let o=new Uint8Array(16),y=ft(o);Y(y,0,BigInt(c?c.length:0),!0),Y(y,8,BigInt(r.length),!0),s.update(o);let l=s.digest();return f.fill(0),l},jt=e=>(t,n,r)=>(M(t,32),M(n),{tagLength:16,encrypt:(f,s)=>{let o=f.length,y=o+16;s?M(s,y):s=new Uint8Array(y),e(t,n,f,s,1);let l=ut(e,t,n,s.subarray(0,-16),r);return s.set(l,o),s},decrypt:(f,s)=>{let o=f.length,y=o-16;if(o<16)throw new Error("encrypted data must be at least 16 bytes");s?M(s,y):s=new Uint8Array(y);let l=f.subarray(0,-16),u=f.subarray(-16),d=ut(e,t,n,l,r);if(!it(u,d))throw new Error("invalid tag");return e(t,n,l,s,1),s}}),rt=jt(Ot);var It={Aes128Gcm:1,Aes256Gcm:2,Chacha20Poly1305:3,ExportOnly:65535},pt=It;var nt=class{constructor(t){Object.defineProperty(this,"_key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._key=new Uint8Array(t)}async seal(t,n,r){return await this._seal(t,n,r)}async open(t,n,r){return await this._open(t,n,r)}_seal(t,n,r){return new Promise(c=>{let f=rt(this._key,new Uint8Array(t),new Uint8Array(r)).encrypt(new Uint8Array(n));c(f.buffer)})}_open(t,n,r){return new Promise(c=>{let f=rt(this._key,new Uint8Array(t),new Uint8Array(r)).decrypt(new Uint8Array(n));c(f.buffer)})}},ot=class{constructor(){Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:pt.Chacha20Poly1305}),Object.defineProperty(this,"keySize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"nonceSize",{enumerable:!0,configurable:!0,writable:!0,value:12}),Object.defineProperty(this,"tagSize",{enumerable:!0,configurable:!0,writable:!0,value:16})}createEncryptionContext(t){return new nt(t)}};export{ot as Chacha20Poly1305};
/*! Bundled license information:

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)
*/
