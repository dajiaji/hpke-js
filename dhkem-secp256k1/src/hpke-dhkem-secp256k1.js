var sr=Object.defineProperty;var cr=(r,t)=>{for(var e in t)sr(r,e,{get:t[e],enumerable:!0})};var ar={NotAssigned:0,DhkemP256HkdfSha256:16,DhkemP384HkdfSha384:17,DhkemP521HkdfSha512:18,DhkemSecp256k1HkdfSha256:19,DhkemX25519HkdfSha256:32,DhkemX448HkdfSha512:33,HybridkemX25519Kyber768:48},ne=ar,fr={HkdfSha256:1,HkdfSha384:2,HkdfSha512:3},ie=fr;function Ue(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`Wrong positive integer: ${r}`)}function oe(r,...t){if(!(r instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(r.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${r.length}`)}function Pe(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Ue(r.outputLen),Ue(r.blockLen)}function xt(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function Ke(r,t){oe(r);let e=t.outputLen;if(r.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}var ur=r=>r instanceof Uint8Array;var Ot=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),$=(r,t)=>r<<32-t|r>>>t,lr=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!lr)throw new Error("Non little-endian hardware is not supported");function hr(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function It(r){if(typeof r=="string"&&(r=hr(r)),!ur(r))throw new Error(`expected Uint8Array, got ${typeof r}`);return r}var mt=class{clone(){return this._cloneInto()}},dn={}.toString;function Oe(r){let t=n=>r().update(It(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}var Ht=class extends mt{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,Pe(t);let n=It(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,o=new Uint8Array(i);o.set(n.length>i?t.create().update(n).digest():n);for(let c=0;c<o.length;c++)o[c]^=54;this.iHash.update(o),this.oHash=t.create();for(let c=0;c<o.length;c++)o[c]^=106;this.oHash.update(o),o.fill(0)}update(t){return xt(this),this.iHash.update(t),this}digestInto(t){xt(this),oe(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:e,iHash:n,finished:i,destroyed:o,blockLen:c,outputLen:s}=this;return t=t,t.finished=i,t.destroyed=o,t.blockLen=c,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},se=(r,t,e)=>new Ht(r,t).update(e).digest();se.create=(r,t)=>new Ht(r,t);function dr(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let i=BigInt(32),o=BigInt(4294967295),c=Number(e>>i&o),s=Number(e&o),a=n?4:0,f=n?0:4;r.setUint32(t+a,c,n),r.setUint32(t+f,s,n)}var Tt=class extends mt{constructor(t,e,n,i){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Ot(this.buffer)}update(t){xt(this);let{view:e,buffer:n,blockLen:i}=this;t=It(t);let o=t.length;for(let c=0;c<o;){let s=Math.min(i-this.pos,o-c);if(s===i){let a=Ot(t);for(;i<=o-c;c+=i)this.process(a,c);continue}n.set(t.subarray(c,c+s),this.pos),this.pos+=s,c+=s,this.pos===i&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){xt(this),Ke(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:i,isLE:o}=this,{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>i-c&&(this.process(n,0),c=0);for(let u=c;u<i;u++)e[u]=0;dr(n,i-8,BigInt(this.length*8),o),this.process(n,0);let s=Ot(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=a/4,d=this.get();if(f>d.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)s.setUint32(4*u,d[u],o)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:i,finished:o,destroyed:c,pos:s}=this;return t.length=i,t.pos=s,t.finished=o,t.destroyed=c,i%e&&t.buffer.set(n),t}};var pr=(r,t,e)=>r&t^~r&e,yr=(r,t,e)=>r&t^r&e^t&e,br=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),it=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ot=new Uint32Array(64),ce=class extends Tt{constructor(){super(64,32,8,!1),this.A=it[0]|0,this.B=it[1]|0,this.C=it[2]|0,this.D=it[3]|0,this.E=it[4]|0,this.F=it[5]|0,this.G=it[6]|0,this.H=it[7]|0}get(){let{A:t,B:e,C:n,D:i,E:o,F:c,G:s,H:a}=this;return[t,e,n,i,o,c,s,a]}set(t,e,n,i,o,c,s,a){this.A=t|0,this.B=e|0,this.C=n|0,this.D=i|0,this.E=o|0,this.F=c|0,this.G=s|0,this.H=a|0}process(t,e){for(let u=0;u<16;u++,e+=4)ot[u]=t.getUint32(e,!1);for(let u=16;u<64;u++){let w=ot[u-15],B=ot[u-2],g=$(w,7)^$(w,18)^w>>>3,l=$(B,17)^$(B,19)^B>>>10;ot[u]=l+ot[u-7]+g+ot[u-16]|0}let{A:n,B:i,C:o,D:c,E:s,F:a,G:f,H:d}=this;for(let u=0;u<64;u++){let w=$(s,6)^$(s,11)^$(s,25),B=d+w+pr(s,a,f)+br[u]+ot[u]|0,l=($(n,2)^$(n,13)^$(n,22))+yr(n,i,o)|0;d=f,f=a,a=s,s=c+B|0,c=o,o=i,i=n,n=B+l|0}n=n+this.A|0,i=i+this.B|0,o=o+this.C|0,c=c+this.D|0,s=s+this.E|0,a=a+this.F|0,f=f+this.G|0,d=d+this.H|0,this.set(n,i,o,c,s,a,f,d)}roundClean(){ot.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var He=Oe(()=>new ce);var wr={},Te=gr(globalThis,wr);function gr(r,t){return new Proxy(r,{get(e,n,i){return n in t?t[n]:r[n]},set(e,n,i){return n in t&&delete t[n],r[n]=i,!0},deleteProperty(e,n){let i=!1;return n in t&&(delete t[n],i=!0),n in r&&(delete r[n],i=!0),i},ownKeys(e){let n=Reflect.ownKeys(r),i=Reflect.ownKeys(t),o=new Set(i);return[...n.filter(c=>!o.has(c)),...i]},defineProperty(e,n,i){return n in t&&delete t[n],Reflect.defineProperty(r,n,i),!0},getOwnPropertyDescriptor(e,n){return n in t?Reflect.getOwnPropertyDescriptor(t,n):Reflect.getOwnPropertyDescriptor(r,n)},has(e,n){return n in t||n in r}})}var ae=class extends Error{constructor(t){let e;t instanceof Error?e=t.message:typeof t=="string"?e=t:e="",super(e),this.name=this.constructor.name}},Y=class extends ae{},Et=class extends Y{};var vt=class extends Y{},ut=class extends Y{},Nt=class extends Y{},qt=class extends Y{};var Rt=class extends Y{},Bt=class extends Y{};async function mr(){if(Te!==void 0&&globalThis.crypto!==void 0)return globalThis.crypto.subtle;try{let{webcrypto:r}=await import("crypto");return r.subtle}catch(r){throw new Bt(r)}}var Ct=class{constructor(){Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}async _setup(){this._api===void 0&&(this._api=await mr())}};var W=new Uint8Array(0);var Ne=new Uint8Array([72,80,75,69,45,118,49]),fe=class extends Ct{constructor(){super(),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:ie.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_suiteId",{enumerable:!0,configurable:!0,writable:!0,value:W}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}init(t){this._suiteId=t}buildLabeledIkm(t,e){this._checkInit();let n=new Uint8Array(7+this._suiteId.byteLength+t.byteLength+e.byteLength);return n.set(Ne,0),n.set(this._suiteId,7),n.set(t,7+this._suiteId.byteLength),n.set(e,7+this._suiteId.byteLength+t.byteLength),n}buildLabeledInfo(t,e,n){this._checkInit();let i=new Uint8Array(9+this._suiteId.byteLength+t.byteLength+e.byteLength);return i.set(new Uint8Array([0,n]),0),i.set(Ne,2),i.set(this._suiteId,9),i.set(t,9+this._suiteId.byteLength),i.set(e,9+this._suiteId.byteLength+t.byteLength),i}async extract(t,e){if(await this._setup(),t.byteLength===0&&(t=new ArrayBuffer(this.hashSize)),t.byteLength!==this.hashSize)throw new Et("The salt length must be the same as the hashSize");let n=await this._api.importKey("raw",t,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,e)}async expand(t,e,n){await this._setup();let i=await this._api.importKey("raw",t,this.algHash,!1,["sign"]),o=new ArrayBuffer(n),c=new Uint8Array(o),s=W,a=new Uint8Array(e),f=new Uint8Array(1);if(n>255*this.hashSize)throw new Error("Entropy limit reached");let d=new Uint8Array(this.hashSize+a.length+1);for(let u=1,w=0;w<c.length;u++)f[0]=u,d.set(s,0),d.set(a,s.length),d.set(f,s.length+a.length),s=new Uint8Array(await this._api.sign("HMAC",i,d.slice(0,s.length+a.length+1))),c.length-w>=s.length?(c.set(s,w),w+=s.length):(c.set(s.slice(0,c.length-w),w),w+=c.length-w);return o}async extractAndExpand(t,e,n,i){await this._setup();let o=await this._api.importKey("raw",e,"HKDF",!1,["deriveBits"]);return await this._api.deriveBits({name:"HKDF",hash:this.algHash.hash,salt:t,info:n},o,i*8)}async labeledExtract(t,e,n){return await this.extract(t,this.buildLabeledIkm(e,n))}async labeledExpand(t,e,n,i){return await this.expand(t,this.buildLabeledInfo(e,n,i),i)}_checkInit(){if(this._suiteId===W)throw new Error("Not initialized. Call init()")}},zt=class extends fe{constructor(){super(...arguments),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:ie.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}};var Dt=class extends zt{async extract(t,e){if(await this._setup(),t.byteLength===0&&(t=new ArrayBuffer(this.hashSize)),t.byteLength!==this.hashSize)return se(He,new Uint8Array(t),new Uint8Array(e));let n=await this._api.importKey("raw",t,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,e)}};var qe=new Uint8Array([75,69,77,0,0]);var At=r=>typeof r=="object"&&r!==null&&typeof r.privateKey=="object"&&typeof r.publicKey=="object";function Re(r,t){if(t<=0)throw new Error("i2Osp: too small size");if(r>=256**t)throw new Error("i2Osp: too large integer");let e=new Uint8Array(t);for(let n=0;n<t&&r;n++)e[t-(n+1)]=r%256,r=r>>8;return e}function Lt(r,t){let e=new Uint8Array(r.length+t.length);return e.set(r,0),e.set(t,r.length),e}var vr=new Uint8Array([101,97,101,95,112,114,107]),Br=new Uint8Array([115,104,97,114,101,100,95,115,101,99,114,101,116]);function Ar(r,t,e){let n=new Uint8Array(r.length+t.length+e.length);return n.set(r,0),n.set(t,r.length),n.set(e,r.length+t.length),n}var jt=class{constructor(t,e,n){Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_prim",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.id=t,this._prim=e,this._kdf=n;let i=new Uint8Array(qe);i.set(Re(this.id,2),3),this._kdf.init(i)}async serializePublicKey(t){return await this._prim.serializePublicKey(t)}async deserializePublicKey(t){return await this._prim.deserializePublicKey(t)}async serializePrivateKey(t){return await this._prim.serializePrivateKey(t)}async deserializePrivateKey(t){return await this._prim.deserializePrivateKey(t)}async importKey(t,e,n=!0){return await this._prim.importKey(t,e,n)}async generateKeyPair(){return await this._prim.generateKeyPair()}async deriveKeyPair(t){if(t.byteLength>8192)throw new Et("Too long ikm");return await this._prim.deriveKeyPair(t)}async encap(t){let e;t.ekm===void 0?e=await this.generateKeyPair():At(t.ekm)?e=t.ekm:e=await this.deriveKeyPair(t.ekm);let n=await this._prim.serializePublicKey(e.publicKey),i=await this._prim.serializePublicKey(t.recipientPublicKey);try{let o;if(t.senderKey===void 0)o=new Uint8Array(await this._prim.dh(e.privateKey,t.recipientPublicKey));else{let a=At(t.senderKey)?t.senderKey.privateKey:t.senderKey,f=new Uint8Array(await this._prim.dh(e.privateKey,t.recipientPublicKey)),d=new Uint8Array(await this._prim.dh(a,t.recipientPublicKey));o=Lt(f,d)}let c;if(t.senderKey===void 0)c=Lt(new Uint8Array(n),new Uint8Array(i));else{let a=At(t.senderKey)?t.senderKey.publicKey:await this._prim.derivePublicKey(t.senderKey),f=await this._prim.serializePublicKey(a);c=Ar(new Uint8Array(n),new Uint8Array(i),new Uint8Array(f))}let s=await this._generateSharedSecret(o,c);return{enc:n,sharedSecret:s}}catch(o){throw new Nt(o)}}async decap(t){let e=await this._prim.deserializePublicKey(t.enc),n=At(t.recipientKey)?t.recipientKey.privateKey:t.recipientKey,i=At(t.recipientKey)?t.recipientKey.publicKey:await this._prim.derivePublicKey(t.recipientKey),o=await this._prim.serializePublicKey(i);try{let c;if(t.senderPublicKey===void 0)c=new Uint8Array(await this._prim.dh(n,e));else{let a=new Uint8Array(await this._prim.dh(n,e)),f=new Uint8Array(await this._prim.dh(n,t.senderPublicKey));c=Lt(a,f)}let s;if(t.senderPublicKey===void 0)s=Lt(new Uint8Array(t.enc),new Uint8Array(o));else{let a=await this._prim.serializePublicKey(t.senderPublicKey);s=new Uint8Array(t.enc.byteLength+o.byteLength+a.byteLength),s.set(new Uint8Array(t.enc),0),s.set(new Uint8Array(o),t.enc.byteLength),s.set(new Uint8Array(a),t.enc.byteLength+o.byteLength)}return await this._generateSharedSecret(c,s)}catch(c){throw new qt(c)}}async _generateSharedSecret(t,e){let n=this._kdf.buildLabeledIkm(vr,t),i=this._kdf.buildLabeledInfo(Br,e,this.secretSize);return await this._kdf.extractAndExpand(W,n,i,this.secretSize)}};function ue(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`Wrong positive integer: ${r}`)}function _r(r){if(typeof r!="boolean")throw new Error(`Expected boolean, not ${r}`)}function Ce(r,...t){if(!(r instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(r.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${r.length}`)}function Sr(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ue(r.outputLen),ue(r.blockLen)}function Ir(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function Lr(r,t){Ce(r);let e=t.outputLen;if(r.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}var kr={number:ue,bool:_r,bytes:Ce,hash:Sr,exists:Ir,output:Lr},X=kr;var Vt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var ze=r=>r instanceof Uint8Array;var $t=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),M=(r,t)=>r<<32-t|r>>>t,Ur=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Ur)throw new Error("Non little-endian hardware is not supported");var Gn=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function Pr(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function kt(r){if(typeof r=="string"&&(r=Pr(r)),!ze(r))throw new Error(`expected Uint8Array, got ${typeof r}`);return r}function De(...r){let t=new Uint8Array(r.reduce((n,i)=>n+i.length,0)),e=0;return r.forEach(n=>{if(!ze(n))throw new Error("Uint8Array expected");t.set(n,e),e+=n.length}),t}var _t=class{clone(){return this._cloneInto()}};function le(r){let t=n=>r().update(kt(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function he(r=32){if(Vt&&typeof Vt.getRandomValues=="function")return Vt.getRandomValues(new Uint8Array(r));throw new Error("crypto.getRandomValues must be defined")}function Kr(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let i=BigInt(32),o=BigInt(4294967295),c=Number(e>>i&o),s=Number(e&o),a=n?4:0,f=n?0:4;r.setUint32(t+a,c,n),r.setUint32(t+f,s,n)}var Mt=class extends _t{constructor(t,e,n,i){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=$t(this.buffer)}update(t){X.exists(this);let{view:e,buffer:n,blockLen:i}=this;t=kt(t);let o=t.length;for(let c=0;c<o;){let s=Math.min(i-this.pos,o-c);if(s===i){let a=$t(t);for(;i<=o-c;c+=i)this.process(a,c);continue}n.set(t.subarray(c,c+s),this.pos),this.pos+=s,c+=s,this.pos===i&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){X.exists(this),X.output(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:i,isLE:o}=this,{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>i-c&&(this.process(n,0),c=0);for(let u=c;u<i;u++)e[u]=0;Kr(n,i-8,BigInt(this.length*8),o),this.process(n,0);let s=$t(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=a/4,d=this.get();if(f>d.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)s.setUint32(4*u,d[u],o)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:i,finished:o,destroyed:c,pos:s}=this;return t.length=i,t.pos=s,t.finished=o,t.destroyed=c,i%e&&t.buffer.set(n),t}};var Or=(r,t,e)=>r&t^~r&e,Hr=(r,t,e)=>r&t^r&e^t&e,Tr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),st=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ct=new Uint32Array(64),Zt=class extends Mt{constructor(){super(64,32,8,!1),this.A=st[0]|0,this.B=st[1]|0,this.C=st[2]|0,this.D=st[3]|0,this.E=st[4]|0,this.F=st[5]|0,this.G=st[6]|0,this.H=st[7]|0}get(){let{A:t,B:e,C:n,D:i,E:o,F:c,G:s,H:a}=this;return[t,e,n,i,o,c,s,a]}set(t,e,n,i,o,c,s,a){this.A=t|0,this.B=e|0,this.C=n|0,this.D=i|0,this.E=o|0,this.F=c|0,this.G=s|0,this.H=a|0}process(t,e){for(let u=0;u<16;u++,e+=4)ct[u]=t.getUint32(e,!1);for(let u=16;u<64;u++){let w=ct[u-15],B=ct[u-2],g=M(w,7)^M(w,18)^w>>>3,l=M(B,17)^M(B,19)^B>>>10;ct[u]=l+ct[u-7]+g+ct[u-16]|0}let{A:n,B:i,C:o,D:c,E:s,F:a,G:f,H:d}=this;for(let u=0;u<64;u++){let w=M(s,6)^M(s,11)^M(s,25),B=d+w+Or(s,a,f)+Tr[u]+ct[u]|0,l=(M(n,2)^M(n,13)^M(n,22))+Hr(n,i,o)|0;d=f,f=a,a=s,s=c+B|0,c=o,o=i,i=n,n=B+l|0}n=n+this.A|0,i=i+this.B|0,o=o+this.C|0,c=c+this.D|0,s=s+this.E|0,a=a+this.F|0,f=f+this.G|0,d=d+this.H|0,this.set(n,i,o,c,s,a,f,d)}roundClean(){ct.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}},de=class extends Zt{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}},je=le(()=>new Zt),ti=le(()=>new de);var ge={};cr(ge,{bitGet:()=>Dr,bitLen:()=>zr,bitMask:()=>Ut,bitSet:()=>jr,bytesToHex:()=>lt,bytesToNumberBE:()=>Z,bytesToNumberLE:()=>Wt,concatBytes:()=>at,createHmacDrbg:()=>we,ensureBytes:()=>N,equalBytes:()=>Cr,hexToBytes:()=>ht,hexToNumber:()=>ye,numberToBytesBE:()=>Q,numberToBytesLE:()=>be,numberToHexUnpadded:()=>Me,numberToVarBytesBE:()=>Rr,utf8ToBytes:()=>Ze,validateObject:()=>J});var $e=BigInt(0),Gt=BigInt(1),Nr=BigInt(2),Yt=r=>r instanceof Uint8Array,qr=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function lt(r){if(!Yt(r))throw new Error("Uint8Array expected");let t="";for(let e=0;e<r.length;e++)t+=qr[r[e]];return t}function Me(r){let t=r.toString(16);return t.length&1?`0${t}`:t}function ye(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}function ht(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);let e=new Uint8Array(t/2);for(let n=0;n<e.length;n++){let i=n*2,o=r.slice(i,i+2),c=Number.parseInt(o,16);if(Number.isNaN(c)||c<0)throw new Error("Invalid byte sequence");e[n]=c}return e}function Z(r){return ye(lt(r))}function Wt(r){if(!Yt(r))throw new Error("Uint8Array expected");return ye(lt(Uint8Array.from(r).reverse()))}function Q(r,t){return ht(r.toString(16).padStart(t*2,"0"))}function be(r,t){return Q(r,t).reverse()}function Rr(r){return ht(Me(r))}function N(r,t,e){let n;if(typeof t=="string")try{n=ht(t)}catch(o){throw new Error(`${r} must be valid hex string, got "${t}". Cause: ${o}`)}else if(Yt(t))n=Uint8Array.from(t);else throw new Error(`${r} must be hex string or Uint8Array`);let i=n.length;if(typeof e=="number"&&i!==e)throw new Error(`${r} expected ${e} bytes, got ${i}`);return n}function at(...r){let t=new Uint8Array(r.reduce((n,i)=>n+i.length,0)),e=0;return r.forEach(n=>{if(!Yt(n))throw new Error("Uint8Array expected");t.set(n,e),e+=n.length}),t}function Cr(r,t){if(r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}function Ze(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function zr(r){let t;for(t=0;r>$e;r>>=Gt,t+=1);return t}function Dr(r,t){return r>>BigInt(t)&Gt}var jr=(r,t,e)=>r|(e?Gt:$e)<<BigInt(t),Ut=r=>(Nr<<BigInt(r-1))-Gt,pe=r=>new Uint8Array(r),Ve=r=>Uint8Array.from(r);function we(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=pe(r),i=pe(r),o=0,c=()=>{n.fill(1),i.fill(0),o=0},s=(...u)=>e(i,n,...u),a=(u=pe())=>{i=s(Ve([0]),u),n=s(),u.length!==0&&(i=s(Ve([1]),u),n=s())},f=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let u=0,w=[];for(;u<t;){n=s();let B=n.slice();w.push(B),u+=n.length}return at(...w)};return(u,w)=>{c(),a(u);let B;for(;!(B=w(f()));)a();return c(),B}}var Vr={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function J(r,t,e={}){let n=(i,o,c)=>{let s=Vr[o];if(typeof s!="function")throw new Error(`Invalid validator "${o}", expected function`);let a=r[i];if(!(c&&a===void 0)&&!s(a,r))throw new Error(`Invalid param ${String(i)}=${a} (${typeof a}), expected ${o}`)};for(let[i,o]of Object.entries(t))n(i,o,!1);for(let[i,o]of Object.entries(e))n(i,o,!0);return r}var O=BigInt(0),K=BigInt(1),dt=BigInt(2),$r=BigInt(3),xe=BigInt(4),Ge=BigInt(5),Ye=BigInt(8),Mr=BigInt(9),Zr=BigInt(16);function T(r,t){let e=r%t;return e>=O?e:t+e}function Gr(r,t,e){if(e<=O||t<O)throw new Error("Expected power/modulo > 0");if(e===K)return O;let n=K;for(;t>O;)t&K&&(n=n*r%e),r=r*r%e,t>>=K;return n}function D(r,t,e){let n=r;for(;t-- >O;)n*=n,n%=e;return n}function Xt(r,t){if(r===O||t<=O)throw new Error(`invert: expected positive integers, got n=${r} mod=${t}`);let e=T(r,t),n=t,i=O,o=K,c=K,s=O;for(;e!==O;){let f=n/e,d=n%e,u=i-c*f,w=o-s*f;n=e,e=d,i=c,o=s,c=u,s=w}if(n!==K)throw new Error("invert: does not exist");return T(i,t)}function Yr(r){let t=(r-K)/dt,e,n,i;for(e=r-K,n=0;e%dt===O;e/=dt,n++);for(i=dt;i<r&&Gr(i,t,r)!==r-K;i++);if(n===1){let c=(r+K)/xe;return function(a,f){let d=a.pow(f,c);if(!a.eql(a.sqr(d),f))throw new Error("Cannot find square root");return d}}let o=(e+K)/dt;return function(s,a){if(s.pow(a,t)===s.neg(s.ONE))throw new Error("Cannot find square root");let f=n,d=s.pow(s.mul(s.ONE,i),e),u=s.pow(a,o),w=s.pow(a,e);for(;!s.eql(w,s.ONE);){if(s.eql(w,s.ZERO))return s.ZERO;let B=1;for(let l=s.sqr(w);B<f&&!s.eql(l,s.ONE);B++)l=s.sqr(l);let g=s.pow(d,K<<BigInt(f-B-1));d=s.sqr(g),u=s.mul(u,g),w=s.mul(w,d),f=B}return u}}function Wr(r){if(r%xe===$r){let t=(r+K)/xe;return function(n,i){let o=n.pow(i,t);if(!n.eql(n.sqr(o),i))throw new Error("Cannot find square root");return o}}if(r%Ye===Ge){let t=(r-Ge)/Ye;return function(n,i){let o=n.mul(i,dt),c=n.pow(o,t),s=n.mul(i,c),a=n.mul(n.mul(s,dt),c),f=n.mul(s,n.sub(a,n.ONE));if(!n.eql(n.sqr(f),i))throw new Error("Cannot find square root");return f}}return r%Zr,Yr(r)}var Xr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function me(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Xr.reduce((n,i)=>(n[i]="function",n),t);return J(r,e)}function Qr(r,t,e){if(e<O)throw new Error("Expected power > 0");if(e===O)return r.ONE;if(e===K)return t;let n=r.ONE,i=t;for(;e>O;)e&K&&(n=r.mul(n,i)),i=r.sqr(i),e>>=K;return n}function Jr(r,t){let e=new Array(t.length),n=t.reduce((o,c,s)=>r.is0(c)?o:(e[s]=o,r.mul(o,c)),r.ONE),i=r.inv(n);return t.reduceRight((o,c,s)=>r.is0(c)?o:(e[s]=r.mul(o,e[s]),r.mul(o,c)),i),e}function Qt(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function We(r,t,e=!1,n={}){if(r<=O)throw new Error(`Expected Fp ORDER > 0, got ${r}`);let{nBitLength:i,nByteLength:o}=Qt(r,t);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");let c=Wr(r),s=Object.freeze({ORDER:r,BITS:i,BYTES:o,MASK:Ut(i),ZERO:O,ONE:K,create:a=>T(a,r),isValid:a=>{if(typeof a!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof a}`);return O<=a&&a<r},is0:a=>a===O,isOdd:a=>(a&K)===K,neg:a=>T(-a,r),eql:(a,f)=>a===f,sqr:a=>T(a*a,r),add:(a,f)=>T(a+f,r),sub:(a,f)=>T(a-f,r),mul:(a,f)=>T(a*f,r),pow:(a,f)=>Qr(s,a,f),div:(a,f)=>T(a*Xt(f,r),r),sqrN:a=>a*a,addN:(a,f)=>a+f,subN:(a,f)=>a-f,mulN:(a,f)=>a*f,inv:a=>Xt(a,r),sqrt:n.sqrt||(a=>c(s,a)),invertBatch:a=>Jr(s,a),cmov:(a,f,d)=>d?f:a,toBytes:a=>e?be(a,o):Q(a,o),fromBytes:a=>{if(a.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${a.length}`);return e?Wt(a):Z(a)}});return Object.freeze(s)}function Xe(r,t,e=!1){r=N("privateHash",r);let n=r.length,i=Qt(t).nByteLength+8;if(i<24||n<i||n>1024)throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${n}`);let o=e?Wt(r):Z(r);return T(o,t-K)+K}var tn=BigInt(0),Ee=BigInt(1);function Qe(r,t){let e=(i,o)=>{let c=o.negate();return i?c:o},n=i=>{let o=Math.ceil(t/i)+1,c=2**(i-1);return{windows:o,windowSize:c}};return{constTimeNegate:e,unsafeLadder(i,o){let c=r.ZERO,s=i;for(;o>tn;)o&Ee&&(c=c.add(s)),s=s.double(),o>>=Ee;return c},precomputeWindow(i,o){let{windows:c,windowSize:s}=n(o),a=[],f=i,d=f;for(let u=0;u<c;u++){d=f,a.push(d);for(let w=1;w<s;w++)d=d.add(f),a.push(d);f=d.double()}return a},wNAF(i,o,c){let{windows:s,windowSize:a}=n(i),f=r.ZERO,d=r.BASE,u=BigInt(2**i-1),w=2**i,B=BigInt(i);for(let g=0;g<s;g++){let l=g*a,p=Number(c&u);c>>=B,p>a&&(p-=w,c+=Ee);let b=l,m=l+Math.abs(p)-1,v=g%2!==0,I=p<0;p===0?d=d.add(e(v,o[b])):f=f.add(e(I,o[m]))}return{p:f,f:d}},wNAFCached(i,o,c,s){let a=i._WINDOW_SIZE||1,f=o.get(i);return f||(f=this.precomputeWindow(i,a),a!==1&&o.set(i,s(f))),this.wNAF(a,f,c)}}}function ve(r){return me(r.Fp),J(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Qt(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}function en(r){let t=ve(r);J(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:e,Fp:n,a:i}=t;if(e){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}var{bytesToNumberBE:rn,hexToBytes:nn}=ge,pt={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(r){let{Err:t}=pt;if(r.length<2||r[0]!==2)throw new t("Invalid signature integer tag");let e=r[1],n=r.subarray(2,e+2);if(!e||n.length!==e)throw new t("Invalid signature integer: wrong length");if(n[0]&128)throw new t("Invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:rn(n),l:r.subarray(e+2)}},toSig(r){let{Err:t}=pt,e=typeof r=="string"?nn(r):r;if(!(e instanceof Uint8Array))throw new Error("ui8a expected");let n=e.length;if(n<2||e[0]!=48)throw new t("Invalid signature tag");if(e[1]!==n-2)throw new t("Invalid signature: incorrect length");let{d:i,l:o}=pt._parseInt(e.subarray(2)),{d:c,l:s}=pt._parseInt(o);if(s.length)throw new t("Invalid signature: left bytes after parsing");return{r:i,s:c}},hexFromSig(r){let t=f=>Number.parseInt(f[0],16)&8?"00"+f:f,e=f=>{let d=f.toString(16);return d.length&1?`0${d}`:d},n=t(e(r.s)),i=t(e(r.r)),o=n.length/2,c=i.length/2,s=e(o),a=e(c);return`30${e(c+o+4)}02${a}${i}02${s}${n}`}},F=BigInt(0),V=BigInt(1),fi=BigInt(2),Je=BigInt(3),ui=BigInt(4);function on(r){let t=en(r),{Fp:e}=t,n=t.toBytes||((g,l,p)=>{let b=l.toAffine();return at(Uint8Array.from([4]),e.toBytes(b.x),e.toBytes(b.y))}),i=t.fromBytes||(g=>{let l=g.subarray(1),p=e.fromBytes(l.subarray(0,e.BYTES)),b=e.fromBytes(l.subarray(e.BYTES,2*e.BYTES));return{x:p,y:b}});function o(g){let{a:l,b:p}=t,b=e.sqr(g),m=e.mul(b,g);return e.add(e.add(m,e.mul(g,l)),p)}if(!e.eql(e.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function c(g){return typeof g=="bigint"&&F<g&&g<t.n}function s(g){if(!c(g))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function a(g){let{allowedPrivateKeyLengths:l,nByteLength:p,wrapPrivateKey:b,n:m}=t;if(l&&typeof g!="bigint"){if(g instanceof Uint8Array&&(g=lt(g)),typeof g!="string"||!l.includes(g.length))throw new Error("Invalid key");g=g.padStart(p*2,"0")}let v;try{v=typeof g=="bigint"?g:Z(N("private key",g,p))}catch{throw new Error(`private key must be ${p} bytes, hex or bigint, not ${typeof g}`)}return b&&(v=T(v,m)),s(v),v}let f=new Map;function d(g){if(!(g instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(l,p,b){if(this.px=l,this.py=p,this.pz=b,l==null||!e.isValid(l))throw new Error("x required");if(p==null||!e.isValid(p))throw new Error("y required");if(b==null||!e.isValid(b))throw new Error("z required")}static fromAffine(l){let{x:p,y:b}=l||{};if(!l||!e.isValid(p)||!e.isValid(b))throw new Error("invalid affine point");if(l instanceof u)throw new Error("projective point not allowed");let m=v=>e.eql(v,e.ZERO);return m(p)&&m(b)?u.ZERO:new u(p,b,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){let p=e.invertBatch(l.map(b=>b.pz));return l.map((b,m)=>b.toAffine(p[m])).map(u.fromAffine)}static fromHex(l){let p=u.fromAffine(i(N("pointHex",l)));return p.assertValidity(),p}static fromPrivateKey(l){return u.BASE.multiply(a(l))}_setWindowSize(l){this._WINDOW_SIZE=l,f.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint)return;throw new Error("bad point: ZERO")}let{x:l,y:p}=this.toAffine();if(!e.isValid(l)||!e.isValid(p))throw new Error("bad point: x or y not FE");let b=e.sqr(p),m=o(l);if(!e.eql(b,m))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){let{y:l}=this.toAffine();if(e.isOdd)return!e.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){d(l);let{px:p,py:b,pz:m}=this,{px:v,py:I,pz:S}=l,x=e.eql(e.mul(p,S),e.mul(v,m)),E=e.eql(e.mul(b,S),e.mul(I,m));return x&&E}negate(){return new u(this.px,e.neg(this.py),this.pz)}double(){let{a:l,b:p}=t,b=e.mul(p,Je),{px:m,py:v,pz:I}=this,S=e.ZERO,x=e.ZERO,E=e.ZERO,_=e.mul(m,m),j=e.mul(v,v),P=e.mul(I,I),L=e.mul(m,v);return L=e.add(L,L),E=e.mul(m,I),E=e.add(E,E),S=e.mul(l,E),x=e.mul(b,P),x=e.add(S,x),S=e.sub(j,x),x=e.add(j,x),x=e.mul(S,x),S=e.mul(L,S),E=e.mul(b,E),P=e.mul(l,P),L=e.sub(_,P),L=e.mul(l,L),L=e.add(L,E),E=e.add(_,_),_=e.add(E,_),_=e.add(_,P),_=e.mul(_,L),x=e.add(x,_),P=e.mul(v,I),P=e.add(P,P),_=e.mul(P,L),S=e.sub(S,_),E=e.mul(P,j),E=e.add(E,E),E=e.add(E,E),new u(S,x,E)}add(l){d(l);let{px:p,py:b,pz:m}=this,{px:v,py:I,pz:S}=l,x=e.ZERO,E=e.ZERO,_=e.ZERO,j=t.a,P=e.mul(t.b,Je),L=e.mul(p,v),q=e.mul(b,I),R=e.mul(m,S),tt=e.add(p,b),h=e.add(v,I);tt=e.mul(tt,h),h=e.add(L,q),tt=e.sub(tt,h),h=e.add(p,m);let y=e.add(v,S);return h=e.mul(h,y),y=e.add(L,R),h=e.sub(h,y),y=e.add(b,m),x=e.add(I,S),y=e.mul(y,x),x=e.add(q,R),y=e.sub(y,x),_=e.mul(j,h),x=e.mul(P,R),_=e.add(x,_),x=e.sub(q,_),_=e.add(q,_),E=e.mul(x,_),q=e.add(L,L),q=e.add(q,L),R=e.mul(j,R),h=e.mul(P,h),q=e.add(q,R),R=e.sub(L,R),R=e.mul(j,R),h=e.add(h,R),L=e.mul(q,h),E=e.add(E,L),L=e.mul(y,h),x=e.mul(tt,x),x=e.sub(x,L),L=e.mul(tt,q),_=e.mul(y,_),_=e.add(_,L),new u(x,E,_)}subtract(l){return this.add(l.negate())}is0(){return this.equals(u.ZERO)}wNAF(l){return B.wNAFCached(this,f,l,p=>{let b=e.invertBatch(p.map(m=>m.pz));return p.map((m,v)=>m.toAffine(b[v])).map(u.fromAffine)})}multiplyUnsafe(l){let p=u.ZERO;if(l===F)return p;if(s(l),l===V)return this;let{endo:b}=t;if(!b)return B.unsafeLadder(this,l);let{k1neg:m,k1:v,k2neg:I,k2:S}=b.splitScalar(l),x=p,E=p,_=this;for(;v>F||S>F;)v&V&&(x=x.add(_)),S&V&&(E=E.add(_)),_=_.double(),v>>=V,S>>=V;return m&&(x=x.negate()),I&&(E=E.negate()),E=new u(e.mul(E.px,b.beta),E.py,E.pz),x.add(E)}multiply(l){s(l);let p=l,b,m,{endo:v}=t;if(v){let{k1neg:I,k1:S,k2neg:x,k2:E}=v.splitScalar(p),{p:_,f:j}=this.wNAF(S),{p:P,f:L}=this.wNAF(E);_=B.constTimeNegate(I,_),P=B.constTimeNegate(x,P),P=new u(e.mul(P.px,v.beta),P.py,P.pz),b=_.add(P),m=j.add(L)}else{let{p:I,f:S}=this.wNAF(p);b=I,m=S}return u.normalizeZ([b,m])[0]}multiplyAndAddUnsafe(l,p,b){let m=u.BASE,v=(S,x)=>x===F||x===V||!S.equals(m)?S.multiplyUnsafe(x):S.multiply(x),I=v(this,p).add(v(l,b));return I.is0()?void 0:I}toAffine(l){let{px:p,py:b,pz:m}=this,v=this.is0();l==null&&(l=v?e.ONE:e.inv(m));let I=e.mul(p,l),S=e.mul(b,l),x=e.mul(m,l);if(v)return{x:e.ZERO,y:e.ZERO};if(!e.eql(x,e.ONE))throw new Error("invZ was invalid");return{x:I,y:S}}isTorsionFree(){let{h:l,isTorsionFree:p}=t;if(l===V)return!0;if(p)return p(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:l,clearCofactor:p}=t;return l===V?this:p?p(u,this):this.multiplyUnsafe(t.h)}toRawBytes(l=!0){return this.assertValidity(),n(u,this,l)}toHex(l=!0){return lt(this.toRawBytes(l))}}u.BASE=new u(t.Gx,t.Gy,e.ONE),u.ZERO=new u(e.ZERO,e.ONE,e.ZERO);let w=t.nBitLength,B=Qe(u,t.endo?Math.ceil(w/2):w);return{CURVE:t,ProjectivePoint:u,normPrivateKeyToScalar:a,weierstrassEquation:o,isWithinCurveOrder:c}}function sn(r){let t=ve(r);return J(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function Fe(r){let t=sn(r),{Fp:e,n}=t,i=e.BYTES+1,o=2*e.BYTES+1;function c(h){return F<h&&h<e.ORDER}function s(h){return T(h,n)}function a(h){return Xt(h,n)}let{ProjectivePoint:f,normPrivateKeyToScalar:d,weierstrassEquation:u,isWithinCurveOrder:w}=on({...t,toBytes(h,y,A){let U=y.toAffine(),k=e.toBytes(U.x),H=at;return A?H(Uint8Array.from([y.hasEvenY()?2:3]),k):H(Uint8Array.from([4]),k,e.toBytes(U.y))},fromBytes(h){let y=h.length,A=h[0],U=h.subarray(1);if(y===i&&(A===2||A===3)){let k=Z(U);if(!c(k))throw new Error("Point is not on curve");let H=u(k),C=e.sqrt(H),z=(C&V)===V;return(A&1)===1!==z&&(C=e.neg(C)),{x:k,y:C}}else if(y===o&&A===4){let k=e.fromBytes(U.subarray(0,e.BYTES)),H=e.fromBytes(U.subarray(e.BYTES,2*e.BYTES));return{x:k,y:H}}else throw new Error(`Point of length ${y} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}}),B=h=>lt(Q(h,t.nByteLength));function g(h){let y=n>>V;return h>y}function l(h){return g(h)?s(-h):h}let p=(h,y,A)=>Z(h.slice(y,A));class b{constructor(y,A,U){this.r=y,this.s=A,this.recovery=U,this.assertValidity()}static fromCompact(y){let A=t.nByteLength;return y=N("compactSignature",y,A*2),new b(p(y,0,A),p(y,A,2*A))}static fromDER(y){let{r:A,s:U}=pt.toSig(N("DER",y));return new b(A,U)}assertValidity(){if(!w(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!w(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(y){return new b(this.r,this.s,y)}recoverPublicKey(y){let{r:A,s:U,recovery:k}=this,H=E(N("msgHash",y));if(k==null||![0,1,2,3].includes(k))throw new Error("recovery id invalid");let C=k===2||k===3?A+t.n:A;if(C>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");let z=k&1?"03":"02",et=f.fromHex(z+B(C)),rt=a(C),bt=s(-H*rt),St=s(U*rt),nt=f.BASE.multiplyAndAddUnsafe(et,bt,St);if(!nt)throw new Error("point at infinify");return nt.assertValidity(),nt}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new b(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return ht(this.toDERHex())}toDERHex(){return pt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ht(this.toCompactHex())}toCompactHex(){return B(this.r)+B(this.s)}}let m={isValidPrivateKey(h){try{return d(h),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{let h=t.randomBytes(e.BYTES+8),y=Xe(h,n);return Q(y,t.nByteLength)},precompute(h=8,y=f.BASE){return y._setWindowSize(h),y.multiply(BigInt(3)),y}};function v(h,y=!0){return f.fromPrivateKey(h).toRawBytes(y)}function I(h){let y=h instanceof Uint8Array,A=typeof h=="string",U=(y||A)&&h.length;return y?U===i||U===o:A?U===2*i||U===2*o:h instanceof f}function S(h,y,A=!0){if(I(h))throw new Error("first arg must be private key");if(!I(y))throw new Error("second arg must be public key");return f.fromHex(y).multiply(d(h)).toRawBytes(A)}let x=t.bits2int||function(h){let y=Z(h),A=h.length*8-t.nBitLength;return A>0?y>>BigInt(A):y},E=t.bits2int_modN||function(h){return s(x(h))},_=Ut(t.nBitLength);function j(h){if(typeof h!="bigint")throw new Error("bigint expected");if(!(F<=h&&h<_))throw new Error(`bigint expected < 2^${t.nBitLength}`);return Q(h,t.nByteLength)}function P(h,y,A=L){if(["recovered","canonical"].some(ft=>ft in A))throw new Error("sign() legacy options not supported");let{hash:U,randomBytes:k}=t,{lowS:H,prehash:C,extraEntropy:z}=A;H==null&&(H=!0),h=N("msgHash",h),C&&(h=N("prehashed msgHash",U(h)));let et=E(h),rt=d(y),bt=[j(rt),j(et)];if(z!=null){let ft=z===!0?k(e.BYTES):z;bt.push(N("extraEntropy",ft,e.BYTES))}let St=at(...bt),nt=et;function re(ft){let wt=x(ft);if(!w(wt))return;let Ie=a(wt),G=f.BASE.multiply(wt).toAffine(),gt=s(G.x);if(gt===F)return;let Kt=s(Ie*s(nt+gt*rt));if(Kt===F)return;let Le=(G.x===gt?0:2)|Number(G.y&V),ke=Kt;return H&&g(Kt)&&(ke=l(Kt),Le^=1),new b(gt,ke,Le)}return{seed:St,k2sig:re}}let L={lowS:t.lowS,prehash:!1},q={lowS:t.lowS,prehash:!1};function R(h,y,A=L){let{seed:U,k2sig:k}=P(h,y,A),H=t;return we(H.hash.outputLen,H.nByteLength,H.hmac)(U,k)}f.BASE._setWindowSize(8);function tt(h,y,A,U=q){let k=h;if(y=N("msgHash",y),A=N("publicKey",A),"strict"in U)throw new Error("options.strict was renamed to lowS");let{lowS:H,prehash:C}=U,z,et;try{if(typeof k=="string"||k instanceof Uint8Array)try{z=b.fromDER(k)}catch(G){if(!(G instanceof pt.Err))throw G;z=b.fromCompact(k)}else if(typeof k=="object"&&typeof k.r=="bigint"&&typeof k.s=="bigint"){let{r:G,s:gt}=k;z=new b(G,gt)}else throw new Error("PARSE");et=f.fromHex(A)}catch(G){if(G.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(H&&z.hasHighS())return!1;C&&(y=t.hash(y));let{r:rt,s:bt}=z,St=E(y),nt=a(bt),re=s(St*nt),ft=s(rt*nt),wt=f.BASE.multiplyAndAddUnsafe(et,re,ft)?.toAffine();return wt?s(wt.x)===rt:!1}return{CURVE:t,getPublicKey:v,getSharedSecret:S,sign:R,verify:tt,ProjectivePoint:f,Signature:b,utils:m}}var Jt=class extends _t{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,X.hash(t);let n=kt(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,o=new Uint8Array(i);o.set(n.length>i?t.create().update(n).digest():n);for(let c=0;c<o.length;c++)o[c]^=54;this.iHash.update(o),this.oHash=t.create();for(let c=0;c<o.length;c++)o[c]^=106;this.oHash.update(o),o.fill(0)}update(t){return X.exists(this),this.iHash.update(t),this}digestInto(t){X.exists(this),X.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:e,iHash:n,finished:i,destroyed:o,blockLen:c,outputLen:s}=this;return t=t,t.finished=i,t.destroyed=o,t.blockLen=c,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},Be=(r,t,e)=>new Jt(r,t).update(e).digest();Be.create=(r,t)=>new Jt(r,t);function cn(r){return{hash:r,hmac:(t,...e)=>Be(r,t,De(...e)),randomBytes:he}}function tr(r,t){let e=n=>Fe({...r,...cn(n)});return Object.freeze({...e(t),create:e})}var nr=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),er=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),an=BigInt(1),Ae=BigInt(2),rr=(r,t)=>(r+t/Ae)/t;function fn(r){let t=nr,e=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),c=BigInt(23),s=BigInt(44),a=BigInt(88),f=r*r*r%t,d=f*f*r%t,u=D(d,e,t)*d%t,w=D(u,e,t)*d%t,B=D(w,Ae,t)*f%t,g=D(B,i,t)*B%t,l=D(g,o,t)*g%t,p=D(l,s,t)*l%t,b=D(p,a,t)*p%t,m=D(b,s,t)*l%t,v=D(m,e,t)*d%t,I=D(v,c,t)*g%t,S=D(I,n,t)*f%t,x=D(S,Ae,t);if(!_e.eql(_e.sqr(x),r))throw new Error("Cannot find square root");return x}var _e=We(nr,void 0,void 0,{sqrt:fn}),Pt=tr({a:BigInt(0),b:BigInt(7),Fp:_e,n:er,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{let t=er,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-an*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,c=BigInt("0x100000000000000000000000000000000"),s=rr(o*r,t),a=rr(-n*r,t),f=T(r-s*e-a*i,t),d=T(-s*n-a*o,t),u=f>c,w=d>c;if(u&&(f=t-f),w&&(d=t-d),f>c||d>c)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:u,k1:f,k2neg:w,k2:d}}}},je),Ki=BigInt(0);var Oi=Pt.ProjectivePoint;var Ft=["deriveBits"],ir=new Uint8Array([100,107,112,95,112,114,107]),or=new Uint8Array([115,107]);var yt=class{constructor(t,e,n,i=[]){Object.defineProperty(this,"key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extractable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"algorithm",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"usages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.key=e,this.type=n,this.algorithm={name:t},this.usages=i,n==="public"&&(this.usages=[])}};var te="ECDH",ee=class{constructor(t){Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=t,this._nPk=33,this._nSk=32}async serializePublicKey(t){try{return await this._serializePublicKey(t)}catch(e){throw new vt(e)}}async deserializePublicKey(t){try{return await this._importRawKey(t,!0)}catch(e){throw new ut(e)}}async serializePrivateKey(t){try{return await this._serializePrivateKey(t)}catch(e){throw new vt(e)}}async deserializePrivateKey(t){try{return await this._importRawKey(t,!1)}catch(e){throw new ut(e)}}async importKey(t,e,n){try{if(t!=="raw")throw new Error("Unsupported format");return await this._importRawKey(e,n)}catch(i){throw new ut(i)}}async generateKeyPair(){try{let t=Pt.utils.randomPrivateKey(),e=new yt(te,t,"private",Ft);return{publicKey:await this.derivePublicKey(e),privateKey:e}}catch(t){throw new Bt(t)}}async deriveKeyPair(t){try{let e=await this._hkdf.labeledExtract(W,ir,new Uint8Array(t)),n=await this._hkdf.labeledExpand(e,or,W,this._nSk),i=new yt(te,new Uint8Array(n),"private",Ft);return{privateKey:i,publicKey:await this.derivePublicKey(i)}}catch(e){throw new Rt(e)}}async derivePublicKey(t){try{return await this._derivePublicKey(t)}catch(e){throw new ut(e)}}async dh(t,e){try{return await this._dh(t,e)}catch(n){throw new vt(n)}}_serializePublicKey(t){return new Promise(e=>{e(t.key.buffer)})}_serializePrivateKey(t){return new Promise(e=>{e(t.key.buffer)})}_importRawKey(t,e){return new Promise((n,i)=>{e&&t.byteLength!==this._nPk&&i(new Error("Invalid length of the key")),!e&&t.byteLength!==this._nSk&&i(new Error("Invalid length of the key")),n(new yt(te,new Uint8Array(t),e?"public":"private",e?[]:Ft))})}_derivePublicKey(t){return new Promise((e,n)=>{try{let i=Pt.getPublicKey(t.key);e(new yt(te,i,"public"))}catch(i){n(i)}})}_dh(t,e){return new Promise((n,i)=>{try{n(Pt.getSharedSecret(t.key,e.key).buffer)}catch(o){i(o)}})}};var Se=class extends jt{constructor(){let t=new Dt;super(ne.DhkemSecp256k1HkdfSha256,new ee(t),t),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:ne.DhkemSecp256k1HkdfSha256}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:32})}};export{Se as DhkemSecp256k1HkdfSha256};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
