var Yt=Object.defineProperty;var Wt=(r,e)=>{for(var t in e)Yt(r,t,{get:e[t],enumerable:!0})};function Fe(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`Wrong positive integer: ${r}`)}function Xt(r){if(typeof r!="boolean")throw new Error(`Expected boolean, not ${r}`)}function At(r,...e){if(!(r instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(r.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${r.length}`)}function Qt(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Fe(r.outputLen),Fe(r.blockLen)}function Jt(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Ft(r,e){At(r);let t=e.outputLen;if(r.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var er={number:Fe,bool:Xt,bytes:At,hash:Qt,exists:Jt,output:Ft},G=er;var Pe=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var Bt=r=>r instanceof Uint8Array;var Ue=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),M=(r,e)=>r<<32-e|r>>>e,tr=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!tr)throw new Error("Non little-endian hardware is not supported");var Mr=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function rr(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function ge(r){if(typeof r=="string"&&(r=rr(r)),!Bt(r))throw new Error(`expected Uint8Array, got ${typeof r}`);return r}function vt(...r){let e=new Uint8Array(r.reduce((n,i)=>n+i.length,0)),t=0;return r.forEach(n=>{if(!Bt(n))throw new Error("Uint8Array expected");e.set(n,t),t+=n.length}),e}var pe=class{clone(){return this._cloneInto()}};function et(r){let e=n=>r().update(ge(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function tt(r=32){if(Pe&&typeof Pe.getRandomValues=="function")return Pe.getRandomValues(new Uint8Array(r));throw new Error("crypto.getRandomValues must be defined")}function nr(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);let i=BigInt(32),s=BigInt(4294967295),a=Number(t>>i&s),o=Number(t&s),c=n?4:0,f=n?0:4;r.setUint32(e+c,a,n),r.setUint32(e+f,o,n)}var Le=class extends pe{constructor(e,t,n,i){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Ue(this.buffer)}update(e){G.exists(this);let{view:t,buffer:n,blockLen:i}=this;e=ge(e);let s=e.length;for(let a=0;a<s;){let o=Math.min(i-this.pos,s-a);if(o===i){let c=Ue(e);for(;i<=s-a;a+=i)this.process(c,a);continue}n.set(e.subarray(a,a+o),this.pos),this.pos+=o,a+=o,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){G.exists(this),G.output(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:i,isLE:s}=this,{pos:a}=this;t[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>i-a&&(this.process(n,0),a=0);for(let l=a;l<i;l++)t[l]=0;nr(n,i-8,BigInt(this.length*8),s),this.process(n,0);let o=Ue(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=c/4,p=this.get();if(f>p.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<f;l++)o.setUint32(4*l,p[l],s)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:i,finished:s,destroyed:a,pos:o}=this;return e.length=i,e.pos=o,e.finished=s,e.destroyed=a,i%t&&e.buffer.set(n),e}};var ir=(r,e,t)=>r&e^~r&t,or=(r,e,t)=>r&e^r&t^e&t,sr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ne=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ie=new Uint32Array(64),Ke=class extends Le{constructor(){super(64,32,8,!1),this.A=ne[0]|0,this.B=ne[1]|0,this.C=ne[2]|0,this.D=ne[3]|0,this.E=ne[4]|0,this.F=ne[5]|0,this.G=ne[6]|0,this.H=ne[7]|0}get(){let{A:e,B:t,C:n,D:i,E:s,F:a,G:o,H:c}=this;return[e,t,n,i,s,a,o,c]}set(e,t,n,i,s,a,o,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=s|0,this.F=a|0,this.G=o|0,this.H=c|0}process(e,t){for(let l=0;l<16;l++,t+=4)ie[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){let g=ie[l-15],_=ie[l-2],w=M(g,7)^M(g,18)^g>>>3,u=M(_,17)^M(_,19)^_>>>10;ie[l]=u+ie[l-7]+w+ie[l-16]|0}let{A:n,B:i,C:s,D:a,E:o,F:c,G:f,H:p}=this;for(let l=0;l<64;l++){let g=M(o,6)^M(o,11)^M(o,25),_=p+g+ir(o,c,f)+sr[l]+ie[l]|0,u=(M(n,2)^M(n,13)^M(n,22))+or(n,i,s)|0;p=f,f=c,c=o,o=a+_|0,a=s,s=i,i=n,n=_+u|0}n=n+this.A|0,i=i+this.B|0,s=s+this.C|0,a=a+this.D|0,o=o+this.E|0,c=c+this.F|0,f=f+this.G|0,p=p+this.H|0,this.set(n,i,s,a,o,c,f,p)}roundClean(){ie.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}},rt=class extends Ke{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}},ke=et(()=>new Ke),Qr=et(()=>new rt);var ct={};Wt(ct,{bitGet:()=>dr,bitLen:()=>lr,bitMask:()=>me,bitSet:()=>hr,bytesToHex:()=>ae,bytesToNumberBE:()=>$,bytesToNumberLE:()=>He,concatBytes:()=>oe,createHmacDrbg:()=>st,ensureBytes:()=>N,equalBytes:()=>ur,hexToBytes:()=>fe,hexToNumber:()=>it,numberToBytesBE:()=>Y,numberToBytesLE:()=>ot,numberToHexUnpadded:()=>It,numberToVarBytesBE:()=>fr,utf8ToBytes:()=>Pt,validateObject:()=>W});var _t=BigInt(0),Oe=BigInt(1),cr=BigInt(2),Te=r=>r instanceof Uint8Array,ar=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function ae(r){if(!Te(r))throw new Error("Uint8Array expected");let e="";for(let t=0;t<r.length;t++)e+=ar[r[t]];return e}function It(r){let e=r.toString(16);return e.length&1?`0${e}`:e}function it(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}function fe(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let e=r.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);let t=new Uint8Array(e/2);for(let n=0;n<t.length;n++){let i=n*2,s=r.slice(i,i+2),a=Number.parseInt(s,16);if(Number.isNaN(a)||a<0)throw new Error("Invalid byte sequence");t[n]=a}return t}function $(r){return it(ae(r))}function He(r){if(!Te(r))throw new Error("Uint8Array expected");return it(ae(Uint8Array.from(r).reverse()))}function Y(r,e){return fe(r.toString(16).padStart(e*2,"0"))}function ot(r,e){return Y(r,e).reverse()}function fr(r){return fe(It(r))}function N(r,e,t){let n;if(typeof e=="string")try{n=fe(e)}catch(s){throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${s}`)}else if(Te(e))n=Uint8Array.from(e);else throw new Error(`${r} must be hex string or Uint8Array`);let i=n.length;if(typeof t=="number"&&i!==t)throw new Error(`${r} expected ${t} bytes, got ${i}`);return n}function oe(...r){let e=new Uint8Array(r.reduce((n,i)=>n+i.length,0)),t=0;return r.forEach(n=>{if(!Te(n))throw new Error("Uint8Array expected");e.set(n,t),t+=n.length}),e}function ur(r,e){if(r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function Pt(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function lr(r){let e;for(e=0;r>_t;r>>=Oe,e+=1);return e}function dr(r,e){return r>>BigInt(e)&Oe}var hr=(r,e,t)=>r|(t?Oe:_t)<<BigInt(e),me=r=>(cr<<BigInt(r-1))-Oe,nt=r=>new Uint8Array(r),St=r=>Uint8Array.from(r);function st(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=nt(r),i=nt(r),s=0,a=()=>{n.fill(1),i.fill(0),s=0},o=(...l)=>t(i,n,...l),c=(l=nt())=>{i=o(St([0]),l),n=o(),l.length!==0&&(i=o(St([1]),l),n=o())},f=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let l=0,g=[];for(;l<e;){n=o();let _=n.slice();g.push(_),l+=n.length}return oe(...g)};return(l,g)=>{a(),c(l);let _;for(;!(_=g(f()));)c();return a(),_}}var yr={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function W(r,e,t={}){let n=(i,s,a)=>{let o=yr[s];if(typeof o!="function")throw new Error(`Invalid validator "${s}", expected function`);let c=r[i];if(!(a&&c===void 0)&&!o(c,r))throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${s}`)};for(let[i,s]of Object.entries(e))n(i,s,!1);for(let[i,s]of Object.entries(t))n(i,s,!0);return r}var O=BigInt(0),k=BigInt(1),ue=BigInt(2),pr=BigInt(3),at=BigInt(4),Ut=BigInt(5),Lt=BigInt(8),br=BigInt(9),xr=BigInt(16);function H(r,e){let t=r%e;return t>=O?t:e+t}function wr(r,e,t){if(t<=O||e<O)throw new Error("Expected power/modulo > 0");if(t===k)return O;let n=k;for(;e>O;)e&k&&(n=n*r%t),r=r*r%t,e>>=k;return n}function D(r,e,t){let n=r;for(;e-- >O;)n*=n,n%=t;return n}function Ne(r,e){if(r===O||e<=O)throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);let t=H(r,e),n=e,i=O,s=k,a=k,o=O;for(;t!==O;){let f=n/t,p=n%t,l=i-a*f,g=s-o*f;n=t,t=p,i=a,s=o,a=l,o=g}if(n!==k)throw new Error("invert: does not exist");return H(i,e)}function gr(r){let e=(r-k)/ue,t,n,i;for(t=r-k,n=0;t%ue===O;t/=ue,n++);for(i=ue;i<r&&wr(i,e,r)!==r-k;i++);if(n===1){let a=(r+k)/at;return function(c,f){let p=c.pow(f,a);if(!c.eql(c.sqr(p),f))throw new Error("Cannot find square root");return p}}let s=(t+k)/ue;return function(o,c){if(o.pow(c,e)===o.neg(o.ONE))throw new Error("Cannot find square root");let f=n,p=o.pow(o.mul(o.ONE,i),t),l=o.pow(c,s),g=o.pow(c,t);for(;!o.eql(g,o.ONE);){if(o.eql(g,o.ZERO))return o.ZERO;let _=1;for(let u=o.sqr(g);_<f&&!o.eql(u,o.ONE);_++)u=o.sqr(u);let w=o.pow(p,k<<BigInt(f-_-1));p=o.sqr(w),l=o.mul(l,w),g=o.mul(g,p),f=_}return l}}function mr(r){if(r%at===pr){let e=(r+k)/at;return function(n,i){let s=n.pow(i,e);if(!n.eql(n.sqr(s),i))throw new Error("Cannot find square root");return s}}if(r%Lt===Ut){let e=(r-Ut)/Lt;return function(n,i){let s=n.mul(i,ue),a=n.pow(s,e),o=n.mul(i,a),c=n.mul(n.mul(o,ue),a),f=n.mul(o,n.sub(c,n.ONE));if(!n.eql(n.sqr(f),i))throw new Error("Cannot find square root");return f}}return r%xr,gr(r)}var Er=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ft(r){let e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Er.reduce((n,i)=>(n[i]="function",n),e);return W(r,t)}function Ar(r,e,t){if(t<O)throw new Error("Expected power > 0");if(t===O)return r.ONE;if(t===k)return e;let n=r.ONE,i=e;for(;t>O;)t&k&&(n=r.mul(n,i)),i=r.sqr(i),t>>=k;return n}function Br(r,e){let t=new Array(e.length),n=e.reduce((s,a,o)=>r.is0(a)?s:(t[o]=s,r.mul(s,a)),r.ONE),i=r.inv(n);return e.reduceRight((s,a,o)=>r.is0(a)?s:(t[o]=r.mul(s,t[o]),r.mul(s,a)),i),t}function Re(r,e){let t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function Kt(r,e,t=!1,n={}){if(r<=O)throw new Error(`Expected Fp ORDER > 0, got ${r}`);let{nBitLength:i,nByteLength:s}=Re(r,e);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");let a=mr(r),o=Object.freeze({ORDER:r,BITS:i,BYTES:s,MASK:me(i),ZERO:O,ONE:k,create:c=>H(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return O<=c&&c<r},is0:c=>c===O,isOdd:c=>(c&k)===k,neg:c=>H(-c,r),eql:(c,f)=>c===f,sqr:c=>H(c*c,r),add:(c,f)=>H(c+f,r),sub:(c,f)=>H(c-f,r),mul:(c,f)=>H(c*f,r),pow:(c,f)=>Ar(o,c,f),div:(c,f)=>H(c*Ne(f,r),r),sqrN:c=>c*c,addN:(c,f)=>c+f,subN:(c,f)=>c-f,mulN:(c,f)=>c*f,inv:c=>Ne(c,r),sqrt:n.sqrt||(c=>a(o,c)),invertBatch:c=>Br(o,c),cmov:(c,f,p)=>p?f:c,toBytes:c=>t?ot(c,s):Y(c,s),fromBytes:c=>{if(c.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);return t?He(c):$(c)}});return Object.freeze(o)}function kt(r,e,t=!1){r=N("privateHash",r);let n=r.length,i=Re(e).nByteLength+8;if(i<24||n<i||n>1024)throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${n}`);let s=t?He(r):$(r);return H(s,e-k)+k}var Sr=BigInt(0),ut=BigInt(1);function Ot(r,e){let t=(i,s)=>{let a=s.negate();return i?a:s},n=i=>{let s=Math.ceil(e/i)+1,a=2**(i-1);return{windows:s,windowSize:a}};return{constTimeNegate:t,unsafeLadder(i,s){let a=r.ZERO,o=i;for(;s>Sr;)s&ut&&(a=a.add(o)),o=o.double(),s>>=ut;return a},precomputeWindow(i,s){let{windows:a,windowSize:o}=n(s),c=[],f=i,p=f;for(let l=0;l<a;l++){p=f,c.push(p);for(let g=1;g<o;g++)p=p.add(f),c.push(p);f=p.double()}return c},wNAF(i,s,a){let{windows:o,windowSize:c}=n(i),f=r.ZERO,p=r.BASE,l=BigInt(2**i-1),g=2**i,_=BigInt(i);for(let w=0;w<o;w++){let u=w*c,h=Number(a&l);a>>=_,h>c&&(h-=g,a+=ut);let b=u,m=u+Math.abs(h)-1,A=w%2!==0,I=h<0;h===0?p=p.add(t(A,s[b])):f=f.add(t(I,s[m]))}return{p:f,f:p}},wNAFCached(i,s,a,o){let c=i._WINDOW_SIZE||1,f=s.get(i);return f||(f=this.precomputeWindow(i,c),c!==1&&s.set(i,o(f))),this.wNAF(c,f,a)}}}function lt(r){return ft(r.Fp),W(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Re(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}function _r(r){let e=lt(r);W(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:t,Fp:n,a:i}=e;if(t){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}var{bytesToNumberBE:Ir,hexToBytes:Pr}=ct,le={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(r){let{Err:e}=le;if(r.length<2||r[0]!==2)throw new e("Invalid signature integer tag");let t=r[1],n=r.subarray(2,t+2);if(!t||n.length!==t)throw new e("Invalid signature integer: wrong length");if(n[0]&128)throw new e("Invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Ir(n),l:r.subarray(t+2)}},toSig(r){let{Err:e}=le,t=typeof r=="string"?Pr(r):r;if(!(t instanceof Uint8Array))throw new Error("ui8a expected");let n=t.length;if(n<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==n-2)throw new e("Invalid signature: incorrect length");let{d:i,l:s}=le._parseInt(t.subarray(2)),{d:a,l:o}=le._parseInt(s);if(o.length)throw new e("Invalid signature: left bytes after parsing");return{r:i,s:a}},hexFromSig(r){let e=f=>Number.parseInt(f[0],16)&8?"00"+f:f,t=f=>{let p=f.toString(16);return p.length&1?`0${p}`:p},n=e(t(r.s)),i=e(t(r.r)),s=n.length/2,a=i.length/2,o=t(s),c=t(a);return`30${t(a+s+4)}02${c}${i}02${o}${n}`}},X=BigInt(0),V=BigInt(1),cn=BigInt(2),Tt=BigInt(3),an=BigInt(4);function Ur(r){let e=_r(r),{Fp:t}=e,n=e.toBytes||((w,u,h)=>{let b=u.toAffine();return oe(Uint8Array.from([4]),t.toBytes(b.x),t.toBytes(b.y))}),i=e.fromBytes||(w=>{let u=w.subarray(1),h=t.fromBytes(u.subarray(0,t.BYTES)),b=t.fromBytes(u.subarray(t.BYTES,2*t.BYTES));return{x:h,y:b}});function s(w){let{a:u,b:h}=e,b=t.sqr(w),m=t.mul(b,w);return t.add(t.add(m,t.mul(w,u)),h)}if(!t.eql(t.sqr(e.Gy),s(e.Gx)))throw new Error("bad generator point: equation left != right");function a(w){return typeof w=="bigint"&&X<w&&w<e.n}function o(w){if(!a(w))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(w){let{allowedPrivateKeyLengths:u,nByteLength:h,wrapPrivateKey:b,n:m}=e;if(u&&typeof w!="bigint"){if(w instanceof Uint8Array&&(w=ae(w)),typeof w!="string"||!u.includes(w.length))throw new Error("Invalid key");w=w.padStart(h*2,"0")}let A;try{A=typeof w=="bigint"?w:$(N("private key",w,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof w}`)}return b&&(A=H(A,m)),o(A),A}let f=new Map;function p(w){if(!(w instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(u,h,b){if(this.px=u,this.py=h,this.pz=b,u==null||!t.isValid(u))throw new Error("x required");if(h==null||!t.isValid(h))throw new Error("y required");if(b==null||!t.isValid(b))throw new Error("z required")}static fromAffine(u){let{x:h,y:b}=u||{};if(!u||!t.isValid(h)||!t.isValid(b))throw new Error("invalid affine point");if(u instanceof l)throw new Error("projective point not allowed");let m=A=>t.eql(A,t.ZERO);return m(h)&&m(b)?l.ZERO:new l(h,b,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){let h=t.invertBatch(u.map(b=>b.pz));return u.map((b,m)=>b.toAffine(h[m])).map(l.fromAffine)}static fromHex(u){let h=l.fromAffine(i(N("pointHex",u)));return h.assertValidity(),h}static fromPrivateKey(u){return l.BASE.multiply(c(u))}_setWindowSize(u){this._WINDOW_SIZE=u,f.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint)return;throw new Error("bad point: ZERO")}let{x:u,y:h}=this.toAffine();if(!t.isValid(u)||!t.isValid(h))throw new Error("bad point: x or y not FE");let b=t.sqr(h),m=s(u);if(!t.eql(b,m))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){let{y:u}=this.toAffine();if(t.isOdd)return!t.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){p(u);let{px:h,py:b,pz:m}=this,{px:A,py:I,pz:S}=u,x=t.eql(t.mul(h,S),t.mul(A,m)),E=t.eql(t.mul(b,S),t.mul(I,m));return x&&E}negate(){return new l(this.px,t.neg(this.py),this.pz)}double(){let{a:u,b:h}=e,b=t.mul(h,Tt),{px:m,py:A,pz:I}=this,S=t.ZERO,x=t.ZERO,E=t.ZERO,v=t.mul(m,m),j=t.mul(A,A),K=t.mul(I,I),P=t.mul(m,A);return P=t.add(P,P),E=t.mul(m,I),E=t.add(E,E),S=t.mul(u,E),x=t.mul(b,K),x=t.add(S,x),S=t.sub(j,x),x=t.add(j,x),x=t.mul(S,x),S=t.mul(P,S),E=t.mul(b,E),K=t.mul(u,K),P=t.sub(v,K),P=t.mul(u,P),P=t.add(P,E),E=t.add(v,v),v=t.add(E,v),v=t.add(v,K),v=t.mul(v,P),x=t.add(x,v),K=t.mul(A,I),K=t.add(K,K),v=t.mul(K,P),S=t.sub(S,v),E=t.mul(K,j),E=t.add(E,E),E=t.add(E,E),new l(S,x,E)}add(u){p(u);let{px:h,py:b,pz:m}=this,{px:A,py:I,pz:S}=u,x=t.ZERO,E=t.ZERO,v=t.ZERO,j=e.a,K=t.mul(e.b,Tt),P=t.mul(h,A),R=t.mul(b,I),q=t.mul(m,S),F=t.add(h,b),d=t.add(A,I);F=t.mul(F,d),d=t.add(P,R),F=t.sub(F,d),d=t.add(h,m);let y=t.add(A,S);return d=t.mul(d,y),y=t.add(P,q),d=t.sub(d,y),y=t.add(b,m),x=t.add(I,S),y=t.mul(y,x),x=t.add(R,q),y=t.sub(y,x),v=t.mul(j,d),x=t.mul(K,q),v=t.add(x,v),x=t.sub(R,v),v=t.add(R,v),E=t.mul(x,v),R=t.add(P,P),R=t.add(R,P),q=t.mul(j,q),d=t.mul(K,d),R=t.add(R,q),q=t.sub(P,q),q=t.mul(j,q),d=t.add(d,q),P=t.mul(R,d),E=t.add(E,P),P=t.mul(y,d),x=t.mul(F,x),x=t.sub(x,P),P=t.mul(F,R),v=t.mul(y,v),v=t.add(v,P),new l(x,E,v)}subtract(u){return this.add(u.negate())}is0(){return this.equals(l.ZERO)}wNAF(u){return _.wNAFCached(this,f,u,h=>{let b=t.invertBatch(h.map(m=>m.pz));return h.map((m,A)=>m.toAffine(b[A])).map(l.fromAffine)})}multiplyUnsafe(u){let h=l.ZERO;if(u===X)return h;if(o(u),u===V)return this;let{endo:b}=e;if(!b)return _.unsafeLadder(this,u);let{k1neg:m,k1:A,k2neg:I,k2:S}=b.splitScalar(u),x=h,E=h,v=this;for(;A>X||S>X;)A&V&&(x=x.add(v)),S&V&&(E=E.add(v)),v=v.double(),A>>=V,S>>=V;return m&&(x=x.negate()),I&&(E=E.negate()),E=new l(t.mul(E.px,b.beta),E.py,E.pz),x.add(E)}multiply(u){o(u);let h=u,b,m,{endo:A}=e;if(A){let{k1neg:I,k1:S,k2neg:x,k2:E}=A.splitScalar(h),{p:v,f:j}=this.wNAF(S),{p:K,f:P}=this.wNAF(E);v=_.constTimeNegate(I,v),K=_.constTimeNegate(x,K),K=new l(t.mul(K.px,A.beta),K.py,K.pz),b=v.add(K),m=j.add(P)}else{let{p:I,f:S}=this.wNAF(h);b=I,m=S}return l.normalizeZ([b,m])[0]}multiplyAndAddUnsafe(u,h,b){let m=l.BASE,A=(S,x)=>x===X||x===V||!S.equals(m)?S.multiplyUnsafe(x):S.multiply(x),I=A(this,h).add(A(u,b));return I.is0()?void 0:I}toAffine(u){let{px:h,py:b,pz:m}=this,A=this.is0();u==null&&(u=A?t.ONE:t.inv(m));let I=t.mul(h,u),S=t.mul(b,u),x=t.mul(m,u);if(A)return{x:t.ZERO,y:t.ZERO};if(!t.eql(x,t.ONE))throw new Error("invZ was invalid");return{x:I,y:S}}isTorsionFree(){let{h:u,isTorsionFree:h}=e;if(u===V)return!0;if(h)return h(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:u,clearCofactor:h}=e;return u===V?this:h?h(l,this):this.multiplyUnsafe(e.h)}toRawBytes(u=!0){return this.assertValidity(),n(l,this,u)}toHex(u=!0){return ae(this.toRawBytes(u))}}l.BASE=new l(e.Gx,e.Gy,t.ONE),l.ZERO=new l(t.ZERO,t.ONE,t.ZERO);let g=e.nBitLength,_=Ot(l,e.endo?Math.ceil(g/2):g);return{CURVE:e,ProjectivePoint:l,normPrivateKeyToScalar:c,weierstrassEquation:s,isWithinCurveOrder:a}}function Lr(r){let e=lt(r);return W(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Ht(r){let e=Lr(r),{Fp:t,n}=e,i=t.BYTES+1,s=2*t.BYTES+1;function a(d){return X<d&&d<t.ORDER}function o(d){return H(d,n)}function c(d){return Ne(d,n)}let{ProjectivePoint:f,normPrivateKeyToScalar:p,weierstrassEquation:l,isWithinCurveOrder:g}=Ur({...e,toBytes(d,y,B){let L=y.toAffine(),U=t.toBytes(L.x),T=oe;return B?T(Uint8Array.from([y.hasEvenY()?2:3]),U):T(Uint8Array.from([4]),U,t.toBytes(L.y))},fromBytes(d){let y=d.length,B=d[0],L=d.subarray(1);if(y===i&&(B===2||B===3)){let U=$(L);if(!a(U))throw new Error("Point is not on curve");let T=l(U),C=t.sqrt(T),z=(C&V)===V;return(B&1)===1!==z&&(C=t.neg(C)),{x:U,y:C}}else if(y===s&&B===4){let U=t.fromBytes(L.subarray(0,t.BYTES)),T=t.fromBytes(L.subarray(t.BYTES,2*t.BYTES));return{x:U,y:T}}else throw new Error(`Point of length ${y} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`)}}),_=d=>ae(Y(d,e.nByteLength));function w(d){let y=n>>V;return d>y}function u(d){return w(d)?o(-d):d}let h=(d,y,B)=>$(d.slice(y,B));class b{constructor(y,B,L){this.r=y,this.s=B,this.recovery=L,this.assertValidity()}static fromCompact(y){let B=e.nByteLength;return y=N("compactSignature",y,B*2),new b(h(y,0,B),h(y,B,2*B))}static fromDER(y){let{r:B,s:L}=le.toSig(N("DER",y));return new b(B,L)}assertValidity(){if(!g(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!g(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(y){return new b(this.r,this.s,y)}recoverPublicKey(y){let{r:B,s:L,recovery:U}=this,T=E(N("msgHash",y));if(U==null||![0,1,2,3].includes(U))throw new Error("recovery id invalid");let C=U===2||U===3?B+e.n:B;if(C>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");let z=U&1?"03":"02",ee=f.fromHex(z+_(C)),te=c(C),de=o(-T*te),we=o(L*te),re=f.BASE.multiplyAndAddUnsafe(ee,de,we);if(!re)throw new Error("point at infinify");return re.assertValidity(),re}hasHighS(){return w(this.s)}normalizeS(){return this.hasHighS()?new b(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return fe(this.toDERHex())}toDERHex(){return le.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return fe(this.toCompactHex())}toCompactHex(){return _(this.r)+_(this.s)}}let m={isValidPrivateKey(d){try{return p(d),!0}catch{return!1}},normPrivateKeyToScalar:p,randomPrivateKey:()=>{let d=e.randomBytes(t.BYTES+8),y=kt(d,n);return Y(y,e.nByteLength)},precompute(d=8,y=f.BASE){return y._setWindowSize(d),y.multiply(BigInt(3)),y}};function A(d,y=!0){return f.fromPrivateKey(d).toRawBytes(y)}function I(d){let y=d instanceof Uint8Array,B=typeof d=="string",L=(y||B)&&d.length;return y?L===i||L===s:B?L===2*i||L===2*s:d instanceof f}function S(d,y,B=!0){if(I(d))throw new Error("first arg must be private key");if(!I(y))throw new Error("second arg must be public key");return f.fromHex(y).multiply(p(d)).toRawBytes(B)}let x=e.bits2int||function(d){let y=$(d),B=d.length*8-e.nBitLength;return B>0?y>>BigInt(B):y},E=e.bits2int_modN||function(d){return o(x(d))},v=me(e.nBitLength);function j(d){if(typeof d!="bigint")throw new Error("bigint expected");if(!(X<=d&&d<v))throw new Error(`bigint expected < 2^${e.nBitLength}`);return Y(d,e.nByteLength)}function K(d,y,B=P){if(["recovered","canonical"].some(ce=>ce in B))throw new Error("sign() legacy options not supported");let{hash:L,randomBytes:U}=e,{lowS:T,prehash:C,extraEntropy:z}=B;T==null&&(T=!0),d=N("msgHash",d),C&&(d=N("prehashed msgHash",L(d)));let ee=E(d),te=p(y),de=[j(te),j(ee)];if(z!=null){let ce=z===!0?U(t.BYTES):z;de.push(N("extraEntropy",ce,t.BYTES))}let we=oe(...de),re=ee;function Je(ce){let he=x(ce);if(!g(he))return;let gt=c(he),Z=f.BASE.multiply(he).toAffine(),ye=o(Z.x);if(ye===X)return;let Ie=o(gt*o(re+ye*te));if(Ie===X)return;let mt=(Z.x===ye?0:2)|Number(Z.y&V),Et=Ie;return T&&w(Ie)&&(Et=u(Ie),mt^=1),new b(ye,Et,mt)}return{seed:we,k2sig:Je}}let P={lowS:e.lowS,prehash:!1},R={lowS:e.lowS,prehash:!1};function q(d,y,B=P){let{seed:L,k2sig:U}=K(d,y,B),T=e;return st(T.hash.outputLen,T.nByteLength,T.hmac)(L,U)}f.BASE._setWindowSize(8);function F(d,y,B,L=R){let U=d;if(y=N("msgHash",y),B=N("publicKey",B),"strict"in L)throw new Error("options.strict was renamed to lowS");let{lowS:T,prehash:C}=L,z,ee;try{if(typeof U=="string"||U instanceof Uint8Array)try{z=b.fromDER(U)}catch(Z){if(!(Z instanceof le.Err))throw Z;z=b.fromCompact(U)}else if(typeof U=="object"&&typeof U.r=="bigint"&&typeof U.s=="bigint"){let{r:Z,s:ye}=U;z=new b(Z,ye)}else throw new Error("PARSE");ee=f.fromHex(B)}catch(Z){if(Z.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(T&&z.hasHighS())return!1;C&&(y=e.hash(y));let{r:te,s:de}=z,we=E(y),re=c(de),Je=o(we*re),ce=o(te*re),he=f.BASE.multiplyAndAddUnsafe(ee,Je,ce)?.toAffine();return he?o(he.x)===te:!1}return{CURVE:e,getPublicKey:A,getSharedSecret:S,sign:q,verify:F,ProjectivePoint:f,Signature:b,utils:m}}var qe=class extends pe{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,G.hash(e);let n=ge(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,s=new Uint8Array(i);s.set(n.length>i?e.create().update(n).digest():n);for(let a=0;a<s.length;a++)s[a]^=54;this.iHash.update(s),this.oHash=e.create();for(let a=0;a<s.length;a++)s[a]^=106;this.oHash.update(s),s.fill(0)}update(e){return G.exists(this),this.iHash.update(e),this}digestInto(e){G.exists(this),G.bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:n,finished:i,destroyed:s,blockLen:a,outputLen:o}=this;return e=e,e.finished=i,e.destroyed=s,e.blockLen=a,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},Ee=(r,e,t)=>new qe(r,e).update(t).digest();Ee.create=(r,e)=>new qe(r,e);function Kr(r){return{hash:r,hmac:(e,...t)=>Ee(r,e,vt(...t)),randomBytes:tt}}function Nt(r,e){let t=n=>Ht({...r,...Kr(n)});return Object.freeze({...t(e),create:t})}var Ct=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Rt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),kr=BigInt(1),dt=BigInt(2),qt=(r,e)=>(r+e/dt)/e;function Or(r){let e=Ct,t=BigInt(3),n=BigInt(6),i=BigInt(11),s=BigInt(22),a=BigInt(23),o=BigInt(44),c=BigInt(88),f=r*r*r%e,p=f*f*r%e,l=D(p,t,e)*p%e,g=D(l,t,e)*p%e,_=D(g,dt,e)*f%e,w=D(_,i,e)*_%e,u=D(w,s,e)*w%e,h=D(u,o,e)*u%e,b=D(h,c,e)*h%e,m=D(b,o,e)*u%e,A=D(m,t,e)*p%e,I=D(A,a,e)*w%e,S=D(I,n,e)*f%e,x=D(S,dt,e);if(!ht.eql(ht.sqr(x),r))throw new Error("Cannot find square root");return x}var ht=Kt(Ct,void 0,void 0,{sqrt:Or}),Ae=Nt({a:BigInt(0),b:BigInt(7),Fp:ht,n:Rt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{let e=Rt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-kr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=t,a=BigInt("0x100000000000000000000000000000000"),o=qt(s*r,e),c=qt(-n*r,e),f=H(r-o*t-c*i,e),p=H(-o*n-c*s,e),l=f>a,g=p>a;if(l&&(f=e-f),g&&(p=e-p),f>a||p>a)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:l,k1:f,k2neg:g,k2:p}}}},ke),Ln=BigInt(0);var Kn=Ae.ProjectivePoint;var Ce=["deriveBits"];var Q=new Uint8Array(0),yt=new Uint8Array([72,80,75,69,45,118,49]),On=new Uint8Array([72,80,75,69,0,0,0,0,0,0]),zt=new Uint8Array([75,69,77,0,0]),Dt=new Uint8Array([100,107,112,95,112,114,107]),jt=new Uint8Array([101,97,101,95,112,114,107]),Tn=new Uint8Array([105,110,102,111,95,104,97,115,104]),Hn=new Uint8Array([112,115,107,95,105,100,95,104,97,115,104]),Nn=new Uint8Array([115,101,99,114,101,116]),Vt=new Uint8Array([115,104,97,114,101,100,95,115,101,99,114,101,116]),Rn=new Uint8Array([107,101,121]),qn=new Uint8Array([98,97,115,101,95,110,111,110,99,101]),Cn=new Uint8Array([101,120,112]),zn=new Uint8Array([115,101,99]),Dn=new Uint8Array([99,97,110,100,105,100,97,116,101]),Mt=new Uint8Array([115,107]),jn=new Uint8Array([255,255,255,255,0,0,0,0,255,255,255,255,255,255,255,255,188,230,250,173,167,23,158,132,243,185,202,194,252,99,37,81]),Vn=new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,199,99,77,129,244,55,45,223,88,26,13,178,72,176,167,122,236,236,25,106,204,197,41,115]),Mn=new Uint8Array([1,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,81,134,135,131,191,47,150,107,127,204,1,72,247,9,165,208,59,181,201,184,137,156,71,174,187,111,183,30,145,56,100,9]);var ze=class{constructor(){Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}checkInit(){if(typeof this._api>"u")throw new Error("Not initialized. Call init()")}},be=class extends ze{constructor(){super()}init(e){this._api=e}},De=class extends ze{constructor(){super(),Object.defineProperty(this,"_suiteId",{enumerable:!0,configurable:!0,writable:!0,value:Q})}init(e,t){this._api=e,this._suiteId=t}};var Tr={DhkemP256HkdfSha256:16,DhkemP384HkdfSha384:17,DhkemP521HkdfSha512:18,DhkemSecp256k1HkdfSha256:19,DhkemX25519HkdfSha256:32,DhkemX448HkdfSha512:33},je=Tr,Hr={HkdfSha256:1,HkdfSha384:2,HkdfSha512:3},pt=Hr;var se=class{constructor(e,t,n){Object.defineProperty(this,"key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extractable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"algorithm",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"usages",{enumerable:!0,configurable:!0,writable:!0,value:Ce}),this.key=t,this.type=n,this.algorithm={name:e},n==="public"&&(this.usages=[])}};var J=class extends Error{constructor(e){let t;e instanceof Error?t=e.message:typeof e=="string"?t=e:t="",super(t),this.name=this.constructor.name}},Ve=class extends J{};var Me=class extends J{},xe=class extends J{},$e=class extends J{},Ze=class extends J{};var Ge=class extends J{},Ye=class extends J{};var bt=class extends De{constructor(){super(),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:pt.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}buildLabeledIkm(e,t){let n=new Uint8Array(7+this._suiteId.byteLength+e.byteLength+t.byteLength);return n.set(yt,0),n.set(this._suiteId,7),n.set(e,7+this._suiteId.byteLength),n.set(t,7+this._suiteId.byteLength+e.byteLength),n}buildLabeledInfo(e,t,n){let i=new Uint8Array(9+this._suiteId.byteLength+e.byteLength+t.byteLength);return i.set(new Uint8Array([0,n]),0),i.set(yt,2),i.set(this._suiteId,9),i.set(e,9+this._suiteId.byteLength),i.set(t,9+this._suiteId.byteLength+e.byteLength),i}async extract(e,t){if(this.checkInit(),e.byteLength===0&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)throw new Ve("The salt length must be the same as the hashSize");let n=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,t)}async expand(e,t,n){this.checkInit();let i=await this._api.importKey("raw",e,this.algHash,!1,["sign"]),s=new ArrayBuffer(n),a=new Uint8Array(s),o=Q,c=new Uint8Array(t),f=new Uint8Array(1);if(n>255*this.hashSize)throw new Error("Entropy limit reached");let p=new Uint8Array(this.hashSize+c.length+1);for(let l=1,g=0;g<a.length;l++)f[0]=l,p.set(o,0),p.set(c,o.length),p.set(f,o.length+c.length),o=new Uint8Array(await this._api.sign("HMAC",i,p.slice(0,o.length+c.length+1))),a.length-g>=o.length?(a.set(o,g),g+=o.length):(a.set(o.slice(0,a.length-g),g),g+=a.length-g);return s}async extractAndExpand(e,t,n,i){this.checkInit();let s=await this._api.importKey("raw",t,"HKDF",!1,Ce);return await this._api.deriveBits({name:"HKDF",hash:this.algHash.hash,salt:e,info:n},s,i*8)}async labeledExtract(e,t,n){return await this.extract(e,this.buildLabeledIkm(t,n))}async labeledExpand(e,t,n,i){return await this.expand(e,this.buildLabeledInfo(t,n,i),i)}},We=class extends bt{constructor(){super(...arguments),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:pt.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}};var Xe=class extends We{async extract(e,t){if(this.checkInit(),e.byteLength===0&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)return Ee(ke,new Uint8Array(e),new Uint8Array(t));let n=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,t)}};var Nr={},Rr=qr(globalThis,Nr);function qr(r,e){return new Proxy(r,{get(t,n,i){return n in e?e[n]:r[n]},set(t,n,i){return n in e&&delete e[n],r[n]=i,!0},deleteProperty(t,n){let i=!1;return n in e&&(delete e[n],i=!0),n in r&&(delete r[n],i=!0),i},ownKeys(t){let n=Reflect.ownKeys(r),i=Reflect.ownKeys(e),s=new Set(i);return[...n.filter(a=>!s.has(a)),...i]},defineProperty(t,n,i){return n in e&&delete e[n],Reflect.defineProperty(r,n,i),!0},getOwnPropertyDescriptor(t,n){return n in e?Reflect.getOwnPropertyDescriptor(e,n):Reflect.getOwnPropertyDescriptor(r,n)},has(t,n){return n in e||n in r}})}var ve=r=>typeof r=="object"&&r!==null&&typeof r.privateKey=="object"&&typeof r.publicKey=="object";function Zt(r,e){if(e<=0)throw new Error("i2Osp: too small size");if(r>=256**e)throw new Error("i2Osp: too large integer");let t=new Uint8Array(e);for(let n=0;n<e&&r;n++)t[e-(n+1)]=r%256,r=r>>8;return t}function Se(r,e){let t=new Uint8Array(r.length+e.length);return t.set(r,0),t.set(e,r.length),t}function Gt(r,e,t){let n=new Uint8Array(r.length+e.length+t.length);return n.set(r,0),n.set(e,r.length),n.set(t,r.length+e.length),n}var Qe=class extends be{constructor(e,t){super(),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:je.DhkemP256HkdfSha256}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_prim",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._prim=e,this._kdf=t}init(e){super.init(e);let t=new Uint8Array(zt);t.set(Zt(this.id,2),3),this._prim.init(e),this._kdf.init(e,t),super.init(e)}async generateKeyPair(){try{return await this._prim.generateKeyPair()}catch(e){throw new Ye(e)}}async deriveKeyPair(e){try{return await this._prim.deriveKeyPair(e)}catch(t){throw new Ge(t)}}async serializePublicKey(e){try{return await this._prim.serializePublicKey(e)}catch(t){throw new Me(t)}}async deserializePublicKey(e){try{return await this._prim.deserializePublicKey(e)}catch(t){throw new xe(t)}}async importKey(e,t,n){try{return await this._prim.importKey(e,t,n)}catch(i){throw new xe(i)}}async encap(e){try{let t=e.nonEphemeralKeyPair===void 0?await this.generateKeyPair():e.nonEphemeralKeyPair,n=await this._prim.serializePublicKey(t.publicKey),i=await this._prim.serializePublicKey(e.recipientPublicKey),s;if(e.senderKey===void 0)s=new Uint8Array(await this._prim.dh(t.privateKey,e.recipientPublicKey));else{let c=ve(e.senderKey)?e.senderKey.privateKey:e.senderKey,f=new Uint8Array(await this._prim.dh(t.privateKey,e.recipientPublicKey)),p=new Uint8Array(await this._prim.dh(c,e.recipientPublicKey));s=Se(f,p)}let a;if(e.senderKey===void 0)a=Se(new Uint8Array(n),new Uint8Array(i));else{let c=ve(e.senderKey)?e.senderKey.publicKey:await this._prim.derivePublicKey(e.senderKey),f=await this._prim.serializePublicKey(c);a=Gt(new Uint8Array(n),new Uint8Array(i),new Uint8Array(f))}let o=await this.generateSharedSecret(s,a);return{enc:n,sharedSecret:o}}catch(t){throw new $e(t)}}async decap(e){let t;try{t=await this._prim.deserializePublicKey(e.enc)}catch(n){throw new xe(n)}try{let n=ve(e.recipientKey)?e.recipientKey.privateKey:e.recipientKey,i=ve(e.recipientKey)?e.recipientKey.publicKey:await this._prim.derivePublicKey(e.recipientKey),s=await this._prim.serializePublicKey(i),a;if(e.senderPublicKey===void 0)a=new Uint8Array(await this._prim.dh(n,t));else{let c=new Uint8Array(await this._prim.dh(n,t)),f=new Uint8Array(await this._prim.dh(n,e.senderPublicKey));a=Se(c,f)}let o;if(e.senderPublicKey===void 0)o=Se(new Uint8Array(e.enc),new Uint8Array(s));else{let c=await this._prim.serializePublicKey(e.senderPublicKey);o=new Uint8Array(e.enc.byteLength+s.byteLength+c.byteLength),o.set(new Uint8Array(e.enc),0),o.set(new Uint8Array(s),e.enc.byteLength),o.set(new Uint8Array(c),e.enc.byteLength+s.byteLength)}return await this.generateSharedSecret(a,o)}catch(n){throw new Ze(n)}}async generateSharedSecret(e,t){let n=this._kdf.buildLabeledIkm(jt,e),i=this._kdf.buildLabeledInfo(Vt,t,this.secretSize);return await this._kdf.extractAndExpand(Q,n,i,this.secretSize)}};var _e="ECDH",xt=class extends be{constructor(e){super(),Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=e,this._nPk=33,this._nSk=32}async serializePublicKey(e){return await this._serializePublicKey(e)}async deserializePublicKey(e){return await this._deserializePublicKey(e)}async importKey(e,t,n){if(e!=="raw")throw new Error("Unsupported format");return await this._importKey(t,n)}async derivePublicKey(e){return await this._derivePublicKey(e)}async generateKeyPair(){let e=Ae.utils.randomPrivateKey(),t=new se(_e,e,"private");return{publicKey:await this.derivePublicKey(t),privateKey:t}}async deriveKeyPair(e){let t=await this._hkdf.labeledExtract(Q,Dt,new Uint8Array(e)),n=await this._hkdf.labeledExpand(t,Mt,Q,this._nSk),i=new se(_e,new Uint8Array(n),"private");return{privateKey:i,publicKey:await this.derivePublicKey(i)}}async dh(e,t){return await this._dh(e,t)}_serializePublicKey(e){return new Promise(t=>{t(e.key.buffer)})}_deserializePublicKey(e){return new Promise((t,n)=>{e.byteLength!==this._nPk?n(new Error("Invalid public key for the ciphersuite")):t(new se(_e,new Uint8Array(e),"public"))})}_importKey(e,t){return new Promise((n,i)=>{t&&e.byteLength!==this._nPk&&i(new Error("Invalid public key for the ciphersuite")),!t&&e.byteLength!==this._nSk&&i(new Error("Invalid private key for the ciphersuite")),n(new se(_e,new Uint8Array(e),t?"public":"private"))})}_derivePublicKey(e){return new Promise(t=>{let n=Ae.getPublicKey(e.key);t(new se(_e,n,"public"))})}_dh(e,t){return new Promise((n,i)=>{try{n(Ae.getSharedSecret(e.key,t.key).buffer)}catch(s){i(s)}})}},wt=class extends Qe{constructor(){let e=new Xe,t=new xt(e);super(t,e),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:je.DhkemSecp256k1HkdfSha256}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:32})}};export{wt as DhkemSecp256k1HkdfSha256};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
