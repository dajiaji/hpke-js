var or=Object.defineProperty;var sr=(r,e)=>{for(var t in e)or(r,t,{get:e[t],enumerable:!0})};var ar={},It=cr(globalThis,ar);function cr(r,e){return new Proxy(r,{get(t,n,i){return n in e?e[n]:r[n]},set(t,n,i){return n in e&&delete e[n],r[n]=i,!0},deleteProperty(t,n){let i=!1;return n in e&&(delete e[n],i=!0),n in r&&(delete r[n],i=!0),i},ownKeys(t){let n=Reflect.ownKeys(r),i=Reflect.ownKeys(e),o=new Set(i);return[...n.filter(c=>!o.has(c)),...i]},defineProperty(t,n,i){return n in e&&delete e[n],Reflect.defineProperty(r,n,i),!0},getOwnPropertyDescriptor(t,n){return n in e?Reflect.getOwnPropertyDescriptor(e,n):Reflect.getOwnPropertyDescriptor(r,n)},has(t,n){return n in e||n in r}})}var ot=class extends Error{constructor(e){let t;e instanceof Error?t=e.message:typeof e=="string"?t=e:t="",super(t),this.name=this.constructor.name}},Q=class extends ot{},J=class extends Q{};var F=class extends Q{},W=class extends Q{},qe=class extends Q{},Me=class extends Q{};var ke=class extends Q{},G=class extends Q{};async function fr(){if(It!==void 0&&globalThis.crypto!==void 0)return globalThis.crypto.subtle;try{let{webcrypto:r}=await import("crypto");return r.subtle}catch(r){throw new G(r)}}var ye=class{constructor(){Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}async _setup(){this._api===void 0&&(this._api=await fr())}};var oe={NotAssigned:0,DhkemP256HkdfSha256:16,DhkemP384HkdfSha384:17,DhkemP521HkdfSha512:18,DhkemSecp256k1HkdfSha256:19,DhkemX25519HkdfSha256:32,DhkemX448HkdfSha512:33,HybridkemX25519Kyber768:48},$e={HkdfSha256:1,HkdfSha384:2,HkdfSha512:3};var V=new Uint8Array(0);var kn=new Uint8Array([115,101,99]);var be=r=>typeof r=="object"&&r!==null&&typeof r.privateKey=="object"&&typeof r.publicKey=="object";function Se(r,e){if(e<=0)throw new Error("i2Osp: too small size");if(r>=256**e)throw new Error("i2Osp: too large integer");let t=new Uint8Array(e);for(let n=0;n<e&&r;n++)t[e-(n+1)]=r%256,r=r>>8;return t}function Pe(r,e){let t=new Uint8Array(r.length+e.length);return t.set(r,0),t.set(e,r.length),t}var ni=new Uint8Array([98,97,115,101,95,110,111,110,99,101]),ii=new Uint8Array([101,120,112]),oi=new Uint8Array([105,110,102,111,95,104,97,115,104]),si=new Uint8Array([107,101,121]),ai=new Uint8Array([112,115,107,95,105,100,95,104,97,115,104]),ci=new Uint8Array([115,101,99,114,101,116]),ui=new Uint8Array([72,80,75,69,0,0,0,0,0,0]);var Ot=new Uint8Array([72,80,75,69,45,118,49]),at=class extends ye{constructor(){super(),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:$e.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_suiteId",{enumerable:!0,configurable:!0,writable:!0,value:V}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}init(e){this._suiteId=e}buildLabeledIkm(e,t){this._checkInit();let n=new Uint8Array(7+this._suiteId.byteLength+e.byteLength+t.byteLength);return n.set(Ot,0),n.set(this._suiteId,7),n.set(e,7+this._suiteId.byteLength),n.set(t,7+this._suiteId.byteLength+e.byteLength),n}buildLabeledInfo(e,t,n){this._checkInit();let i=new Uint8Array(9+this._suiteId.byteLength+e.byteLength+t.byteLength);return i.set(new Uint8Array([0,n]),0),i.set(Ot,2),i.set(this._suiteId,9),i.set(e,9+this._suiteId.byteLength),i.set(t,9+this._suiteId.byteLength+e.byteLength),i}async extract(e,t){if(await this._setup(),e.byteLength===0&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)throw new J("The salt length must be the same as the hashSize");let n=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,t)}async expand(e,t,n){await this._setup();let i=await this._api.importKey("raw",e,this.algHash,!1,["sign"]),o=new ArrayBuffer(n),c=new Uint8Array(o),a=V,s=new Uint8Array(t),f=new Uint8Array(1);if(n>255*this.hashSize)throw new Error("Entropy limit reached");let b=new Uint8Array(this.hashSize+s.length+1);for(let l=1,x=0;x<c.length;l++)f[0]=l,b.set(a,0),b.set(s,a.length),b.set(f,a.length+s.length),a=new Uint8Array(await this._api.sign("HMAC",i,b.slice(0,a.length+s.length+1))),c.length-x>=a.length?(c.set(a,x),x+=a.length):(c.set(a.slice(0,c.length-x),x),x+=c.length-x);return o}async extractAndExpand(e,t,n,i){await this._setup();let o=await this._api.importKey("raw",t,"HKDF",!1,["deriveBits"]);return await this._api.deriveBits({name:"HKDF",hash:this.algHash.hash,salt:e,info:n},o,i*8)}async labeledExtract(e,t,n){return await this.extract(e,this.buildLabeledIkm(t,n))}async labeledExpand(e,t,n,i){return await this.expand(e,this.buildLabeledInfo(t,n,i),i)}_checkInit(){if(this._suiteId===V)throw new Error("Not initialized. Call init()")}},ze=class extends at{constructor(){super(...arguments),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:$e.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}};var ct=new Uint8Array([75,69,77,0,0]);var dr=new Uint8Array([101,97,101,95,112,114,107]),hr=new Uint8Array([115,104,97,114,101,100,95,115,101,99,114,101,116]);function yr(r,e,t){let n=new Uint8Array(r.length+e.length+t.length);return n.set(r,0),n.set(e,r.length),n.set(t,r.length+e.length),n}var we=class{constructor(e,t,n){Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_prim",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.id=e,this._prim=t,this._kdf=n;let i=new Uint8Array(ct);i.set(Se(this.id,2),3),this._kdf.init(i)}async serializePublicKey(e){return await this._prim.serializePublicKey(e)}async deserializePublicKey(e){return await this._prim.deserializePublicKey(e)}async serializePrivateKey(e){return await this._prim.serializePrivateKey(e)}async deserializePrivateKey(e){return await this._prim.deserializePrivateKey(e)}async importKey(e,t,n=!0){return await this._prim.importKey(e,t,n)}async generateKeyPair(){return await this._prim.generateKeyPair()}async deriveKeyPair(e){if(e.byteLength>8192)throw new J("Too long ikm");return await this._prim.deriveKeyPair(e)}async encap(e){let t;e.ekm===void 0?t=await this.generateKeyPair():be(e.ekm)?t=e.ekm:t=await this.deriveKeyPair(e.ekm);let n=await this._prim.serializePublicKey(t.publicKey),i=await this._prim.serializePublicKey(e.recipientPublicKey);try{let o;if(e.senderKey===void 0)o=new Uint8Array(await this._prim.dh(t.privateKey,e.recipientPublicKey));else{let s=be(e.senderKey)?e.senderKey.privateKey:e.senderKey,f=new Uint8Array(await this._prim.dh(t.privateKey,e.recipientPublicKey)),b=new Uint8Array(await this._prim.dh(s,e.recipientPublicKey));o=Pe(f,b)}let c;if(e.senderKey===void 0)c=Pe(new Uint8Array(n),new Uint8Array(i));else{let s=be(e.senderKey)?e.senderKey.publicKey:await this._prim.derivePublicKey(e.senderKey),f=await this._prim.serializePublicKey(s);c=yr(new Uint8Array(n),new Uint8Array(i),new Uint8Array(f))}let a=await this._generateSharedSecret(o,c);return{enc:n,sharedSecret:a}}catch(o){throw new qe(o)}}async decap(e){let t=await this._prim.deserializePublicKey(e.enc),n=be(e.recipientKey)?e.recipientKey.privateKey:e.recipientKey,i=be(e.recipientKey)?e.recipientKey.publicKey:await this._prim.derivePublicKey(e.recipientKey),o=await this._prim.serializePublicKey(i);try{let c;if(e.senderPublicKey===void 0)c=new Uint8Array(await this._prim.dh(n,t));else{let s=new Uint8Array(await this._prim.dh(n,t)),f=new Uint8Array(await this._prim.dh(n,e.senderPublicKey));c=Pe(s,f)}let a;if(e.senderPublicKey===void 0)a=Pe(new Uint8Array(e.enc),new Uint8Array(o));else{let s=await this._prim.serializePublicKey(e.senderPublicKey);a=new Uint8Array(e.enc.byteLength+o.byteLength+s.byteLength),a.set(new Uint8Array(e.enc),0),a.set(new Uint8Array(o),e.enc.byteLength),a.set(new Uint8Array(s),e.enc.byteLength+o.byteLength)}return await this._generateSharedSecret(c,a)}catch(c){throw new Me(c)}}async _generateSharedSecret(e,t){let n=this._kdf.buildLabeledIkm(dr,e),i=this._kdf.buildLabeledInfo(hr,t,this.secretSize);return await this._kdf.extractAndExpand(V,n,i,this.secretSize)}};var Lt=new Uint8Array([100,107,112,95,112,114,107]),br=new Uint8Array([115,107]);var zi=new Uint8Array([99,97,110,100,105,100,97,116,101]),Hi=new Uint8Array([255,255,255,255,0,0,0,0,255,255,255,255,255,255,255,255,188,230,250,173,167,23,158,132,243,185,202,194,252,99,37,81]),Ti=new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,199,99,77,129,244,55,45,223,88,26,13,178,72,176,167,122,236,236,25,106,204,197,41,115]),Ni=new Uint8Array([1,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,81,134,135,131,191,47,150,107,127,204,1,72,247,9,165,208,59,181,201,184,137,156,71,174,187,111,183,30,145,56,100,9]),ji=new Uint8Array([48,65,2,1,0,48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7,4,39,48,37,2,1,1,4,32]),Ri=new Uint8Array([48,78,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,34,4,55,48,53,2,1,1,4,48]),Ci=new Uint8Array([48,96,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,35,4,73,48,71,2,1,1,4,66]);var He=class extends ze{};var X=class{constructor(e,t,n,i=[]){Object.defineProperty(this,"key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extractable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"algorithm",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"usages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.key=t,this.type=n,this.algorithm={name:e},this.usages=i,n==="public"&&(this.usages=[])}};function Ut(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`positive integer expected, not ${r}`)}function gr(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function Ae(r,...e){if(!gr(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${r.length}`)}function zt(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Ut(r.outputLen),Ut(r.blockLen)}function Ke(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Ht(r,e){Ae(r);let t=e.outputLen;if(r.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}var Ve=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var Ze=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),Z=(r,e)=>r<<32-e|r>>>e;var To=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function xr(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function Te(r){return typeof r=="string"&&(r=xr(r)),Ae(r),r}function Tt(...r){let e=0;for(let n=0;n<r.length;n++){let i=r[n];Ae(i),e+=i.length}let t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){let o=r[n];t.set(o,i),i+=o.length}return t}var Be=class{clone(){return this._cloneInto()}},No={}.toString;function Nt(r){let e=n=>r().update(Te(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function jt(r=32){if(Ve&&typeof Ve.getRandomValues=="function")return Ve.getRandomValues(new Uint8Array(r));throw new Error("crypto.getRandomValues must be defined")}var Ye=class extends Be{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,zt(e);let n=Te(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,o=new Uint8Array(i);o.set(n.length>i?e.create().update(n).digest():n);for(let c=0;c<o.length;c++)o[c]^=54;this.iHash.update(o),this.oHash=e.create();for(let c=0;c<o.length;c++)o[c]^=106;this.oHash.update(o),o.fill(0)}update(e){return Ke(this),this.iHash.update(e),this}digestInto(e){Ke(this),Ae(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:n,finished:i,destroyed:o,blockLen:c,outputLen:a}=this;return e=e,e.finished=i,e.destroyed=o,e.blockLen=c,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},Ne=(r,e,t)=>new Ye(r,e).update(t).digest();Ne.create=(r,e)=>new Ye(r,e);function _r(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);let i=BigInt(32),o=BigInt(4294967295),c=Number(t>>i&o),a=Number(t&o),s=n?4:0,f=n?0:4;r.setUint32(e+s,c,n),r.setUint32(e+f,a,n)}var Rt=(r,e,t)=>r&e^~r&t,Ct=(r,e,t)=>r&e^r&t^e&t,We=class extends Be{constructor(e,t,n,i){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Ze(this.buffer)}update(e){Ke(this);let{view:t,buffer:n,blockLen:i}=this;e=Te(e);let o=e.length;for(let c=0;c<o;){let a=Math.min(i-this.pos,o-c);if(a===i){let s=Ze(e);for(;i<=o-c;c+=i)this.process(s,c);continue}n.set(e.subarray(c,c+a),this.pos),this.pos+=a,c+=a,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Ke(this),Ht(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:i,isLE:o}=this,{pos:c}=this;t[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>i-c&&(this.process(n,0),c=0);for(let l=c;l<i;l++)t[l]=0;_r(n,i-8,BigInt(this.length*8),o),this.process(n,0);let a=Ze(e),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=s/4,b=this.get();if(f>b.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<f;l++)a.setUint32(4*l,b[l],o)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:i,finished:o,destroyed:c,pos:a}=this;return e.length=i,e.pos=a,e.finished=o,e.destroyed=c,i%t&&e.buffer.set(n),e}};var vr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),se=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ae=new Uint32Array(64),ut=class extends We{constructor(){super(64,32,8,!1),this.A=se[0]|0,this.B=se[1]|0,this.C=se[2]|0,this.D=se[3]|0,this.E=se[4]|0,this.F=se[5]|0,this.G=se[6]|0,this.H=se[7]|0}get(){let{A:e,B:t,C:n,D:i,E:o,F:c,G:a,H:s}=this;return[e,t,n,i,o,c,a,s]}set(e,t,n,i,o,c,a,s){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=o|0,this.F=c|0,this.G=a|0,this.H=s|0}process(e,t){for(let l=0;l<16;l++,t+=4)ae[l]=e.getUint32(t,!1);for(let l=16;l<64;l++){let x=ae[l-15],P=ae[l-2],g=Z(x,7)^Z(x,18)^x>>>3,u=Z(P,17)^Z(P,19)^P>>>10;ae[l]=u+ae[l-7]+g+ae[l-16]|0}let{A:n,B:i,C:o,D:c,E:a,F:s,G:f,H:b}=this;for(let l=0;l<64;l++){let x=Z(a,6)^Z(a,11)^Z(a,25),P=b+x+Rt(a,s,f)+vr[l]+ae[l]|0,u=(Z(n,2)^Z(n,13)^Z(n,22))+Ct(n,i,o)|0;b=f,f=s,s=a,a=c+P|0,c=o,o=i,i=n,n=P+u|0}n=n+this.A|0,i=i+this.B|0,o=o+this.C|0,c=c+this.D|0,a=a+this.E|0,s=s+this.F|0,f=f+this.G|0,b=b+this.H|0,this.set(n,i,o,c,a,s,f,b)}roundClean(){ae.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var Xe=Nt(()=>new ut);var Ie=class extends He{async extract(e,t){if(await this._setup(),e.byteLength===0&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)return Ne(Xe,new Uint8Array(e),new Uint8Array(t));let n=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,t)}};var bt={};sr(bt,{aInRange:()=>fe,abool:()=>pe,abytes:()=>Oe,bitGet:()=>Br,bitLen:()=>Kr,bitMask:()=>Re,bitSet:()=>Ir,bytesToHex:()=>me,bytesToNumberBE:()=>te,bytesToNumberLE:()=>Je,concatBytes:()=>Le,createHmacDrbg:()=>yt,ensureBytes:()=>D,equalBytes:()=>Pr,hexToBytes:()=>ge,hexToNumber:()=>ht,inRange:()=>je,isBytes:()=>ce,memoized:()=>et,notImplemented:()=>Lr,numberToBytesBE:()=>ue,numberToBytesLE:()=>Fe,numberToHexUnpadded:()=>Mt,numberToVarBytesBE:()=>Sr,utf8ToBytes:()=>Ar,validateObject:()=>le});var dt=BigInt(0),Qe=BigInt(1),Er=BigInt(2);function ce(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function Oe(r){if(!ce(r))throw new Error("Uint8Array expected")}function pe(r,e){if(typeof e!="boolean")throw new Error(`${r} must be valid boolean, got "${e}".`)}var kr=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function me(r){Oe(r);let e="";for(let t=0;t<r.length;t++)e+=kr[r[t]];return e}function Mt(r){let e=r.toString(16);return e.length&1?`0${e}`:e}function ht(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}var ee={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Dt(r){if(r>=ee._0&&r<=ee._9)return r-ee._0;if(r>=ee._A&&r<=ee._F)return r-(ee._A-10);if(r>=ee._a&&r<=ee._f)return r-(ee._a-10)}function ge(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let e=r.length,t=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);let n=new Uint8Array(t);for(let i=0,o=0;i<t;i++,o+=2){let c=Dt(r.charCodeAt(o)),a=Dt(r.charCodeAt(o+1));if(c===void 0||a===void 0){let s=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+o)}n[i]=c*16+a}return n}function te(r){return ht(me(r))}function Je(r){return Oe(r),ht(me(Uint8Array.from(r).reverse()))}function ue(r,e){return ge(r.toString(16).padStart(e*2,"0"))}function Fe(r,e){return ue(r,e).reverse()}function Sr(r){return ge(Mt(r))}function D(r,e,t){let n;if(typeof e=="string")try{n=ge(e)}catch(o){throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${o}`)}else if(ce(e))n=Uint8Array.from(e);else throw new Error(`${r} must be hex string or Uint8Array`);let i=n.length;if(typeof t=="number"&&i!==t)throw new Error(`${r} expected ${t} bytes, got ${i}`);return n}function Le(...r){let e=0;for(let n=0;n<r.length;n++){let i=r[n];Oe(i),e+=i.length}let t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){let o=r[n];t.set(o,i),i+=o.length}return t}function Pr(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}function Ar(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}var ft=r=>typeof r=="bigint"&&dt<=r;function je(r,e,t){return ft(r)&&ft(e)&&ft(t)&&e<=r&&r<t}function fe(r,e,t,n){if(!je(e,t,n))throw new Error(`expected valid ${r}: ${t} <= n < ${n}, got ${typeof e} ${e}`)}function Kr(r){let e;for(e=0;r>dt;r>>=Qe,e+=1);return e}function Br(r,e){return r>>BigInt(e)&Qe}function Ir(r,e,t){return r|(t?Qe:dt)<<BigInt(e)}var Re=r=>(Er<<BigInt(r-1))-Qe,lt=r=>new Uint8Array(r),qt=r=>Uint8Array.from(r);function yt(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=lt(r),i=lt(r),o=0,c=()=>{n.fill(1),i.fill(0),o=0},a=(...l)=>t(i,n,...l),s=(l=lt())=>{i=a(qt([0]),l),n=a(),l.length!==0&&(i=a(qt([1]),l),n=a())},f=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let l=0,x=[];for(;l<e;){n=a();let P=n.slice();x.push(P),l+=n.length}return Le(...x)};return(l,x)=>{c(),s(l);let P;for(;!(P=x(f()));)s();return c(),P}}var Or={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||ce(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function le(r,e,t={}){let n=(i,o,c)=>{let a=Or[o];if(typeof a!="function")throw new Error(`Invalid validator "${o}", expected function`);let s=r[i];if(!(c&&s===void 0)&&!a(s,r))throw new Error(`Invalid param ${String(i)}=${s} (${typeof s}), expected ${o}`)};for(let[i,o]of Object.entries(e))n(i,o,!1);for(let[i,o]of Object.entries(t))n(i,o,!0);return r}var Lr=()=>{throw new Error("not implemented")};function et(r){let e=new WeakMap;return(t,...n)=>{let i=e.get(t);if(i!==void 0)return i;let o=r(t,...n);return e.set(t,o),o}}var U=BigInt(0),L=BigInt(1),xe=BigInt(2),Ur=BigInt(3),wt=BigInt(4),$t=BigInt(5),Gt=BigInt(8),zr=BigInt(9),Hr=BigInt(16);function T(r,e){let t=r%e;return t>=U?t:e+t}function Tr(r,e,t){if(t<=U||e<U)throw new Error("Expected power/modulo > 0");if(t===L)return U;let n=L;for(;e>U;)e&L&&(n=n*r%t),r=r*r%t,e>>=L;return n}function q(r,e,t){let n=r;for(;e-- >U;)n*=n,n%=t;return n}function tt(r,e){if(r===U||e<=U)throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);let t=T(r,e),n=e,i=U,o=L,c=L,a=U;for(;t!==U;){let f=n/t,b=n%t,l=i-c*f,x=o-a*f;n=t,t=b,i=c,o=a,c=l,a=x}if(n!==L)throw new Error("invert: does not exist");return T(i,e)}function Nr(r){let e=(r-L)/xe,t,n,i;for(t=r-L,n=0;t%xe===U;t/=xe,n++);for(i=xe;i<r&&Tr(i,e,r)!==r-L;i++);if(n===1){let c=(r+L)/wt;return function(s,f){let b=s.pow(f,c);if(!s.eql(s.sqr(b),f))throw new Error("Cannot find square root");return b}}let o=(t+L)/xe;return function(a,s){if(a.pow(s,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let f=n,b=a.pow(a.mul(a.ONE,i),t),l=a.pow(s,o),x=a.pow(s,t);for(;!a.eql(x,a.ONE);){if(a.eql(x,a.ZERO))return a.ZERO;let P=1;for(let u=a.sqr(x);P<f&&!a.eql(u,a.ONE);P++)u=a.sqr(u);let g=a.pow(b,L<<BigInt(f-P-1));b=a.sqr(g),l=a.mul(l,g),x=a.mul(x,b),f=P}return l}}function jr(r){if(r%wt===Ur){let e=(r+L)/wt;return function(n,i){let o=n.pow(i,e);if(!n.eql(n.sqr(o),i))throw new Error("Cannot find square root");return o}}if(r%Gt===$t){let e=(r-$t)/Gt;return function(n,i){let o=n.mul(i,xe),c=n.pow(o,e),a=n.mul(i,c),s=n.mul(n.mul(a,xe),c),f=n.mul(a,n.sub(s,n.ONE));if(!n.eql(n.sqr(f),i))throw new Error("Cannot find square root");return f}}return r%Hr,Nr(r)}var Rr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function pt(r){let e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Rr.reduce((n,i)=>(n[i]="function",n),e);return le(r,t)}function Cr(r,e,t){if(t<U)throw new Error("Expected power > 0");if(t===U)return r.ONE;if(t===L)return e;let n=r.ONE,i=e;for(;t>U;)t&L&&(n=r.mul(n,i)),i=r.sqr(i),t>>=L;return n}function Dr(r,e){let t=new Array(e.length),n=e.reduce((o,c,a)=>r.is0(c)?o:(t[a]=o,r.mul(o,c)),r.ONE),i=r.inv(n);return e.reduceRight((o,c,a)=>r.is0(c)?o:(t[a]=r.mul(o,t[a]),r.mul(o,c)),i),t}function mt(r,e){let t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function Vt(r,e,t=!1,n={}){if(r<=U)throw new Error(`Expected Field ORDER > 0, got ${r}`);let{nBitLength:i,nByteLength:o}=mt(r,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");let c=jr(r),a=Object.freeze({ORDER:r,BITS:i,BYTES:o,MASK:Re(i),ZERO:U,ONE:L,create:s=>T(s,r),isValid:s=>{if(typeof s!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof s}`);return U<=s&&s<r},is0:s=>s===U,isOdd:s=>(s&L)===L,neg:s=>T(-s,r),eql:(s,f)=>s===f,sqr:s=>T(s*s,r),add:(s,f)=>T(s+f,r),sub:(s,f)=>T(s-f,r),mul:(s,f)=>T(s*f,r),pow:(s,f)=>Cr(a,s,f),div:(s,f)=>T(s*tt(f,r),r),sqrN:s=>s*s,addN:(s,f)=>s+f,subN:(s,f)=>s-f,mulN:(s,f)=>s*f,inv:s=>tt(s,r),sqrt:n.sqrt||(s=>c(a,s)),invertBatch:s=>Dr(a,s),cmov:(s,f,b)=>b?f:s,toBytes:s=>t?Fe(s,o):ue(s,o),fromBytes:s=>{if(s.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${s.length}`);return t?Je(s):te(s)}});return Object.freeze(a)}function Zt(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let e=r.toString(2).length;return Math.ceil(e/8)}function gt(r){let e=Zt(r);return e+Math.ceil(e/2)}function Yt(r,e,t=!1){let n=r.length,i=Zt(e),o=gt(e);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);let c=t?te(r):Je(r),a=T(c,e-L)+L;return t?Fe(a,i):ue(a,i)}var Mr=BigInt(0),xt=BigInt(1),_t=new WeakMap,Wt=new WeakMap;function Xt(r,e){let t=(o,c)=>{let a=c.negate();return o?a:c},n=o=>{if(!Number.isSafeInteger(o)||o<=0||o>e)throw new Error(`Wrong window size=${o}, should be [1..${e}]`)},i=o=>{n(o);let c=Math.ceil(e/o)+1,a=2**(o-1);return{windows:c,windowSize:a}};return{constTimeNegate:t,unsafeLadder(o,c){let a=r.ZERO,s=o;for(;c>Mr;)c&xt&&(a=a.add(s)),s=s.double(),c>>=xt;return a},precomputeWindow(o,c){let{windows:a,windowSize:s}=i(c),f=[],b=o,l=b;for(let x=0;x<a;x++){l=b,f.push(l);for(let P=1;P<s;P++)l=l.add(b),f.push(l);b=l.double()}return f},wNAF(o,c,a){let{windows:s,windowSize:f}=i(o),b=r.ZERO,l=r.BASE,x=BigInt(2**o-1),P=2**o,g=BigInt(o);for(let u=0;u<s;u++){let d=u*f,w=Number(a&x);a>>=g,w>f&&(w-=P,a+=xt);let _=d,v=d+Math.abs(w)-1,A=u%2!==0,k=w<0;w===0?l=l.add(t(A,c[_])):b=b.add(t(k,c[v]))}return{p:b,f:l}},wNAFCached(o,c,a){let s=Wt.get(o)||1,f=_t.get(o);return f||(f=this.precomputeWindow(o,s),s!==1&&_t.set(o,a(f))),this.wNAF(s,f,c)},setWindowSize(o,c){n(c),Wt.set(o,c),_t.delete(o)}}}function vt(r){return pt(r.Fp),le(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...mt(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}var ns=new Uint8Array;var is=new Uint8Array([100,107,112,95,112,114,107]),os=new Uint8Array([115,107]);function Qt(r){r.lowS!==void 0&&pe("lowS",r.lowS),r.prehash!==void 0&&pe("prehash",r.prehash)}function Gr(r){let e=vt(r);le(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:t,Fp:n,a:i}=e;if(t){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}var{bytesToNumberBE:Vr,hexToBytes:Zr}=bt,_e={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(r){let{Err:e}=_e;if(r.length<2||r[0]!==2)throw new e("Invalid signature integer tag");let t=r[1],n=r.subarray(2,t+2);if(!t||n.length!==t)throw new e("Invalid signature integer: wrong length");if(n[0]&128)throw new e("Invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Vr(n),l:r.subarray(t+2)}},toSig(r){let{Err:e}=_e,t=typeof r=="string"?Zr(r):r;Oe(t);let n=t.length;if(n<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==n-2)throw new e("Invalid signature: incorrect length");let{d:i,l:o}=_e._parseInt(t.subarray(2)),{d:c,l:a}=_e._parseInt(o);if(a.length)throw new e("Invalid signature: left bytes after parsing");return{r:i,s:c}},hexFromSig(r){let e=f=>Number.parseInt(f[0],16)&8?"00"+f:f,t=f=>{let b=f.toString(16);return b.length&1?`0${b}`:b},n=e(t(r.s)),i=e(t(r.r)),o=n.length/2,c=i.length/2,a=t(o),s=t(c);return`30${t(c+o+4)}02${s}${i}02${a}${n}`}},de=BigInt(0),H=BigInt(1),gs=BigInt(2),Jt=BigInt(3),xs=BigInt(4);function Yr(r){let e=Gr(r),{Fp:t}=e,n=e.toBytes||((g,u,d)=>{let w=u.toAffine();return Le(Uint8Array.from([4]),t.toBytes(w.x),t.toBytes(w.y))}),i=e.fromBytes||(g=>{let u=g.subarray(1),d=t.fromBytes(u.subarray(0,t.BYTES)),w=t.fromBytes(u.subarray(t.BYTES,2*t.BYTES));return{x:d,y:w}});function o(g){let{a:u,b:d}=e,w=t.sqr(g),_=t.mul(w,g);return t.add(t.add(_,t.mul(g,u)),d)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function c(g){return je(g,H,e.n)}function a(g){let{allowedPrivateKeyLengths:u,nByteLength:d,wrapPrivateKey:w,n:_}=e;if(u&&typeof g!="bigint"){if(ce(g)&&(g=me(g)),typeof g!="string"||!u.includes(g.length))throw new Error("Invalid key");g=g.padStart(d*2,"0")}let v;try{v=typeof g=="bigint"?g:te(D("private key",g,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof g}`)}return w&&(v=T(v,_)),fe("private key",v,H,_),v}function s(g){if(!(g instanceof l))throw new Error("ProjectivePoint expected")}let f=et((g,u)=>{let{px:d,py:w,pz:_}=g;if(t.eql(_,t.ONE))return{x:d,y:w};let v=g.is0();u==null&&(u=v?t.ONE:t.inv(_));let A=t.mul(d,u),k=t.mul(w,u),m=t.mul(_,u);if(v)return{x:t.ZERO,y:t.ZERO};if(!t.eql(m,t.ONE))throw new Error("invZ was invalid");return{x:A,y:k}}),b=et(g=>{if(g.is0()){if(e.allowInfinityPoint&&!t.is0(g.py))return;throw new Error("bad point: ZERO")}let{x:u,y:d}=g.toAffine();if(!t.isValid(u)||!t.isValid(d))throw new Error("bad point: x or y not FE");let w=t.sqr(d),_=o(u);if(!t.eql(w,_))throw new Error("bad point: equation left != right");if(!g.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class l{constructor(u,d,w){if(this.px=u,this.py=d,this.pz=w,u==null||!t.isValid(u))throw new Error("x required");if(d==null||!t.isValid(d))throw new Error("y required");if(w==null||!t.isValid(w))throw new Error("z required");Object.freeze(this)}static fromAffine(u){let{x:d,y:w}=u||{};if(!u||!t.isValid(d)||!t.isValid(w))throw new Error("invalid affine point");if(u instanceof l)throw new Error("projective point not allowed");let _=v=>t.eql(v,t.ZERO);return _(d)&&_(w)?l.ZERO:new l(d,w,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){let d=t.invertBatch(u.map(w=>w.pz));return u.map((w,_)=>w.toAffine(d[_])).map(l.fromAffine)}static fromHex(u){let d=l.fromAffine(i(D("pointHex",u)));return d.assertValidity(),d}static fromPrivateKey(u){return l.BASE.multiply(a(u))}_setWindowSize(u){P.setWindowSize(this,u)}assertValidity(){b(this)}hasEvenY(){let{y:u}=this.toAffine();if(t.isOdd)return!t.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){s(u);let{px:d,py:w,pz:_}=this,{px:v,py:A,pz:k}=u,m=t.eql(t.mul(d,k),t.mul(v,_)),E=t.eql(t.mul(w,k),t.mul(A,_));return m&&E}negate(){return new l(this.px,t.neg(this.py),this.pz)}double(){let{a:u,b:d}=e,w=t.mul(d,Jt),{px:_,py:v,pz:A}=this,k=t.ZERO,m=t.ZERO,E=t.ZERO,S=t.mul(_,_),M=t.mul(v,v),O=t.mul(A,A),K=t.mul(_,v);return K=t.add(K,K),E=t.mul(_,A),E=t.add(E,E),k=t.mul(u,E),m=t.mul(w,O),m=t.add(k,m),k=t.sub(M,m),m=t.add(M,m),m=t.mul(k,m),k=t.mul(K,k),E=t.mul(w,E),O=t.mul(u,O),K=t.sub(S,O),K=t.mul(u,K),K=t.add(K,E),E=t.add(S,S),S=t.add(E,S),S=t.add(S,O),S=t.mul(S,K),m=t.add(m,S),O=t.mul(v,A),O=t.add(O,O),S=t.mul(O,K),k=t.sub(k,S),E=t.mul(O,M),E=t.add(E,E),E=t.add(E,E),new l(k,m,E)}add(u){s(u);let{px:d,py:w,pz:_}=this,{px:v,py:A,pz:k}=u,m=t.ZERO,E=t.ZERO,S=t.ZERO,M=e.a,O=t.mul(e.b,Jt),K=t.mul(d,v),R=t.mul(w,A),C=t.mul(_,k),y=t.add(d,w),h=t.add(v,A);y=t.mul(y,h),h=t.add(K,R),y=t.sub(y,h),h=t.add(d,_);let p=t.add(v,k);return h=t.mul(h,p),p=t.add(K,C),h=t.sub(h,p),p=t.add(w,_),m=t.add(A,k),p=t.mul(p,m),m=t.add(R,C),p=t.sub(p,m),S=t.mul(M,h),m=t.mul(O,C),S=t.add(m,S),m=t.sub(R,S),S=t.add(R,S),E=t.mul(m,S),R=t.add(K,K),R=t.add(R,K),C=t.mul(M,C),h=t.mul(O,h),R=t.add(R,C),C=t.sub(K,C),C=t.mul(M,C),h=t.add(h,C),K=t.mul(R,h),E=t.add(E,K),K=t.mul(p,h),m=t.mul(y,m),m=t.sub(m,K),K=t.mul(y,R),S=t.mul(p,S),S=t.add(S,K),new l(m,E,S)}subtract(u){return this.add(u.negate())}is0(){return this.equals(l.ZERO)}wNAF(u){return P.wNAFCached(this,u,l.normalizeZ)}multiplyUnsafe(u){fe("scalar",u,de,e.n);let d=l.ZERO;if(u===de)return d;if(u===H)return this;let{endo:w}=e;if(!w)return P.unsafeLadder(this,u);let{k1neg:_,k1:v,k2neg:A,k2:k}=w.splitScalar(u),m=d,E=d,S=this;for(;v>de||k>de;)v&H&&(m=m.add(S)),k&H&&(E=E.add(S)),S=S.double(),v>>=H,k>>=H;return _&&(m=m.negate()),A&&(E=E.negate()),E=new l(t.mul(E.px,w.beta),E.py,E.pz),m.add(E)}multiply(u){let{endo:d,n:w}=e;fe("scalar",u,H,w);let _,v;if(d){let{k1neg:A,k1:k,k2neg:m,k2:E}=d.splitScalar(u),{p:S,f:M}=this.wNAF(k),{p:O,f:K}=this.wNAF(E);S=P.constTimeNegate(A,S),O=P.constTimeNegate(m,O),O=new l(t.mul(O.px,d.beta),O.py,O.pz),_=S.add(O),v=M.add(K)}else{let{p:A,f:k}=this.wNAF(u);_=A,v=k}return l.normalizeZ([_,v])[0]}multiplyAndAddUnsafe(u,d,w){let _=l.BASE,v=(k,m)=>m===de||m===H||!k.equals(_)?k.multiplyUnsafe(m):k.multiply(m),A=v(this,d).add(v(u,w));return A.is0()?void 0:A}toAffine(u){return f(this,u)}isTorsionFree(){let{h:u,isTorsionFree:d}=e;if(u===H)return!0;if(d)return d(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:u,clearCofactor:d}=e;return u===H?this:d?d(l,this):this.multiplyUnsafe(e.h)}toRawBytes(u=!0){return pe("isCompressed",u),this.assertValidity(),n(l,this,u)}toHex(u=!0){return pe("isCompressed",u),me(this.toRawBytes(u))}}l.BASE=new l(e.Gx,e.Gy,t.ONE),l.ZERO=new l(t.ZERO,t.ONE,t.ZERO);let x=e.nBitLength,P=Xt(l,e.endo?Math.ceil(x/2):x);return{CURVE:e,ProjectivePoint:l,normPrivateKeyToScalar:a,weierstrassEquation:o,isWithinCurveOrder:c}}function Wr(r){let e=vt(r);return le(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Ft(r){let e=Wr(r),{Fp:t,n}=e,i=t.BYTES+1,o=2*t.BYTES+1;function c(y){return T(y,n)}function a(y){return tt(y,n)}let{ProjectivePoint:s,normPrivateKeyToScalar:f,weierstrassEquation:b,isWithinCurveOrder:l}=Yr({...e,toBytes(y,h,p){let I=h.toAffine(),B=t.toBytes(I.x),z=Le;return pe("isCompressed",p),p?z(Uint8Array.from([h.hasEvenY()?2:3]),B):z(Uint8Array.from([4]),B,t.toBytes(I.y))},fromBytes(y){let h=y.length,p=y[0],I=y.subarray(1);if(h===i&&(p===2||p===3)){let B=te(I);if(!je(B,H,t.ORDER))throw new Error("Point is not on curve");let z=b(B),N;try{N=t.sqrt(z)}catch($){let ne=$ instanceof Error?": "+$.message:"";throw new Error("Point is not on curve"+ne)}let j=(N&H)===H;return(p&1)===1!==j&&(N=t.neg(N)),{x:B,y:N}}else if(h===o&&p===4){let B=t.fromBytes(I.subarray(0,t.BYTES)),z=t.fromBytes(I.subarray(t.BYTES,2*t.BYTES));return{x:B,y:z}}else throw new Error(`Point of length ${h} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}}),x=y=>me(ue(y,e.nByteLength));function P(y){let h=n>>H;return y>h}function g(y){return P(y)?c(-y):y}let u=(y,h,p)=>te(y.slice(h,p));class d{constructor(h,p,I){this.r=h,this.s=p,this.recovery=I,this.assertValidity()}static fromCompact(h){let p=e.nByteLength;return h=D("compactSignature",h,p*2),new d(u(h,0,p),u(h,p,2*p))}static fromDER(h){let{r:p,s:I}=_e.toSig(D("DER",h));return new d(p,I)}assertValidity(){fe("r",this.r,H,n),fe("s",this.s,H,n)}addRecoveryBit(h){return new d(this.r,this.s,h)}recoverPublicKey(h){let{r:p,s:I,recovery:B}=this,z=m(D("msgHash",h));if(B==null||![0,1,2,3].includes(B))throw new Error("recovery id invalid");let N=B===2||B===3?p+e.n:p;if(N>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");let j=B&1?"03":"02",re=s.fromHex(j+x(N)),$=a(N),ne=c(-z*$),Ue=c(I*$),ie=s.BASE.multiplyAndAddUnsafe(re,ne,Ue);if(!ie)throw new Error("point at infinify");return ie.assertValidity(),ie}hasHighS(){return P(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return ge(this.toDERHex())}toDERHex(){return _e.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ge(this.toCompactHex())}toCompactHex(){return x(this.r)+x(this.s)}}let w={isValidPrivateKey(y){try{return f(y),!0}catch{return!1}},normPrivateKeyToScalar:f,randomPrivateKey:()=>{let y=gt(e.n);return Yt(e.randomBytes(y),e.n)},precompute(y=8,h=s.BASE){return h._setWindowSize(y),h.multiply(BigInt(3)),h}};function _(y,h=!0){return s.fromPrivateKey(y).toRawBytes(h)}function v(y){let h=ce(y),p=typeof y=="string",I=(h||p)&&y.length;return h?I===i||I===o:p?I===2*i||I===2*o:y instanceof s}function A(y,h,p=!0){if(v(y))throw new Error("first arg must be private key");if(!v(h))throw new Error("second arg must be public key");return s.fromHex(h).multiply(f(y)).toRawBytes(p)}let k=e.bits2int||function(y){let h=te(y),p=y.length*8-e.nBitLength;return p>0?h>>BigInt(p):h},m=e.bits2int_modN||function(y){return c(k(y))},E=Re(e.nBitLength);function S(y){return fe(`num < 2^${e.nBitLength}`,y,de,E),ue(y,e.nByteLength)}function M(y,h,p=O){if(["recovered","canonical"].some(he=>he in p))throw new Error("sign() legacy options not supported");let{hash:I,randomBytes:B}=e,{lowS:z,prehash:N,extraEntropy:j}=p;z==null&&(z=!0),y=D("msgHash",y),Qt(p),N&&(y=D("prehashed msgHash",I(y)));let re=m(y),$=f(h),ne=[S($),S(re)];if(j!=null&&j!==!1){let he=j===!0?B(t.BYTES):j;ne.push(D("extraEntropy",he))}let Ue=Le(...ne),ie=re;function it(he){let ve=k(he);if(!l(ve))return;let At=a(ve),Y=s.BASE.multiply(ve).toAffine(),Ee=c(Y.x);if(Ee===de)return;let De=c(At*c(ie+Ee*$));if(De===de)return;let Kt=(Y.x===Ee?0:2)|Number(Y.y&H),Bt=De;return z&&P(De)&&(Bt=g(De),Kt^=1),new d(Ee,Bt,Kt)}return{seed:Ue,k2sig:it}}let O={lowS:e.lowS,prehash:!1},K={lowS:e.lowS,prehash:!1};function R(y,h,p=O){let{seed:I,k2sig:B}=M(y,h,p),z=e;return yt(z.hash.outputLen,z.nByteLength,z.hmac)(I,B)}s.BASE._setWindowSize(8);function C(y,h,p,I=K){let B=y;if(h=D("msgHash",h),p=D("publicKey",p),"strict"in I)throw new Error("options.strict was renamed to lowS");Qt(I);let{lowS:z,prehash:N}=I,j,re;try{if(typeof B=="string"||ce(B))try{j=d.fromDER(B)}catch(Y){if(!(Y instanceof _e.Err))throw Y;j=d.fromCompact(B)}else if(typeof B=="object"&&typeof B.r=="bigint"&&typeof B.s=="bigint"){let{r:Y,s:Ee}=B;j=new d(Y,Ee)}else throw new Error("PARSE");re=s.fromHex(p)}catch(Y){if(Y.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(z&&j.hasHighS())return!1;N&&(h=e.hash(h));let{r:$,s:ne}=j,Ue=m(h),ie=a(ne),it=c(Ue*ie),he=c($*ie),ve=s.BASE.multiplyAndAddUnsafe(re,it,he)?.toAffine();return ve?c(ve.x)===$:!1}return{CURVE:e,getPublicKey:_,getSharedSecret:A,sign:R,verify:C,ProjectivePoint:s,Signature:d,utils:w}}function Xr(r){return{hash:r,hmac:(e,...t)=>Ne(r,e,Tt(...t)),randomBytes:jt}}function er(r,e){let t=n=>Ft({...r,...Xr(n)});return Object.freeze({...t(e),create:t})}var nr=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),tr=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Qr=BigInt(1),Et=BigInt(2),rr=(r,e)=>(r+e/Et)/e;function Jr(r){let e=nr,t=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),c=BigInt(23),a=BigInt(44),s=BigInt(88),f=r*r*r%e,b=f*f*r%e,l=q(b,t,e)*b%e,x=q(l,t,e)*b%e,P=q(x,Et,e)*f%e,g=q(P,i,e)*P%e,u=q(g,o,e)*g%e,d=q(u,a,e)*u%e,w=q(d,s,e)*d%e,_=q(w,a,e)*u%e,v=q(_,t,e)*b%e,A=q(v,c,e)*g%e,k=q(A,n,e)*f%e,m=q(k,Et,e);if(!kt.eql(kt.sqr(m),r))throw new Error("Cannot find square root");return m}var kt=Vt(nr,void 0,void 0,{sqrt:Jr}),Ce=er({a:BigInt(0),b:BigInt(7),Fp:kt,n:tr,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{let e=tr,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Qr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,c=BigInt("0x100000000000000000000000000000000"),a=rr(o*r,e),s=rr(-n*r,e),f=T(r-a*t-s*i,e),b=T(-a*n-s*o,e),l=f>c,x=b>c;if(l&&(f=e-f),x&&(b=e-b),f>c||b>c)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:l,k1:f,k2neg:x,k2:b}}}},Xe),Bs=BigInt(0);var Is=Ce.ProjectivePoint;var rt="ECDH",ir=new Uint8Array,St=["deriveBits"],Fr=new Uint8Array([100,107,112,95,112,114,107]),en=new Uint8Array([115,107]),nt=class{constructor(e){Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=e,this._nPk=33,this._nSk=32}async serializePublicKey(e){try{return await this._serializePublicKey(e)}catch(t){throw new F(t)}}async deserializePublicKey(e){try{return await this._importRawKey(e,!0)}catch(t){throw new W(t)}}async serializePrivateKey(e){try{return await this._serializePrivateKey(e)}catch(t){throw new F(t)}}async deserializePrivateKey(e){try{return await this._importRawKey(e,!1)}catch(t){throw new W(t)}}async importKey(e,t,n){try{if(e!=="raw")throw new Error("Unsupported format");return await this._importRawKey(t,n)}catch(i){throw new W(i)}}async generateKeyPair(){try{let e=Ce.utils.randomPrivateKey(),t=new X(rt,e,"private",St);return{publicKey:await this.derivePublicKey(t),privateKey:t}}catch(e){throw new G(e)}}async deriveKeyPair(e){try{let t=await this._hkdf.labeledExtract(ir,Fr,new Uint8Array(e)),n=await this._hkdf.labeledExpand(t,en,ir,this._nSk),i=new X(rt,new Uint8Array(n),"private",St);return{privateKey:i,publicKey:await this.derivePublicKey(i)}}catch(t){throw new ke(t)}}async derivePublicKey(e){try{return await this._derivePublicKey(e)}catch(t){throw new W(t)}}async dh(e,t){try{return await this._dh(e,t)}catch(n){throw new F(n)}}_serializePublicKey(e){return new Promise(t=>{t(e.key.buffer)})}_serializePrivateKey(e){return new Promise(t=>{t(e.key.buffer)})}_importRawKey(e,t){return new Promise((n,i)=>{t&&e.byteLength!==this._nPk&&i(new Error("Invalid length of the key")),!t&&e.byteLength!==this._nSk&&i(new Error("Invalid length of the key")),n(new X(rt,new Uint8Array(e),t?"public":"private",t?[]:St))})}_derivePublicKey(e){return new Promise((t,n)=>{try{let i=Ce.getPublicKey(e.key);t(new X(rt,i,"public"))}catch(i){n(i)}})}_dh(e,t){return new Promise((n,i)=>{try{n(Ce.getSharedSecret(e.key,t.key).buffer)}catch(o){i(o)}})}};var Pt=class extends we{constructor(){let e=new Ie;super(oe.DhkemSecp256k1HkdfSha256,new nt(e),e),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:oe.DhkemSecp256k1HkdfSha256}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:32})}};export{Pt as DhkemSecp256k1HkdfSha256};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
