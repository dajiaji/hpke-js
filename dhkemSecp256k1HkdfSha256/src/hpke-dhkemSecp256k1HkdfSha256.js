var nr=Object.defineProperty;var ir=(r,t)=>{for(var e in t)nr(r,e,{get:t[e],enumerable:!0})};function ne(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`Wrong positive integer: ${r}`)}function or(r){if(typeof r!="boolean")throw new Error(`Expected boolean, not ${r}`)}function Ue(r,...t){if(!(r instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(r.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${r.length}`)}function sr(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ne(r.outputLen),ne(r.blockLen)}function cr(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function ar(r,t){Ue(r);let e=t.outputLen;if(r.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}var fr={number:ne,bool:or,bytes:Ue,hash:sr,exists:cr,output:ar},W=fr;var Ot=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var Pe=r=>r instanceof Uint8Array;var Tt=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),V=(r,t)=>r<<32-t|r>>>t,ur=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!ur)throw new Error("Non little-endian hardware is not supported");var vn=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function lr(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function _t(r){if(typeof r=="string"&&(r=lr(r)),!Pe(r))throw new Error(`expected Uint8Array, got ${typeof r}`);return r}function He(...r){let t=new Uint8Array(r.reduce((n,i)=>n+i.length,0)),e=0;return r.forEach(n=>{if(!Pe(n))throw new Error("Uint8Array expected");t.set(n,e),e+=n.length}),t}var mt=class{clone(){return this._cloneInto()}};function nt(r){let t=n=>r().update(_t(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function ie(r=32){if(Ot&&typeof Ot.getRandomValues=="function")return Ot.getRandomValues(new Uint8Array(r));throw new Error("crypto.getRandomValues must be defined")}function hr(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);let i=BigInt(32),o=BigInt(4294967295),a=Number(e>>i&o),s=Number(e&o),c=n?4:0,f=n?0:4;r.setUint32(t+c,a,n),r.setUint32(t+f,s,n)}var Et=class extends mt{constructor(t,e,n,i){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Tt(this.buffer)}update(t){W.exists(this);let{view:e,buffer:n,blockLen:i}=this;t=_t(t);let o=t.length;for(let a=0;a<o;){let s=Math.min(i-this.pos,o-a);if(s===i){let c=Tt(t);for(;i<=o-a;a+=i)this.process(c,a);continue}n.set(t.subarray(a,a+s),this.pos),this.pos+=s,a+=s,this.pos===i&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){W.exists(this),W.output(t,this),this.finished=!0;let{buffer:e,view:n,blockLen:i,isLE:o}=this,{pos:a}=this;e[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>i-a&&(this.process(n,0),a=0);for(let u=a;u<i;u++)e[u]=0;hr(n,i-8,BigInt(this.length*8),o),this.process(n,0);let s=Tt(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=c/4,x=this.get();if(f>x.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)s.setUint32(4*u,x[u],o)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:n,length:i,finished:o,destroyed:a,pos:s}=this;return t.length=i,t.pos=s,t.finished=o,t.destroyed=a,i%e&&t.buffer.set(n),t}};var dr=(r,t,e)=>r&t^~r&e,xr=(r,t,e)=>r&t^r&e^t&e,br=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),it=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ot=new Uint32Array(64),Nt=class extends Et{constructor(){super(64,32,8,!1),this.A=it[0]|0,this.B=it[1]|0,this.C=it[2]|0,this.D=it[3]|0,this.E=it[4]|0,this.F=it[5]|0,this.G=it[6]|0,this.H=it[7]|0}get(){let{A:t,B:e,C:n,D:i,E:o,F:a,G:s,H:c}=this;return[t,e,n,i,o,a,s,c]}set(t,e,n,i,o,a,s,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=i|0,this.E=o|0,this.F=a|0,this.G=s|0,this.H=c|0}process(t,e){for(let u=0;u<16;u++,e+=4)ot[u]=t.getUint32(e,!1);for(let u=16;u<64;u++){let p=ot[u-15],v=ot[u-2],g=V(p,7)^V(p,18)^p>>>3,l=V(v,17)^V(v,19)^v>>>10;ot[u]=l+ot[u-7]+g+ot[u-16]|0}let{A:n,B:i,C:o,D:a,E:s,F:c,G:f,H:x}=this;for(let u=0;u<64;u++){let p=V(s,6)^V(s,11)^V(s,25),v=x+p+dr(s,c,f)+br[u]+ot[u]|0,l=(V(n,2)^V(n,13)^V(n,22))+xr(n,i,o)|0;x=f,f=c,c=s,s=a+v|0,a=o,o=i,i=n,n=v+l|0}n=n+this.A|0,i=i+this.B|0,o=o+this.C|0,a=a+this.D|0,s=s+this.E|0,c=c+this.F|0,f=f+this.G|0,x=x+this.H|0,this.set(n,i,o,a,s,c,f,x)}roundClean(){ot.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}},oe=class extends Nt{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}},Ct=nt(()=>new Nt),Kn=nt(()=>new oe);var ue={};ir(ue,{bitGet:()=>Er,bitLen:()=>mr,bitMask:()=>It,bitSet:()=>Ar,bytesToHex:()=>ht,bytesToNumberBE:()=>$,bytesToNumberLE:()=>qt,concatBytes:()=>st,createHmacDrbg:()=>fe,ensureBytes:()=>q,equalBytes:()=>gr,hexToBytes:()=>dt,hexToNumber:()=>ce,numberToBytesBE:()=>X,numberToBytesLE:()=>ae,numberToHexUnpadded:()=>Oe,numberToVarBytesBE:()=>wr,utf8ToBytes:()=>Te,validateObject:()=>Q});var ke=BigInt(0),Rt=BigInt(1),yr=BigInt(2),Dt=r=>r instanceof Uint8Array,pr=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function ht(r){if(!Dt(r))throw new Error("Uint8Array expected");let t="";for(let e=0;e<r.length;e++)t+=pr[r[e]];return t}function Oe(r){let t=r.toString(16);return t.length&1?`0${t}`:t}function ce(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}function dt(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let t=r.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);let e=new Uint8Array(t/2);for(let n=0;n<e.length;n++){let i=n*2,o=r.slice(i,i+2),a=Number.parseInt(o,16);if(Number.isNaN(a)||a<0)throw new Error("Invalid byte sequence");e[n]=a}return e}function $(r){return ce(ht(r))}function qt(r){if(!Dt(r))throw new Error("Uint8Array expected");return ce(ht(Uint8Array.from(r).reverse()))}function X(r,t){return dt(r.toString(16).padStart(t*2,"0"))}function ae(r,t){return X(r,t).reverse()}function wr(r){return dt(Oe(r))}function q(r,t,e){let n;if(typeof t=="string")try{n=dt(t)}catch(o){throw new Error(`${r} must be valid hex string, got "${t}". Cause: ${o}`)}else if(Dt(t))n=Uint8Array.from(t);else throw new Error(`${r} must be hex string or Uint8Array`);let i=n.length;if(typeof e=="number"&&i!==e)throw new Error(`${r} expected ${e} bytes, got ${i}`);return n}function st(...r){let t=new Uint8Array(r.reduce((n,i)=>n+i.length,0)),e=0;return r.forEach(n=>{if(!Dt(n))throw new Error("Uint8Array expected");t.set(n,e),e+=n.length}),t}function gr(r,t){if(r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}function Te(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function mr(r){let t;for(t=0;r>ke;r>>=Rt,t+=1);return t}function Er(r,t){return r>>BigInt(t)&Rt}var Ar=(r,t,e)=>r|(e?Rt:ke)<<BigInt(t),It=r=>(yr<<BigInt(r-1))-Rt,se=r=>new Uint8Array(r),Ke=r=>Uint8Array.from(r);function fe(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=se(r),i=se(r),o=0,a=()=>{n.fill(1),i.fill(0),o=0},s=(...u)=>e(i,n,...u),c=(u=se())=>{i=s(Ke([0]),u),n=s(),u.length!==0&&(i=s(Ke([1]),u),n=s())},f=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let u=0,p=[];for(;u<t;){n=s();let v=n.slice();p.push(v),u+=n.length}return st(...p)};return(u,p)=>{a(),c(u);let v;for(;!(v=p(f()));)c();return a(),v}}var Br={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Q(r,t,e={}){let n=(i,o,a)=>{let s=Br[o];if(typeof s!="function")throw new Error(`Invalid validator "${o}", expected function`);let c=r[i];if(!(a&&c===void 0)&&!s(c,r))throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${o}`)};for(let[i,o]of Object.entries(t))n(i,o,!1);for(let[i,o]of Object.entries(e))n(i,o,!0);return r}var T=BigInt(0),O=BigInt(1),xt=BigInt(2),Sr=BigInt(3),le=BigInt(4),Ne=BigInt(5),Ce=BigInt(8),vr=BigInt(9),_r=BigInt(16);function D(r,t){let e=r%t;return e>=T?e:t+e}function Ir(r,t,e){if(e<=T||t<T)throw new Error("Expected power/modulo > 0");if(e===O)return T;let n=O;for(;t>T;)t&O&&(n=n*r%e),r=r*r%e,t>>=O;return n}function G(r,t,e){let n=r;for(;t-- >T;)n*=n,n%=e;return n}function zt(r,t){if(r===T||t<=T)throw new Error(`invert: expected positive integers, got n=${r} mod=${t}`);let e=D(r,t),n=t,i=T,o=O,a=O,s=T;for(;e!==T;){let f=n/e,x=n%e,u=i-a*f,p=o-s*f;n=e,e=x,i=a,o=s,a=u,s=p}if(n!==O)throw new Error("invert: does not exist");return D(i,t)}function Lr(r){let t=(r-O)/xt,e,n,i;for(e=r-O,n=0;e%xt===T;e/=xt,n++);for(i=xt;i<r&&Ir(i,t,r)!==r-O;i++);if(n===1){let a=(r+O)/le;return function(c,f){let x=c.pow(f,a);if(!c.eql(c.sqr(x),f))throw new Error("Cannot find square root");return x}}let o=(e+O)/xt;return function(s,c){if(s.pow(c,t)===s.neg(s.ONE))throw new Error("Cannot find square root");let f=n,x=s.pow(s.mul(s.ONE,i),e),u=s.pow(c,o),p=s.pow(c,e);for(;!s.eql(p,s.ONE);){if(s.eql(p,s.ZERO))return s.ZERO;let v=1;for(let l=s.sqr(p);v<f&&!s.eql(l,s.ONE);v++)l=s.sqr(l);let g=s.pow(x,O<<BigInt(f-v-1));x=s.sqr(g),u=s.mul(u,g),p=s.mul(p,x),f=v}return u}}function Ur(r){if(r%le===Sr){let t=(r+O)/le;return function(n,i){let o=n.pow(i,t);if(!n.eql(n.sqr(o),i))throw new Error("Cannot find square root");return o}}if(r%Ce===Ne){let t=(r-Ne)/Ce;return function(n,i){let o=n.mul(i,xt),a=n.pow(o,t),s=n.mul(i,a),c=n.mul(n.mul(s,xt),a),f=n.mul(s,n.sub(c,n.ONE));if(!n.eql(n.sqr(f),i))throw new Error("Cannot find square root");return f}}return r%_r,Lr(r)}var Pr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function he(r){let t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Pr.reduce((n,i)=>(n[i]="function",n),t);return Q(r,e)}function Hr(r,t,e){if(e<T)throw new Error("Expected power > 0");if(e===T)return r.ONE;if(e===O)return t;let n=r.ONE,i=t;for(;e>T;)e&O&&(n=r.mul(n,i)),i=r.sqr(i),e>>=O;return n}function Kr(r,t){let e=new Array(t.length),n=t.reduce((o,a,s)=>r.is0(a)?o:(e[s]=o,r.mul(o,a)),r.ONE),i=r.inv(n);return t.reduceRight((o,a,s)=>r.is0(a)?o:(e[s]=r.mul(o,e[s]),r.mul(o,a)),i),e}function jt(r,t){let e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function Re(r,t,e=!1,n={}){if(r<=T)throw new Error(`Expected Fp ORDER > 0, got ${r}`);let{nBitLength:i,nByteLength:o}=jt(r,t);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");let a=Ur(r),s=Object.freeze({ORDER:r,BITS:i,BYTES:o,MASK:It(i),ZERO:T,ONE:O,create:c=>D(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return T<=c&&c<r},is0:c=>c===T,isOdd:c=>(c&O)===O,neg:c=>D(-c,r),eql:(c,f)=>c===f,sqr:c=>D(c*c,r),add:(c,f)=>D(c+f,r),sub:(c,f)=>D(c-f,r),mul:(c,f)=>D(c*f,r),pow:(c,f)=>Hr(s,c,f),div:(c,f)=>D(c*zt(f,r),r),sqrN:c=>c*c,addN:(c,f)=>c+f,subN:(c,f)=>c-f,mulN:(c,f)=>c*f,inv:c=>zt(c,r),sqrt:n.sqrt||(c=>a(s,c)),invertBatch:c=>Kr(s,c),cmov:(c,f,x)=>x?f:c,toBytes:c=>e?ae(c,o):X(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return e?qt(c):$(c)}});return Object.freeze(s)}function De(r,t,e=!1){r=q("privateHash",r);let n=r.length,i=jt(t).nByteLength+8;if(i<24||n<i||n>1024)throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${n}`);let o=e?qt(r):$(r);return D(o,t-O)+O}var Or=BigInt(0),de=BigInt(1);function qe(r,t){let e=(i,o)=>{let a=o.negate();return i?a:o},n=i=>{let o=Math.ceil(t/i)+1,a=2**(i-1);return{windows:o,windowSize:a}};return{constTimeNegate:e,unsafeLadder(i,o){let a=r.ZERO,s=i;for(;o>Or;)o&de&&(a=a.add(s)),s=s.double(),o>>=de;return a},precomputeWindow(i,o){let{windows:a,windowSize:s}=n(o),c=[],f=i,x=f;for(let u=0;u<a;u++){x=f,c.push(x);for(let p=1;p<s;p++)x=x.add(f),c.push(x);f=x.double()}return c},wNAF(i,o,a){let{windows:s,windowSize:c}=n(i),f=r.ZERO,x=r.BASE,u=BigInt(2**i-1),p=2**i,v=BigInt(i);for(let g=0;g<s;g++){let l=g*c,d=Number(a&u);a>>=v,d>c&&(d-=p,a+=de);let b=l,E=l+Math.abs(d)-1,y=g%2!==0,I=d<0;d===0?x=x.add(e(y,o[b])):f=f.add(e(I,o[E]))}return{p:f,f:x}},wNAFCached(i,o,a,s){let c=i._WINDOW_SIZE||1,f=o.get(i);return f||(f=this.precomputeWindow(i,c),c!==1&&o.set(i,s(f))),this.wNAF(c,f,a)}}}function xe(r){return he(r.Fp),Q(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...jt(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}function Tr(r){let t=xe(r);Q(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:e,Fp:n,a:i}=t;if(e){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}var{bytesToNumberBE:Nr,hexToBytes:Cr}=ue,bt={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(r){let{Err:t}=bt;if(r.length<2||r[0]!==2)throw new t("Invalid signature integer tag");let e=r[1],n=r.subarray(2,e+2);if(!e||n.length!==e)throw new t("Invalid signature integer: wrong length");if(n[0]&128)throw new t("Invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:Nr(n),l:r.subarray(e+2)}},toSig(r){let{Err:t}=bt,e=typeof r=="string"?Cr(r):r;if(!(e instanceof Uint8Array))throw new Error("ui8a expected");let n=e.length;if(n<2||e[0]!=48)throw new t("Invalid signature tag");if(e[1]!==n-2)throw new t("Invalid signature: incorrect length");let{d:i,l:o}=bt._parseInt(e.subarray(2)),{d:a,l:s}=bt._parseInt(o);if(s.length)throw new t("Invalid signature: left bytes after parsing");return{r:i,s:a}},hexFromSig(r){let t=f=>Number.parseInt(f[0],16)&8?"00"+f:f,e=f=>{let x=f.toString(16);return x.length&1?`0${x}`:x},n=t(e(r.s)),i=t(e(r.r)),o=n.length/2,a=i.length/2,s=e(o),c=e(a);return`30${e(a+o+4)}02${c}${i}02${s}${n}`}},J=BigInt(0),M=BigInt(1),zn=BigInt(2),ze=BigInt(3),jn=BigInt(4);function Rr(r){let t=Tr(r),{Fp:e}=t,n=t.toBytes||((g,l,d)=>{let b=l.toAffine();return st(Uint8Array.from([4]),e.toBytes(b.x),e.toBytes(b.y))}),i=t.fromBytes||(g=>{let l=g.subarray(1),d=e.fromBytes(l.subarray(0,e.BYTES)),b=e.fromBytes(l.subarray(e.BYTES,2*e.BYTES));return{x:d,y:b}});function o(g){let{a:l,b:d}=t,b=e.sqr(g),E=e.mul(b,g);return e.add(e.add(E,e.mul(g,l)),d)}if(!e.eql(e.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function a(g){return typeof g=="bigint"&&J<g&&g<t.n}function s(g){if(!a(g))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(g){let{allowedPrivateKeyLengths:l,nByteLength:d,wrapPrivateKey:b,n:E}=t;if(l&&typeof g!="bigint"){if(g instanceof Uint8Array&&(g=ht(g)),typeof g!="string"||!l.includes(g.length))throw new Error("Invalid key");g=g.padStart(d*2,"0")}let y;try{y=typeof g=="bigint"?g:$(q("private key",g,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof g}`)}return b&&(y=D(y,E)),s(y),y}let f=new Map;function x(g){if(!(g instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(l,d,b){if(this.px=l,this.py=d,this.pz=b,l==null||!e.isValid(l))throw new Error("x required");if(d==null||!e.isValid(d))throw new Error("y required");if(b==null||!e.isValid(b))throw new Error("z required")}static fromAffine(l){let{x:d,y:b}=l||{};if(!l||!e.isValid(d)||!e.isValid(b))throw new Error("invalid affine point");if(l instanceof u)throw new Error("projective point not allowed");let E=y=>e.eql(y,e.ZERO);return E(d)&&E(b)?u.ZERO:new u(d,b,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){let d=e.invertBatch(l.map(b=>b.pz));return l.map((b,E)=>b.toAffine(d[E])).map(u.fromAffine)}static fromHex(l){let d=u.fromAffine(i(q("pointHex",l)));return d.assertValidity(),d}static fromPrivateKey(l){return u.BASE.multiply(c(l))}_setWindowSize(l){this._WINDOW_SIZE=l,f.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint)return;throw new Error("bad point: ZERO")}let{x:l,y:d}=this.toAffine();if(!e.isValid(l)||!e.isValid(d))throw new Error("bad point: x or y not FE");let b=e.sqr(d),E=o(l);if(!e.eql(b,E))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){let{y:l}=this.toAffine();if(e.isOdd)return!e.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){x(l);let{px:d,py:b,pz:E}=this,{px:y,py:I,pz:S}=l,m=e.eql(e.mul(d,S),e.mul(y,E)),B=e.eql(e.mul(b,S),e.mul(I,E));return m&&B}negate(){return new u(this.px,e.neg(this.py),this.pz)}double(){let{a:l,b:d}=t,b=e.mul(d,ze),{px:E,py:y,pz:I}=this,S=e.ZERO,m=e.ZERO,B=e.ZERO,A=e.mul(E,E),k=e.mul(y,y),P=e.mul(I,I),U=e.mul(E,y);return U=e.add(U,U),B=e.mul(E,I),B=e.add(B,B),S=e.mul(l,B),m=e.mul(b,P),m=e.add(S,m),S=e.sub(k,m),m=e.add(k,m),m=e.mul(S,m),S=e.mul(U,S),B=e.mul(b,B),P=e.mul(l,P),U=e.sub(A,P),U=e.mul(l,U),U=e.add(U,B),B=e.add(A,A),A=e.add(B,A),A=e.add(A,P),A=e.mul(A,U),m=e.add(m,A),P=e.mul(y,I),P=e.add(P,P),A=e.mul(P,U),S=e.sub(S,A),B=e.mul(P,k),B=e.add(B,B),B=e.add(B,B),new u(S,m,B)}add(l){x(l);let{px:d,py:b,pz:E}=this,{px:y,py:I,pz:S}=l,m=e.ZERO,B=e.ZERO,A=e.ZERO,k=t.a,P=e.mul(t.b,ze),U=e.mul(d,y),N=e.mul(b,I),R=e.mul(E,S),Z=e.add(d,b),h=e.add(y,I);Z=e.mul(Z,h),h=e.add(U,N),Z=e.sub(Z,h),h=e.add(d,E);let w=e.add(y,S);return h=e.mul(h,w),w=e.add(U,R),h=e.sub(h,w),w=e.add(b,E),m=e.add(I,S),w=e.mul(w,m),m=e.add(N,R),w=e.sub(w,m),A=e.mul(k,h),m=e.mul(P,R),A=e.add(m,A),m=e.sub(N,A),A=e.add(N,A),B=e.mul(m,A),N=e.add(U,U),N=e.add(N,U),R=e.mul(k,R),h=e.mul(P,h),N=e.add(N,R),R=e.sub(U,R),R=e.mul(k,R),h=e.add(h,R),U=e.mul(N,h),B=e.add(B,U),U=e.mul(w,h),m=e.mul(Z,m),m=e.sub(m,U),U=e.mul(Z,N),A=e.mul(w,A),A=e.add(A,U),new u(m,B,A)}subtract(l){return this.add(l.negate())}is0(){return this.equals(u.ZERO)}wNAF(l){return v.wNAFCached(this,f,l,d=>{let b=e.invertBatch(d.map(E=>E.pz));return d.map((E,y)=>E.toAffine(b[y])).map(u.fromAffine)})}multiplyUnsafe(l){let d=u.ZERO;if(l===J)return d;if(s(l),l===M)return this;let{endo:b}=t;if(!b)return v.unsafeLadder(this,l);let{k1neg:E,k1:y,k2neg:I,k2:S}=b.splitScalar(l),m=d,B=d,A=this;for(;y>J||S>J;)y&M&&(m=m.add(A)),S&M&&(B=B.add(A)),A=A.double(),y>>=M,S>>=M;return E&&(m=m.negate()),I&&(B=B.negate()),B=new u(e.mul(B.px,b.beta),B.py,B.pz),m.add(B)}multiply(l){s(l);let d=l,b,E,{endo:y}=t;if(y){let{k1neg:I,k1:S,k2neg:m,k2:B}=y.splitScalar(d),{p:A,f:k}=this.wNAF(S),{p:P,f:U}=this.wNAF(B);A=v.constTimeNegate(I,A),P=v.constTimeNegate(m,P),P=new u(e.mul(P.px,y.beta),P.py,P.pz),b=A.add(P),E=k.add(U)}else{let{p:I,f:S}=this.wNAF(d);b=I,E=S}return u.normalizeZ([b,E])[0]}multiplyAndAddUnsafe(l,d,b){let E=u.BASE,y=(S,m)=>m===J||m===M||!S.equals(E)?S.multiplyUnsafe(m):S.multiply(m),I=y(this,d).add(y(l,b));return I.is0()?void 0:I}toAffine(l){let{px:d,py:b,pz:E}=this,y=this.is0();l==null&&(l=y?e.ONE:e.inv(E));let I=e.mul(d,l),S=e.mul(b,l),m=e.mul(E,l);if(y)return{x:e.ZERO,y:e.ZERO};if(!e.eql(m,e.ONE))throw new Error("invZ was invalid");return{x:I,y:S}}isTorsionFree(){let{h:l,isTorsionFree:d}=t;if(l===M)return!0;if(d)return d(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:l,clearCofactor:d}=t;return l===M?this:d?d(u,this):this.multiplyUnsafe(t.h)}toRawBytes(l=!0){return this.assertValidity(),n(u,this,l)}toHex(l=!0){return ht(this.toRawBytes(l))}}u.BASE=new u(t.Gx,t.Gy,e.ONE),u.ZERO=new u(e.ZERO,e.ONE,e.ZERO);let p=t.nBitLength,v=qe(u,t.endo?Math.ceil(p/2):p);return{CURVE:t,ProjectivePoint:u,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:a}}function Dr(r){let t=xe(r);return Q(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function je(r){let t=Dr(r),{Fp:e,n}=t,i=e.BYTES+1,o=2*e.BYTES+1;function a(h){return J<h&&h<e.ORDER}function s(h){return D(h,n)}function c(h){return zt(h,n)}let{ProjectivePoint:f,normPrivateKeyToScalar:x,weierstrassEquation:u,isWithinCurveOrder:p}=Rr({...t,toBytes(h,w,L){let K=w.toAffine(),H=e.toBytes(K.x),C=st;return L?C(Uint8Array.from([w.hasEvenY()?2:3]),H):C(Uint8Array.from([4]),H,e.toBytes(K.y))},fromBytes(h){let w=h.length,L=h[0],K=h.subarray(1);if(w===i&&(L===2||L===3)){let H=$(K);if(!a(H))throw new Error("Point is not on curve");let C=u(H),z=e.sqrt(C),j=(z&M)===M;return(L&1)===1!==j&&(z=e.neg(z)),{x:H,y:z}}else if(w===o&&L===4){let H=e.fromBytes(K.subarray(0,e.BYTES)),C=e.fromBytes(K.subarray(e.BYTES,2*e.BYTES));return{x:H,y:C}}else throw new Error(`Point of length ${w} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}}),v=h=>ht(X(h,t.nByteLength));function g(h){let w=n>>M;return h>w}function l(h){return g(h)?s(-h):h}let d=(h,w,L)=>$(h.slice(w,L));class b{constructor(w,L,K){this.r=w,this.s=L,this.recovery=K,this.assertValidity()}static fromCompact(w){let L=t.nByteLength;return w=q("compactSignature",w,L*2),new b(d(w,0,L),d(w,L,2*L))}static fromDER(w){let{r:L,s:K}=bt.toSig(q("DER",w));return new b(L,K)}assertValidity(){if(!p(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!p(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(w){return new b(this.r,this.s,w)}recoverPublicKey(w){let{r:L,s:K,recovery:H}=this,C=B(q("msgHash",w));if(H==null||![0,1,2,3].includes(H))throw new Error("recovery id invalid");let z=H===2||H===3?L+t.n:L;if(z>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");let j=H&1?"03":"02",tt=f.fromHex(j+v(z)),et=c(z),pt=s(-C*et),vt=s(K*et),rt=f.BASE.multiplyAndAddUnsafe(tt,pt,vt);if(!rt)throw new Error("point at infinify");return rt.assertValidity(),rt}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new b(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return dt(this.toDERHex())}toDERHex(){return bt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return dt(this.toCompactHex())}toCompactHex(){return v(this.r)+v(this.s)}}let E={isValidPrivateKey(h){try{return x(h),!0}catch{return!1}},normPrivateKeyToScalar:x,randomPrivateKey:()=>{let h=t.randomBytes(e.BYTES+8),w=De(h,n);return X(w,t.nByteLength)},precompute(h=8,w=f.BASE){return w._setWindowSize(h),w.multiply(BigInt(3)),w}};function y(h,w=!0){return f.fromPrivateKey(h).toRawBytes(w)}function I(h){let w=h instanceof Uint8Array,L=typeof h=="string",K=(w||L)&&h.length;return w?K===i||K===o:L?K===2*i||K===2*o:h instanceof f}function S(h,w,L=!0){if(I(h))throw new Error("first arg must be private key");if(!I(w))throw new Error("second arg must be public key");return f.fromHex(w).multiply(x(h)).toRawBytes(L)}let m=t.bits2int||function(h){let w=$(h),L=h.length*8-t.nBitLength;return L>0?w>>BigInt(L):w},B=t.bits2int_modN||function(h){return s(m(h))},A=It(t.nBitLength);function k(h){if(typeof h!="bigint")throw new Error("bigint expected");if(!(J<=h&&h<A))throw new Error(`bigint expected < 2^${t.nBitLength}`);return X(h,t.nByteLength)}function P(h,w,L=U){if(["recovered","canonical"].some(lt=>lt in L))throw new Error("sign() legacy options not supported");let{hash:K,randomBytes:H}=t,{lowS:C,prehash:z,extraEntropy:j}=L;C==null&&(C=!0),h=q("msgHash",h),z&&(h=q("prehashed msgHash",K(h)));let tt=B(h),et=x(w),pt=[k(et),k(tt)];if(j!=null){let lt=j===!0?H(e.BYTES):j;pt.push(q("extraEntropy",lt,e.BYTES))}let vt=st(...pt),rt=tt;function re(lt){let wt=m(lt);if(!p(wt))return;let _e=c(wt),Y=f.BASE.multiply(wt).toAffine(),gt=s(Y.x);if(gt===J)return;let kt=s(_e*s(rt+gt*et));if(kt===J)return;let Ie=(Y.x===gt?0:2)|Number(Y.y&M),Le=kt;return C&&g(kt)&&(Le=l(kt),Ie^=1),new b(gt,Le,Ie)}return{seed:vt,k2sig:re}}let U={lowS:t.lowS,prehash:!1},N={lowS:t.lowS,prehash:!1};function R(h,w,L=U){let{seed:K,k2sig:H}=P(h,w,L),C=t;return fe(C.hash.outputLen,C.nByteLength,C.hmac)(K,H)}f.BASE._setWindowSize(8);function Z(h,w,L,K=N){let H=h;if(w=q("msgHash",w),L=q("publicKey",L),"strict"in K)throw new Error("options.strict was renamed to lowS");let{lowS:C,prehash:z}=K,j,tt;try{if(typeof H=="string"||H instanceof Uint8Array)try{j=b.fromDER(H)}catch(Y){if(!(Y instanceof bt.Err))throw Y;j=b.fromCompact(H)}else if(typeof H=="object"&&typeof H.r=="bigint"&&typeof H.s=="bigint"){let{r:Y,s:gt}=H;j=new b(Y,gt)}else throw new Error("PARSE");tt=f.fromHex(L)}catch(Y){if(Y.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(C&&j.hasHighS())return!1;z&&(w=t.hash(w));let{r:et,s:pt}=j,vt=B(w),rt=c(pt),re=s(vt*rt),lt=s(et*rt),wt=f.BASE.multiplyAndAddUnsafe(tt,re,lt)?.toAffine();return wt?s(wt.x)===et:!1}return{CURVE:t,getPublicKey:y,getSharedSecret:S,sign:R,verify:Z,ProjectivePoint:f,Signature:b,utils:E}}var Gt=class extends mt{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,W.hash(t);let n=_t(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,o=new Uint8Array(i);o.set(n.length>i?t.create().update(n).digest():n);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=t.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),o.fill(0)}update(t){return W.exists(this),this.iHash.update(t),this}digestInto(t){W.exists(this),W.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:e,iHash:n,finished:i,destroyed:o,blockLen:a,outputLen:s}=this;return t=t,t.finished=i,t.destroyed=o,t.blockLen=a,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},yt=(r,t,e)=>new Gt(r,t).update(e).digest();yt.create=(r,t)=>new Gt(r,t);function qr(r){return{hash:r,hmac:(t,...e)=>yt(r,t,He(...e)),randomBytes:ie}}function Ge(r,t){let e=n=>je({...r,...qr(n)});return Object.freeze({...e(t),create:e})}var $e=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Me=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),zr=BigInt(1),be=BigInt(2),Ve=(r,t)=>(r+t/be)/t;function jr(r){let t=$e,e=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),a=BigInt(23),s=BigInt(44),c=BigInt(88),f=r*r*r%t,x=f*f*r%t,u=G(x,e,t)*x%t,p=G(u,e,t)*x%t,v=G(p,be,t)*f%t,g=G(v,i,t)*v%t,l=G(g,o,t)*g%t,d=G(l,s,t)*l%t,b=G(d,c,t)*d%t,E=G(b,s,t)*l%t,y=G(E,e,t)*x%t,I=G(y,a,t)*g%t,S=G(I,n,t)*f%t,m=G(S,be,t);if(!ye.eql(ye.sqr(m),r))throw new Error("Cannot find square root");return m}var ye=Re($e,void 0,void 0,{sqrt:jr}),Lt=Ge({a:BigInt(0),b:BigInt(7),Fp:ye,n:Me,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{let t=Me,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-zr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,a=BigInt("0x100000000000000000000000000000000"),s=Ve(o*r,t),c=Ve(-n*r,t),f=D(r-s*e-c*i,t),x=D(-s*n-c*o,t),u=f>a,p=x>a;if(u&&(f=t-f),p&&(x=t-x),f>a||x>a)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:u,k1:f,k2neg:p,k2:x}}}},Ct),ui=BigInt(0);var li=Lt.ProjectivePoint;var Mt=["deriveBits"];var F=new Uint8Array(0),pe=new Uint8Array([72,80,75,69,45,118,49]),di=new Uint8Array([72,80,75,69,0,0,0,0,0,0]),Ze=new Uint8Array([75,69,77,0,0]),Ye=new Uint8Array([100,107,112,95,112,114,107]),We=new Uint8Array([101,97,101,95,112,114,107]),xi=new Uint8Array([105,110,102,111,95,104,97,115,104]),bi=new Uint8Array([112,115,107,95,105,100,95,104,97,115,104]),yi=new Uint8Array([115,101,99,114,101,116]),Xe=new Uint8Array([115,104,97,114,101,100,95,115,101,99,114,101,116]),pi=new Uint8Array([107,101,121]),wi=new Uint8Array([98,97,115,101,95,110,111,110,99,101]),gi=new Uint8Array([101,120,112]),mi=new Uint8Array([115,101,99]),Ei=new Uint8Array([99,97,110,100,105,100,97,116,101]),Qe=new Uint8Array([115,107]),Ai=new Uint8Array([255,255,255,255,0,0,0,0,255,255,255,255,255,255,255,255,188,230,250,173,167,23,158,132,243,185,202,194,252,99,37,81]),Bi=new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,199,99,77,129,244,55,45,223,88,26,13,178,72,176,167,122,236,236,25,106,204,197,41,115]),Si=new Uint8Array([1,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,81,134,135,131,191,47,150,107,127,204,1,72,247,9,165,208,59,181,201,184,137,156,71,174,187,111,183,30,145,56,100,9]);var Vt=class{constructor(){Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}checkInit(){if(typeof this._api>"u")throw new Error("Not initialized. Call init()")}},At=class extends Vt{constructor(){super()}init(t){this._api=t}},$t=class extends Vt{constructor(){super(),Object.defineProperty(this,"_suiteId",{enumerable:!0,configurable:!0,writable:!0,value:F})}init(t,e){this._api=t,this._suiteId=e}};var Gr={DhkemP256HkdfSha256:16,DhkemP384HkdfSha384:17,DhkemP521HkdfSha512:18,DhkemSecp256K1HkdfSha256:19,DhkemSecp256k1HkdfSha256:19,DhkemX25519HkdfSha256:32,DhkemX448HkdfSha512:33},Zt=Gr,Mr={HkdfSha256:1,HkdfSha384:2,HkdfSha512:3},we=Mr;var ct=class{constructor(t,e,n){Object.defineProperty(this,"key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extractable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"algorithm",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"usages",{enumerable:!0,configurable:!0,writable:!0,value:Mt}),this.key=e,this.type=n,this.algorithm={name:t},n==="public"&&(this.usages=[])}};var Yt=BigInt(4294967295),ge=BigInt(32);function Je(r,t=!1){return t?{h:Number(r&Yt),l:Number(r>>ge&Yt)}:{h:Number(r>>ge&Yt)|0,l:Number(r&Yt)|0}}function Vr(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let i=0;i<r.length;i++){let{h:o,l:a}=Je(r[i],t);[e[i],n[i]]=[o,a]}return[e,n]}var $r=(r,t)=>BigInt(r>>>0)<<ge|BigInt(t>>>0),Zr=(r,t,e)=>r>>>e,Yr=(r,t,e)=>r<<32-e|t>>>e,Wr=(r,t,e)=>r>>>e|t<<32-e,Xr=(r,t,e)=>r<<32-e|t>>>e,Qr=(r,t,e)=>r<<64-e|t>>>e-32,Jr=(r,t,e)=>r>>>e-32|t<<64-e,Fr=(r,t)=>t,tn=(r,t)=>r,en=(r,t,e)=>r<<e|t>>>32-e,rn=(r,t,e)=>t<<e|r>>>32-e,nn=(r,t,e)=>t<<e-32|r>>>64-e,on=(r,t,e)=>r<<e-32|t>>>64-e;function sn(r,t,e,n){let i=(t>>>0)+(n>>>0);return{h:r+e+(i/2**32|0)|0,l:i|0}}var cn=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),an=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,fn=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),un=(r,t,e,n,i)=>t+e+n+i+(r/2**32|0)|0,ln=(r,t,e,n,i)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(i>>>0),hn=(r,t,e,n,i,o)=>t+e+n+i+o+(r/2**32|0)|0,dn={fromBig:Je,split:Vr,toBig:$r,shrSH:Zr,shrSL:Yr,rotrSH:Wr,rotrSL:Xr,rotrBH:Qr,rotrBL:Jr,rotr32H:Fr,rotr32L:tn,rotlSH:en,rotlSL:rn,rotlBH:nn,rotlBL:on,add:sn,add3L:cn,add3H:an,add4L:fn,add4H:un,add5H:hn,add5L:ln},_=dn;var[xn,bn]=_.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),at=new Uint32Array(80),ft=new Uint32Array(80),Bt=class extends Et{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){let{Ah:t,Al:e,Bh:n,Bl:i,Ch:o,Cl:a,Dh:s,Dl:c,Eh:f,El:x,Fh:u,Fl:p,Gh:v,Gl:g,Hh:l,Hl:d}=this;return[t,e,n,i,o,a,s,c,f,x,u,p,v,g,l,d]}set(t,e,n,i,o,a,s,c,f,x,u,p,v,g,l,d){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=i|0,this.Ch=o|0,this.Cl=a|0,this.Dh=s|0,this.Dl=c|0,this.Eh=f|0,this.El=x|0,this.Fh=u|0,this.Fl=p|0,this.Gh=v|0,this.Gl=g|0,this.Hh=l|0,this.Hl=d|0}process(t,e){for(let y=0;y<16;y++,e+=4)at[y]=t.getUint32(e),ft[y]=t.getUint32(e+=4);for(let y=16;y<80;y++){let I=at[y-15]|0,S=ft[y-15]|0,m=_.rotrSH(I,S,1)^_.rotrSH(I,S,8)^_.shrSH(I,S,7),B=_.rotrSL(I,S,1)^_.rotrSL(I,S,8)^_.shrSL(I,S,7),A=at[y-2]|0,k=ft[y-2]|0,P=_.rotrSH(A,k,19)^_.rotrBH(A,k,61)^_.shrSH(A,k,6),U=_.rotrSL(A,k,19)^_.rotrBL(A,k,61)^_.shrSL(A,k,6),N=_.add4L(B,U,ft[y-7],ft[y-16]),R=_.add4H(N,m,P,at[y-7],at[y-16]);at[y]=R|0,ft[y]=N|0}let{Ah:n,Al:i,Bh:o,Bl:a,Ch:s,Cl:c,Dh:f,Dl:x,Eh:u,El:p,Fh:v,Fl:g,Gh:l,Gl:d,Hh:b,Hl:E}=this;for(let y=0;y<80;y++){let I=_.rotrSH(u,p,14)^_.rotrSH(u,p,18)^_.rotrBH(u,p,41),S=_.rotrSL(u,p,14)^_.rotrSL(u,p,18)^_.rotrBL(u,p,41),m=u&v^~u&l,B=p&g^~p&d,A=_.add5L(E,S,B,bn[y],ft[y]),k=_.add5H(A,b,I,m,xn[y],at[y]),P=A|0,U=_.rotrSH(n,i,28)^_.rotrBH(n,i,34)^_.rotrBH(n,i,39),N=_.rotrSL(n,i,28)^_.rotrBL(n,i,34)^_.rotrBL(n,i,39),R=n&o^n&s^o&s,Z=i&a^i&c^a&c;b=l|0,E=d|0,l=v|0,d=g|0,v=u|0,g=p|0,{h:u,l:p}=_.add(f|0,x|0,k|0,P|0),f=s|0,x=c|0,s=o|0,c=a|0,o=n|0,a=i|0;let h=_.add3L(P,N,Z);n=_.add3H(h,k,U,R),i=h|0}({h:n,l:i}=_.add(this.Ah|0,this.Al|0,n|0,i|0)),{h:o,l:a}=_.add(this.Bh|0,this.Bl|0,o|0,a|0),{h:s,l:c}=_.add(this.Ch|0,this.Cl|0,s|0,c|0),{h:f,l:x}=_.add(this.Dh|0,this.Dl|0,f|0,x|0),{h:u,l:p}=_.add(this.Eh|0,this.El|0,u|0,p|0),{h:v,l:g}=_.add(this.Fh|0,this.Fl|0,v|0,g|0),{h:l,l:d}=_.add(this.Gh|0,this.Gl|0,l|0,d|0),{h:b,l:E}=_.add(this.Hh|0,this.Hl|0,b|0,E|0),this.set(n,i,o,a,s,c,f,x,u,p,v,g,l,d,b,E)}roundClean(){at.fill(0),ft.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}},me=class extends Bt{constructor(){super(),this.Ah=-1942145080,this.Al=424955298,this.Bh=1944164710,this.Bl=-1982016298,this.Ch=502970286,this.Cl=855612546,this.Dh=1738396948,this.Dl=1479516111,this.Eh=258812777,this.El=2077511080,this.Fh=2011393907,this.Fl=79989058,this.Gh=1067287976,this.Gl=1780299464,this.Hh=286451373,this.Hl=-1848208735,this.outputLen=28}},Ee=class extends Bt{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}},Ae=class extends Bt{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}},Fe=nt(()=>new Bt),Ki=nt(()=>new me),ki=nt(()=>new Ee),tr=nt(()=>new Ae);var Be=class extends $t{constructor(){super(),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:we.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}buildLabeledIkm(t,e){let n=new Uint8Array(7+this._suiteId.byteLength+t.byteLength+e.byteLength);return n.set(pe,0),n.set(this._suiteId,7),n.set(t,7+this._suiteId.byteLength),n.set(e,7+this._suiteId.byteLength+t.byteLength),n}buildLabeledInfo(t,e,n){let i=new Uint8Array(9+this._suiteId.byteLength+t.byteLength+e.byteLength);return i.set(new Uint8Array([0,n]),0),i.set(pe,2),i.set(this._suiteId,9),i.set(t,9+this._suiteId.byteLength),i.set(e,9+this._suiteId.byteLength+t.byteLength),i}async extract(t,e){if(this.checkInit(),t.byteLength===0&&(t=new ArrayBuffer(this.hashSize)),t.byteLength!==this.hashSize)switch(this.algHash.hash){case"SHA-256":return yt(Ct,new Uint8Array(t),new Uint8Array(e));case"SHA-384":return yt(tr,new Uint8Array(t),new Uint8Array(e));default:return yt(Fe,new Uint8Array(t),new Uint8Array(e))}let n=await this._api.importKey("raw",t,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,e)}async expand(t,e,n){this.checkInit();let i=await this._api.importKey("raw",t,this.algHash,!1,["sign"]),o=new ArrayBuffer(n),a=new Uint8Array(o),s=F,c=new Uint8Array(e),f=new Uint8Array(1);if(n>255*this.hashSize)throw new Error("Entropy limit reached");let x=new Uint8Array(this.hashSize+c.length+1);for(let u=1,p=0;p<a.length;u++)f[0]=u,x.set(s,0),x.set(c,s.length),x.set(f,s.length+c.length),s=new Uint8Array(await this._api.sign("HMAC",i,x.slice(0,s.length+c.length+1))),a.length-p>=s.length?(a.set(s,p),p+=s.length):(a.set(s.slice(0,a.length-p),p),p+=a.length-p);return o}async extractAndExpand(t,e,n,i){this.checkInit();let o=await this._api.importKey("raw",e,"HKDF",!1,Mt);return await this._api.deriveBits({name:"HKDF",hash:this.algHash.hash,salt:t,info:n},o,i*8)}async labeledExtract(t,e,n){return await this.extract(t,this.buildLabeledIkm(e,n))}async labeledExpand(t,e,n,i){return await this.expand(t,this.buildLabeledInfo(e,n,i),i)}},Wt=class extends Be{constructor(){super(...arguments),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:we.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}};var yn={},pn=wn(globalThis,yn);function wn(r,t){return new Proxy(r,{get(e,n,i){return n in t?t[n]:r[n]},set(e,n,i){return n in t&&delete t[n],r[n]=i,!0},deleteProperty(e,n){let i=!1;return n in t&&(delete t[n],i=!0),n in r&&(delete r[n],i=!0),i},ownKeys(e){let n=Reflect.ownKeys(r),i=Reflect.ownKeys(t),o=new Set(i);return[...n.filter(a=>!o.has(a)),...i]},defineProperty(e,n,i){return n in t&&delete t[n],Reflect.defineProperty(r,n,i),!0},getOwnPropertyDescriptor(e,n){return n in t?Reflect.getOwnPropertyDescriptor(t,n):Reflect.getOwnPropertyDescriptor(r,n)},has(e,n){return n in t||n in r}})}var Pt=r=>typeof r=="object"&&r!==null&&typeof r.privateKey=="object"&&typeof r.publicKey=="object";function er(r,t){if(t<=0)throw new Error("i2Osp: too small size");if(r>=256**t)throw new Error("i2Osp: too large integer");let e=new Uint8Array(t);for(let n=0;n<t&&r;n++)e[t-(n+1)]=r%256,r=r>>8;return e}function Ht(r,t){let e=new Uint8Array(r.length+t.length);return e.set(r,0),e.set(t,r.length),e}function rr(r,t,e){let n=new Uint8Array(r.length+t.length+e.length);return n.set(r,0),n.set(t,r.length),n.set(e,r.length+t.length),n}var ut=class extends Error{constructor(t){let e;t instanceof Error?e=t.message:typeof t=="string"?e=t:e="",super(e),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.message===""?this.message=this.name:this.message=this.name+": "+this.message}};var Xt=class extends ut{},St=class extends ut{},Qt=class extends ut{},Jt=class extends ut{};var Ft=class extends ut{},te=class extends ut{};var ee=class extends At{constructor(t,e){super(),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Zt.DhkemP256HkdfSha256}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_prim",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._prim=t,this._kdf=e}init(t){super.init(t);let e=new Uint8Array(Ze);e.set(er(this.id,2),3),this._prim.init(t),this._kdf.init(t,e),super.init(t)}async generateKeyPair(){try{return await this._prim.generateKeyPair()}catch(t){throw new te(t)}}async deriveKeyPair(t){try{return await this._prim.deriveKeyPair(t)}catch(e){throw new Ft(e)}}async serializePublicKey(t){try{return await this._prim.serializePublicKey(t)}catch(e){throw new Xt(e)}}async deserializePublicKey(t){try{return await this._prim.deserializePublicKey(t)}catch(e){throw new St(e)}}async importKey(t,e,n){try{return await this._prim.importKey(t,e,n)}catch(i){throw new St(i)}}async encap(t){try{let e=t.nonEphemeralKeyPair===void 0?await this.generateKeyPair():t.nonEphemeralKeyPair,n=await this._prim.serializePublicKey(e.publicKey),i=await this._prim.serializePublicKey(t.recipientPublicKey),o;if(t.senderKey===void 0)o=new Uint8Array(await this._prim.dh(e.privateKey,t.recipientPublicKey));else{let c=Pt(t.senderKey)?t.senderKey.privateKey:t.senderKey,f=new Uint8Array(await this._prim.dh(e.privateKey,t.recipientPublicKey)),x=new Uint8Array(await this._prim.dh(c,t.recipientPublicKey));o=Ht(f,x)}let a;if(t.senderKey===void 0)a=Ht(new Uint8Array(n),new Uint8Array(i));else{let c=Pt(t.senderKey)?t.senderKey.publicKey:await this._prim.derivePublicKey(t.senderKey),f=await this._prim.serializePublicKey(c);a=rr(new Uint8Array(n),new Uint8Array(i),new Uint8Array(f))}let s=await this.generateSharedSecret(o,a);return{enc:n,sharedSecret:s}}catch(e){throw new Qt(e)}}async decap(t){let e;try{e=await this._prim.deserializePublicKey(t.enc)}catch(n){throw new St(n)}try{let n=Pt(t.recipientKey)?t.recipientKey.privateKey:t.recipientKey,i=Pt(t.recipientKey)?t.recipientKey.publicKey:await this._prim.derivePublicKey(t.recipientKey),o=await this._prim.serializePublicKey(i),a;if(t.senderPublicKey===void 0)a=new Uint8Array(await this._prim.dh(n,e));else{let c=new Uint8Array(await this._prim.dh(n,e)),f=new Uint8Array(await this._prim.dh(n,t.senderPublicKey));a=Ht(c,f)}let s;if(t.senderPublicKey===void 0)s=Ht(new Uint8Array(t.enc),new Uint8Array(o));else{let c=await this._prim.serializePublicKey(t.senderPublicKey);s=new Uint8Array(t.enc.byteLength+o.byteLength+c.byteLength),s.set(new Uint8Array(t.enc),0),s.set(new Uint8Array(o),t.enc.byteLength),s.set(new Uint8Array(c),t.enc.byteLength+o.byteLength)}return await this.generateSharedSecret(a,s)}catch(n){throw new Jt(n)}}async generateSharedSecret(t,e){let n=this._kdf.buildLabeledIkm(We,t),i=this._kdf.buildLabeledInfo(Xe,e,this.secretSize);return await this._kdf.extractAndExpand(F,n,i,this.secretSize)}};var Kt="ECDH",Se=class extends At{constructor(t){super(),Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=t,this._nPk=33,this._nSk=32}async serializePublicKey(t){return await this._serializePublicKey(t)}async deserializePublicKey(t){return await this._deserializePublicKey(t)}async importKey(t,e,n){if(t!=="raw")throw new Error("Unsupported format");return await this._importKey(e,n)}async derivePublicKey(t){return await this._derivePublicKey(t)}async generateKeyPair(){let t=Lt.utils.randomPrivateKey(),e=new ct(Kt,t,"private");return{publicKey:await this.derivePublicKey(e),privateKey:e}}async deriveKeyPair(t){let e=await this._hkdf.labeledExtract(F,Ye,new Uint8Array(t)),n=await this._hkdf.labeledExpand(e,Qe,F,this._nSk),i=new ct(Kt,new Uint8Array(n),"private");return{privateKey:i,publicKey:await this.derivePublicKey(i)}}async dh(t,e){return await this._dh(t,e)}_serializePublicKey(t){return new Promise(e=>{e(t.key.buffer)})}_deserializePublicKey(t){return new Promise((e,n)=>{t.byteLength!==this._nPk?n(new Error("Invalid public key for the ciphersuite")):e(new ct(Kt,new Uint8Array(t),"public"))})}_importKey(t,e){return new Promise((n,i)=>{e&&t.byteLength!==this._nPk&&i(new Error("Invalid public key for the ciphersuite")),!e&&t.byteLength!==this._nSk&&i(new Error("Invalid private key for the ciphersuite")),n(new ct(Kt,new Uint8Array(t),e?"public":"private"))})}_derivePublicKey(t){return new Promise(e=>{let n=Lt.getPublicKey(t.key);e(new ct(Kt,n,"public"))})}_dh(t,e){return new Promise((n,i)=>{try{n(Lt.getSharedSecret(t.key,e.key).buffer)}catch(o){i(o)}})}},ve=class extends ee{constructor(){let t=new Wt,e=new Se(t);super(e,t),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Zt.DhkemSecp256K1HkdfSha256}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:65}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:65}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:32})}};export{ve as DhkemSecp256k1HkdfSha256};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
