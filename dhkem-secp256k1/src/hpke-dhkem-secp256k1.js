var lr=Object.defineProperty;var dr=(r,e)=>{for(var t in e)lr(r,t,{get:e[t],enumerable:!0})};var Q=class extends Error{constructor(e){let t;e instanceof Error?t=e.message:typeof e=="string"?t=e:t="",super(t),this.name=this.constructor.name}},we=class extends Q{};var J=class extends Q{},W=class extends Q{},Ye=class extends Q{},We=class extends Q{};var Se=class extends Q{},F=class extends Q{};var hr={},ht=yr(globalThis,hr);function yr(r,e){return new Proxy(r,{get(t,n,i){return n in e?e[n]:r[n]},set(t,n,i){return n in e&&delete e[n],r[n]=i,!0},deleteProperty(t,n){let i=!1;return n in e&&(delete e[n],i=!0),n in r&&(delete r[n],i=!0),i},ownKeys(t){let n=Reflect.ownKeys(r),i=Reflect.ownKeys(e),o=new Set(i);return[...n.filter(a=>!o.has(a)),...i]},defineProperty(t,n,i){return n in e&&delete e[n],Reflect.defineProperty(r,n,i),!0},getOwnPropertyDescriptor(t,n){return n in e?Reflect.getOwnPropertyDescriptor(e,n):Reflect.getOwnPropertyDescriptor(r,n)},has(t,n){return n in e||n in r}})}async function wr(){if(ht!==void 0&&globalThis.crypto!==void 0)return globalThis.crypto.subtle;try{let{webcrypto:r}=await import("crypto");return r.subtle}catch(r){throw new F(r)}}var Be=class{constructor(){Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}async _setup(){this._api===void 0&&(this._api=await wr())}};var oe={NotAssigned:0,DhkemP256HkdfSha256:16,DhkemP384HkdfSha384:17,DhkemP521HkdfSha512:18,DhkemSecp256k1HkdfSha256:19,DhkemX25519HkdfSha256:32,DhkemX448HkdfSha512:33,HybridkemX25519Kyber768:48,MlKem512:64,MlKem768:65,MlKem1024:66,XWing:25722},Xe={HkdfSha256:1,HkdfSha384:2,HkdfSha512:3};var M=new Uint8Array(0);var $e=new Uint8Array([75,69,77,0,0]);var se=r=>typeof r=="object"&&r!==null&&typeof r.privateKey=="object"&&typeof r.publicKey=="object";function Ce(r,e){if(e<=0)throw new Error("i2Osp: too small size");if(r>=256**e)throw new Error("i2Osp: too large integer");let t=new Uint8Array(e);for(let n=0;n<e&&r;n++)t[e-(n+1)]=r%256,r=r>>8;return t}function pe(r,e){let t=new Uint8Array(r.length+e.length);return t.set(r,0),t.set(e,r.length),t}var pr=new Uint8Array([101,97,101,95,112,114,107]),br=new Uint8Array([115,104,97,114,101,100,95,115,101,99,114,101,116]);function mr(r,e,t){let n=new Uint8Array(r.length+e.length+t.length);return n.set(r,0),n.set(e,r.length),n.set(t,r.length+e.length),n}var ke=class{constructor(e,t,n){Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_prim",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.id=e,this._prim=t,this._kdf=n;let i=new Uint8Array($e);i.set(Ce(this.id,2),3),this._kdf.init(i)}async serializePublicKey(e){return await this._prim.serializePublicKey(e)}async deserializePublicKey(e){return await this._prim.deserializePublicKey(e)}async serializePrivateKey(e){return await this._prim.serializePrivateKey(e)}async deserializePrivateKey(e){return await this._prim.deserializePrivateKey(e)}async importKey(e,t,n=!0){return await this._prim.importKey(e,t,n)}async generateKeyPair(){return await this._prim.generateKeyPair()}async deriveKeyPair(e){if(e.byteLength>8192)throw new we("Too long ikm");return await this._prim.deriveKeyPair(e)}async encap(e){let t;e.ekm===void 0?t=await this.generateKeyPair():se(e.ekm)?t=e.ekm:t=await this.deriveKeyPair(e.ekm);let n=await this._prim.serializePublicKey(t.publicKey),i=await this._prim.serializePublicKey(e.recipientPublicKey);try{let o;if(e.senderKey===void 0)o=new Uint8Array(await this._prim.dh(t.privateKey,e.recipientPublicKey));else{let s=se(e.senderKey)?e.senderKey.privateKey:e.senderKey,f=new Uint8Array(await this._prim.dh(t.privateKey,e.recipientPublicKey)),y=new Uint8Array(await this._prim.dh(s,e.recipientPublicKey));o=pe(f,y)}let a;if(e.senderKey===void 0)a=pe(new Uint8Array(n),new Uint8Array(i));else{let s=se(e.senderKey)?e.senderKey.publicKey:await this._prim.derivePublicKey(e.senderKey),f=await this._prim.serializePublicKey(s);a=mr(new Uint8Array(n),new Uint8Array(i),new Uint8Array(f))}let c=await this._generateSharedSecret(o,a);return{enc:n,sharedSecret:c}}catch(o){throw new Ye(o)}}async decap(e){let t=await this._prim.deserializePublicKey(e.enc),n=se(e.recipientKey)?e.recipientKey.privateKey:e.recipientKey,i=se(e.recipientKey)?e.recipientKey.publicKey:await this._prim.derivePublicKey(e.recipientKey),o=await this._prim.serializePublicKey(i);try{let a;if(e.senderPublicKey===void 0)a=new Uint8Array(await this._prim.dh(n,t));else{let s=new Uint8Array(await this._prim.dh(n,t)),f=new Uint8Array(await this._prim.dh(n,e.senderPublicKey));a=pe(s,f)}let c;if(e.senderPublicKey===void 0)c=pe(new Uint8Array(e.enc),new Uint8Array(o));else{let s=await this._prim.serializePublicKey(e.senderPublicKey);c=new Uint8Array(e.enc.byteLength+o.byteLength+s.byteLength),c.set(new Uint8Array(e.enc),0),c.set(new Uint8Array(o),e.enc.byteLength),c.set(new Uint8Array(s),e.enc.byteLength+o.byteLength)}return await this._generateSharedSecret(a,c)}catch(a){throw new We(a)}}async _generateSharedSecret(e,t){let n=this._kdf.buildLabeledIkm(pr,e),i=this._kdf.buildLabeledInfo(br,t,this.secretSize);return await this._kdf.extractAndExpand(M,n,i,this.secretSize)}};var be=["deriveBits"],Ie=new Uint8Array([100,107,112,95,112,114,107]),De=new Uint8Array([115,107]);var Kn=new Uint8Array([99,97,110,100,105,100,97,116,101]),An=new Uint8Array([255,255,255,255,0,0,0,0,255,255,255,255,255,255,255,255,188,230,250,173,167,23,158,132,243,185,202,194,252,99,37,81]),Pn=new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,199,99,77,129,244,55,45,223,88,26,13,178,72,176,167,122,236,236,25,106,204,197,41,115]),Sn=new Uint8Array([1,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,81,134,135,131,191,47,150,107,127,204,1,72,247,9,165,208,59,181,201,184,137,156,71,174,187,111,183,30,145,56,100,9]),Bn=new Uint8Array([48,65,2,1,0,48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7,4,39,48,37,2,1,1,4,32]),kn=new Uint8Array([48,78,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,34,4,55,48,53,2,1,1,4,48]),In=new Uint8Array([48,96,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,35,4,73,48,71,2,1,1,4,66]);var X=class{constructor(e,t,n,i=[]){Object.defineProperty(this,"key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extractable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"algorithm",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"usages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.key=t,this.type=n,this.algorithm={name:e},this.usages=i,n==="public"&&(this.usages=[])}};var Nt=new Uint8Array([72,80,75,69,45,118,49]),yt=class extends Be{constructor(){super(),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Xe.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_suiteId",{enumerable:!0,configurable:!0,writable:!0,value:M}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}init(e){this._suiteId=e}buildLabeledIkm(e,t){this._checkInit();let n=new Uint8Array(7+this._suiteId.byteLength+e.byteLength+t.byteLength);return n.set(Nt,0),n.set(this._suiteId,7),n.set(e,7+this._suiteId.byteLength),n.set(t,7+this._suiteId.byteLength+e.byteLength),n}buildLabeledInfo(e,t,n){this._checkInit();let i=new Uint8Array(9+this._suiteId.byteLength+e.byteLength+t.byteLength);return i.set(new Uint8Array([0,n]),0),i.set(Nt,2),i.set(this._suiteId,9),i.set(e,9+this._suiteId.byteLength),i.set(t,9+this._suiteId.byteLength+e.byteLength),i}async extract(e,t){if(await this._setup(),e.byteLength===0&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)throw new we("The salt length must be the same as the hashSize");let n=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,t)}async expand(e,t,n){await this._setup();let i=await this._api.importKey("raw",e,this.algHash,!1,["sign"]),o=new ArrayBuffer(n),a=new Uint8Array(o),c=M,s=new Uint8Array(t),f=new Uint8Array(1);if(n>255*this.hashSize)throw new Error("Entropy limit reached");let y=new Uint8Array(this.hashSize+s.length+1);for(let d=1,l=0;l<a.length;d++)f[0]=d,y.set(c,0),y.set(s,c.length),y.set(f,c.length+s.length),c=new Uint8Array(await this._api.sign("HMAC",i,y.slice(0,c.length+s.length+1))),a.length-l>=c.length?(a.set(c,l),l+=c.length):(a.set(c.slice(0,a.length-l),l),l+=a.length-l);return o}async extractAndExpand(e,t,n,i){await this._setup();let o=await this._api.importKey("raw",t,"HKDF",!1,["deriveBits"]);return await this._api.deriveBits({name:"HKDF",hash:this.algHash.hash,salt:e,info:n},o,i*8)}async labeledExtract(e,t,n){return await this.extract(e,this.buildLabeledIkm(t,n))}async labeledExpand(e,t,n,i){return await this.expand(e,this.buildLabeledInfo(t,n,i),i)}_checkInit(){if(this._suiteId===M)throw new Error("Not initialized. Call init()")}},qe=class extends yt{constructor(){super(...arguments),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:Xe.HkdfSha256}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:{name:"HMAC",hash:"SHA-256",length:256}})}};function Ct(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function gr(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Ue(r,...e){if(!gr(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function Dt(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Ct(r.outputLen),Ct(r.blockLen)}function Le(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function qt(r,e){Ue(r);let t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}var me=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var Qe=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),Y=(r,e)=>r<<32-e|r>>>e;function xr(r){if(typeof r!="string")throw new Error("utf8ToBytes expected string, got "+typeof r);return new Uint8Array(new TextEncoder().encode(r))}function je(r){return typeof r=="string"&&(r=xr(r)),Ue(r),r}function jt(...r){let e=0;for(let n=0;n<r.length;n++){let i=r[n];Ue(i),e+=i.length}let t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){let o=r[n];t.set(o,i),i+=o.length}return t}var Oe=class{clone(){return this._cloneInto()}};function Mt(r){let e=n=>r().update(je(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function Gt(r=32){if(me&&typeof me.getRandomValues=="function")return me.getRandomValues(new Uint8Array(r));if(me&&typeof me.randomBytes=="function")return me.randomBytes(r);throw new Error("crypto.getRandomValues must be defined")}var Je=class extends Oe{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Dt(e);let n=je(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,o=new Uint8Array(i);o.set(n.length>i?e.create().update(n).digest():n);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),o.fill(0)}update(e){return Le(this),this.iHash.update(e),this}digestInto(e){Le(this),Ue(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:n,finished:i,destroyed:o,blockLen:a,outputLen:c}=this;return e=e,e.finished=i,e.destroyed=o,e.blockLen=a,e.outputLen=c,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},Me=(r,e,t)=>new Je(r,e).update(t).digest();Me.create=(r,e)=>new Je(r,e);function vr(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);let i=BigInt(32),o=BigInt(4294967295),a=Number(t>>i&o),c=Number(t&o),s=n?4:0,f=n?0:4;r.setUint32(e+s,a,n),r.setUint32(e+f,c,n)}var Vt=(r,e,t)=>r&e^~r&t,Zt=(r,e,t)=>r&e^r&t^e&t,Fe=class extends Oe{constructor(e,t,n,i){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Qe(this.buffer)}update(e){Le(this);let{view:t,buffer:n,blockLen:i}=this;e=je(e);let o=e.length;for(let a=0;a<o;){let c=Math.min(i-this.pos,o-a);if(c===i){let s=Qe(e);for(;i<=o-a;a+=i)this.process(s,a);continue}n.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Le(this),qt(e,this),this.finished=!0;let{buffer:t,view:n,blockLen:i,isLE:o}=this,{pos:a}=this;t[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>i-a&&(this.process(n,0),a=0);for(let d=a;d<i;d++)t[d]=0;vr(n,i-8,BigInt(this.length*8),o),this.process(n,0);let c=Qe(e),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=s/4,y=this.get();if(f>y.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<f;d++)c.setUint32(4*d,y[d],o)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:n,length:i,finished:o,destroyed:a,pos:c}=this;return e.length=i,e.pos=c,e.finished=o,e.destroyed=a,i%t&&e.buffer.set(n),e}};var _r=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ae=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ce=new Uint32Array(64),wt=class extends Fe{constructor(){super(64,32,8,!1),this.A=ae[0]|0,this.B=ae[1]|0,this.C=ae[2]|0,this.D=ae[3]|0,this.E=ae[4]|0,this.F=ae[5]|0,this.G=ae[6]|0,this.H=ae[7]|0}get(){let{A:e,B:t,C:n,D:i,E:o,F:a,G:c,H:s}=this;return[e,t,n,i,o,a,c,s]}set(e,t,n,i,o,a,c,s){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=o|0,this.F=a|0,this.G=c|0,this.H=s|0}process(e,t){for(let d=0;d<16;d++,t+=4)ce[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){let l=ce[d-15],g=ce[d-2],S=Y(l,7)^Y(l,18)^l>>>3,m=Y(g,17)^Y(g,19)^g>>>10;ce[d]=m+ce[d-7]+S+ce[d-16]|0}let{A:n,B:i,C:o,D:a,E:c,F:s,G:f,H:y}=this;for(let d=0;d<64;d++){let l=Y(c,6)^Y(c,11)^Y(c,25),g=y+l+Vt(c,s,f)+_r[d]+ce[d]|0,m=(Y(n,2)^Y(n,13)^Y(n,22))+Zt(n,i,o)|0;y=f,f=s,s=c,c=a+g|0,a=o,o=i,i=n,n=g+m|0}n=n+this.A|0,i=i+this.B|0,o=o+this.C|0,a=a+this.D|0,c=c+this.E|0,s=s+this.F|0,f=f+this.G|0,y=y+this.H|0,this.set(n,i,o,a,c,s,f,y)}roundClean(){ce.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var et=Mt(()=>new wt);var ze=class extends qe{async extract(e,t){if(await this._setup(),e.byteLength===0&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)return Me(et,new Uint8Array(e),new Uint8Array(t));let n=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",n,t)}};var vt={};dr(vt,{aInRange:()=>le,abool:()=>ge,abytes:()=>Te,bitGet:()=>Br,bitLen:()=>gt,bitMask:()=>Ve,bitSet:()=>kr,bytesToHex:()=>xe,bytesToNumberBE:()=>te,bytesToNumberLE:()=>nt,concatBytes:()=>He,createHmacDrbg:()=>xt,ensureBytes:()=>G,equalBytes:()=>Pr,hexToBytes:()=>_e,hexToNumber:()=>mt,inRange:()=>Ge,isBytes:()=>ue,memoized:()=>ot,notImplemented:()=>Ur,numberToBytesBE:()=>fe,numberToBytesLE:()=>it,numberToHexUnpadded:()=>ve,numberToVarBytesBE:()=>Ar,utf8ToBytes:()=>Sr,validateObject:()=>de});var tt=BigInt(0),rt=BigInt(1),Er=BigInt(2);function ue(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Te(r){if(!ue(r))throw new Error("Uint8Array expected")}function ge(r,e){if(typeof e!="boolean")throw new Error(r+" boolean expected, got "+e)}var Kr=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function xe(r){Te(r);let e="";for(let t=0;t<r.length;t++)e+=Kr[r[t]];return e}function ve(r){let e=r.toString(16);return e.length&1?"0"+e:e}function mt(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?tt:BigInt("0x"+r)}var ee={_0:48,_9:57,A:65,F:70,a:97,f:102};function Yt(r){if(r>=ee._0&&r<=ee._9)return r-ee._0;if(r>=ee.A&&r<=ee.F)return r-(ee.A-10);if(r>=ee.a&&r<=ee.f)return r-(ee.a-10)}function _e(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);let e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);let n=new Uint8Array(t);for(let i=0,o=0;i<t;i++,o+=2){let a=Yt(r.charCodeAt(o)),c=Yt(r.charCodeAt(o+1));if(a===void 0||c===void 0){let s=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+o)}n[i]=a*16+c}return n}function te(r){return mt(xe(r))}function nt(r){return Te(r),mt(xe(Uint8Array.from(r).reverse()))}function fe(r,e){return _e(r.toString(16).padStart(e*2,"0"))}function it(r,e){return fe(r,e).reverse()}function Ar(r){return _e(ve(r))}function G(r,e,t){let n;if(typeof e=="string")try{n=_e(e)}catch(o){throw new Error(r+" must be hex string or Uint8Array, cause: "+o)}else if(ue(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");let i=n.length;if(typeof t=="number"&&i!==t)throw new Error(r+" of length "+t+" expected, got "+i);return n}function He(...r){let e=0;for(let n=0;n<r.length;n++){let i=r[n];Te(i),e+=i.length}let t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){let o=r[n];t.set(o,i),i+=o.length}return t}function Pr(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}function Sr(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}var pt=r=>typeof r=="bigint"&&tt<=r;function Ge(r,e,t){return pt(r)&&pt(e)&&pt(t)&&e<=r&&r<t}function le(r,e,t,n){if(!Ge(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function gt(r){let e;for(e=0;r>tt;r>>=rt,e+=1);return e}function Br(r,e){return r>>BigInt(e)&rt}function kr(r,e,t){return r|(t?rt:tt)<<BigInt(e)}var Ve=r=>(Er<<BigInt(r-1))-rt,bt=r=>new Uint8Array(r),Wt=r=>Uint8Array.from(r);function xt(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=bt(r),i=bt(r),o=0,a=()=>{n.fill(1),i.fill(0),o=0},c=(...d)=>t(i,n,...d),s=(d=bt())=>{i=c(Wt([0]),d),n=c(),d.length!==0&&(i=c(Wt([1]),d),n=c())},f=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let d=0,l=[];for(;d<e;){n=c();let g=n.slice();l.push(g),d+=n.length}return He(...l)};return(d,l)=>{a(),s(d);let g;for(;!(g=l(f()));)s();return a(),g}}var Ir={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||ue(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function de(r,e,t={}){let n=(i,o,a)=>{let c=Ir[o];if(typeof c!="function")throw new Error("invalid validator function");let s=r[i];if(!(a&&s===void 0)&&!c(s,r))throw new Error("param "+String(i)+" is invalid. Expected "+o+", got "+s)};for(let[i,o]of Object.entries(e))n(i,o,!1);for(let[i,o]of Object.entries(t))n(i,o,!0);return r}var Ur=()=>{throw new Error("not implemented")};function ot(r){let e=new WeakMap;return(t,...n)=>{let i=e.get(t);if(i!==void 0)return i;let o=r(t,...n);return e.set(t,o),o}}var T=BigInt(0),O=BigInt(1),Ee=BigInt(2),Lr=BigInt(3),_t=BigInt(4),Xt=BigInt(5),$t=BigInt(8),Or=BigInt(9),zr=BigInt(16);function N(r,e){let t=r%e;return t>=T?t:e+t}function Tr(r,e,t){if(e<T)throw new Error("invalid exponent, negatives unsupported");if(t<=T)throw new Error("invalid modulus");if(t===O)return T;let n=O;for(;e>T;)e&O&&(n=n*r%t),r=r*r%t,e>>=O;return n}function V(r,e,t){let n=r;for(;e-- >T;)n*=n,n%=t;return n}function st(r,e){if(r===T)throw new Error("invert: expected non-zero number");if(e<=T)throw new Error("invert: expected positive modulus, got "+e);let t=N(r,e),n=e,i=T,o=O,a=O,c=T;for(;t!==T;){let f=n/t,y=n%t,d=i-a*f,l=o-c*f;n=t,t=y,i=a,o=c,a=d,c=l}if(n!==O)throw new Error("invert: does not exist");return N(i,e)}function Hr(r){let e=(r-O)/Ee,t,n,i;for(t=r-O,n=0;t%Ee===T;t/=Ee,n++);for(i=Ee;i<r&&Tr(i,e,r)!==r-O;i++)if(i>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){let a=(r+O)/_t;return function(s,f){let y=s.pow(f,a);if(!s.eql(s.sqr(y),f))throw new Error("Cannot find square root");return y}}let o=(t+O)/Ee;return function(c,s){if(c.pow(s,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let f=n,y=c.pow(c.mul(c.ONE,i),t),d=c.pow(s,o),l=c.pow(s,t);for(;!c.eql(l,c.ONE);){if(c.eql(l,c.ZERO))return c.ZERO;let g=1;for(let m=c.sqr(l);g<f&&!c.eql(m,c.ONE);g++)m=c.sqr(m);let S=c.pow(y,O<<BigInt(f-g-1));y=c.sqr(S),d=c.mul(d,S),l=c.mul(l,y),f=g}return d}}function Rr(r){if(r%_t===Lr){let e=(r+O)/_t;return function(n,i){let o=n.pow(i,e);if(!n.eql(n.sqr(o),i))throw new Error("Cannot find square root");return o}}if(r%$t===Xt){let e=(r-Xt)/$t;return function(n,i){let o=n.mul(i,Ee),a=n.pow(o,e),c=n.mul(i,a),s=n.mul(n.mul(c,Ee),a),f=n.mul(c,n.sub(s,n.ONE));if(!n.eql(n.sqr(f),i))throw new Error("Cannot find square root");return f}}return r%zr,Hr(r)}var Nr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Et(r){let e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Nr.reduce((n,i)=>(n[i]="function",n),e);return de(r,t)}function Cr(r,e,t){if(t<T)throw new Error("invalid exponent, negatives unsupported");if(t===T)return r.ONE;if(t===O)return e;let n=r.ONE,i=e;for(;t>T;)t&O&&(n=r.mul(n,i)),i=r.sqr(i),t>>=O;return n}function Dr(r,e){let t=new Array(e.length),n=e.reduce((o,a,c)=>r.is0(a)?o:(t[c]=o,r.mul(o,a)),r.ONE),i=r.inv(n);return e.reduceRight((o,a,c)=>r.is0(a)?o:(t[c]=r.mul(o,t[c]),r.mul(o,a)),i),t}function Kt(r,e){let t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function at(r,e,t=!1,n={}){if(r<=T)throw new Error("invalid field: expected ORDER > 0, got "+r);let{nBitLength:i,nByteLength:o}=Kt(r,e);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a,c=Object.freeze({ORDER:r,BITS:i,BYTES:o,MASK:Ve(i),ZERO:T,ONE:O,create:s=>N(s,r),isValid:s=>{if(typeof s!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof s);return T<=s&&s<r},is0:s=>s===T,isOdd:s=>(s&O)===O,neg:s=>N(-s,r),eql:(s,f)=>s===f,sqr:s=>N(s*s,r),add:(s,f)=>N(s+f,r),sub:(s,f)=>N(s-f,r),mul:(s,f)=>N(s*f,r),pow:(s,f)=>Cr(c,s,f),div:(s,f)=>N(s*st(f,r),r),sqrN:s=>s*s,addN:(s,f)=>s+f,subN:(s,f)=>s-f,mulN:(s,f)=>s*f,inv:s=>st(s,r),sqrt:n.sqrt||(s=>(a||(a=Rr(r)),a(c,s))),invertBatch:s=>Dr(c,s),cmov:(s,f,y)=>y?f:s,toBytes:s=>t?it(s,o):fe(s,o),fromBytes:s=>{if(s.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+s.length);return t?nt(s):te(s)}});return Object.freeze(c)}function Qt(r){if(typeof r!="bigint")throw new Error("field order must be bigint");let e=r.toString(2).length;return Math.ceil(e/8)}function At(r){let e=Qt(r);return e+Math.ceil(e/2)}function Jt(r,e,t=!1){let n=r.length,i=Qt(e),o=At(e);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);let a=t?te(r):nt(r),c=N(a,e-O)+O;return t?it(c,i):fe(c,i)}var Ft=BigInt(0),ct=BigInt(1);function Pt(r,e){let t=e.negate();return r?t:e}function er(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function St(r,e){er(r,e);let t=Math.ceil(e/r)+1,n=2**(r-1);return{windows:t,windowSize:n}}function jr(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function Mr(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}var Bt=new WeakMap,tr=new WeakMap;function kt(r){return tr.get(r)||1}function rr(r,e){return{constTimeNegate:Pt,hasPrecomputes(t){return kt(t)!==1},unsafeLadder(t,n,i=r.ZERO){let o=t;for(;n>Ft;)n&ct&&(i=i.add(o)),o=o.double(),n>>=ct;return i},precomputeWindow(t,n){let{windows:i,windowSize:o}=St(n,e),a=[],c=t,s=c;for(let f=0;f<i;f++){s=c,a.push(s);for(let y=1;y<o;y++)s=s.add(c),a.push(s);c=s.double()}return a},wNAF(t,n,i){let{windows:o,windowSize:a}=St(t,e),c=r.ZERO,s=r.BASE,f=BigInt(2**t-1),y=2**t,d=BigInt(t);for(let l=0;l<o;l++){let g=l*a,S=Number(i&f);i>>=d,S>a&&(S-=y,i+=ct);let m=g,u=g+Math.abs(S)-1,w=l%2!==0,x=S<0;S===0?s=s.add(Pt(w,n[m])):c=c.add(Pt(x,n[u]))}return{p:c,f:s}},wNAFUnsafe(t,n,i,o=r.ZERO){let{windows:a,windowSize:c}=St(t,e),s=BigInt(2**t-1),f=2**t,y=BigInt(t);for(let d=0;d<a;d++){let l=d*c;if(i===Ft)break;let g=Number(i&s);if(i>>=y,g>c&&(g-=f,i+=ct),g===0)continue;let S=n[l+Math.abs(g)-1];g<0&&(S=S.negate()),o=o.add(S)}return o},getPrecomputes(t,n,i){let o=Bt.get(n);return o||(o=this.precomputeWindow(n,t),t!==1&&Bt.set(n,i(o))),o},wNAFCached(t,n,i){let o=kt(t);return this.wNAF(o,this.getPrecomputes(o,t,i),n)},wNAFCachedUnsafe(t,n,i,o){let a=kt(t);return a===1?this.unsafeLadder(t,n,o):this.wNAFUnsafe(a,this.getPrecomputes(a,t,i),n,o)},setWindowSize(t,n){er(n,e),tr.set(t,n),Bt.delete(t)}}}function nr(r,e,t,n){if(jr(t,r),Mr(n,e),t.length!==n.length)throw new Error("arrays of points and scalars must have equal length");let i=r.ZERO,o=gt(BigInt(t.length)),a=o>12?o-3:o>4?o-2:o?2:1,c=(1<<a)-1,s=new Array(c+1).fill(i),f=Math.floor((e.BITS-1)/a)*a,y=i;for(let d=f;d>=0;d-=a){s.fill(i);for(let g=0;g<n.length;g++){let S=n[g],m=Number(S>>BigInt(d)&BigInt(c));s[m]=s[m].add(t[g])}let l=i;for(let g=s.length-1,S=i;g>0;g--)S=S.add(s[g]),l=l.add(S);if(y=y.add(l),d!==0)for(let g=0;g<a;g++)y=y.double()}return y}function It(r){return Et(r.Fp),de(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Kt(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}function ir(r){r.lowS!==void 0&&ge("lowS",r.lowS),r.prehash!==void 0&&ge("prehash",r.prehash)}function Vr(r){let e=It(r);de(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:t,Fp:n,a:i}=e;if(t){if(!n.eql(i,n.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}var{bytesToNumberBE:Zr,hexToBytes:Yr}=vt,re={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode:(r,e)=>{let{Err:t}=re;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");let n=e.length/2,i=ve(n);if(i.length/2&128)throw new t("tlv.encode: long form length too big");let o=n>127?ve(i.length/2|128):"";return ve(r)+o+i+e},decode(r,e){let{Err:t}=re,n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");let i=e[n++],o=!!(i&128),a=0;if(!o)a=i;else{let s=i&127;if(!s)throw new t("tlv.decode(long): indefinite length not supported");if(s>4)throw new t("tlv.decode(long): byte length is too big");let f=e.subarray(n,n+s);if(f.length!==s)throw new t("tlv.decode: length bytes not complete");if(f[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(let y of f)a=a<<8|y;if(n+=s,a<128)throw new t("tlv.decode(long): not minimal encoding")}let c=e.subarray(n,n+a);if(c.length!==a)throw new t("tlv.decode: wrong value length");return{v:c,l:e.subarray(n+a)}}},_int:{encode(r){let{Err:e}=re;if(r<ne)throw new e("integer: negative integers are not allowed");let t=ve(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){let{Err:e}=re;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Zr(r)}},toSig(r){let{Err:e,_int:t,_tlv:n}=re,i=typeof r=="string"?Yr(r):r;Te(i);let{v:o,l:a}=n.decode(48,i);if(a.length)throw new e("invalid signature: left bytes after parsing");let{v:c,l:s}=n.decode(2,o),{v:f,l:y}=n.decode(2,s);if(y.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(c),s:t.decode(f)}},hexFromSig(r){let{_tlv:e,_int:t}=re,n=e.encode(2,t.encode(r.r)),i=e.encode(2,t.encode(r.s)),o=n+i;return e.encode(48,o)}},ne=BigInt(0),H=BigInt(1),oo=BigInt(2),or=BigInt(3),so=BigInt(4);function Wr(r){let e=Vr(r),{Fp:t}=e,n=at(e.n,e.nBitLength),i=e.toBytes||((m,u,w)=>{let x=u.toAffine();return He(Uint8Array.from([4]),t.toBytes(x.x),t.toBytes(x.y))}),o=e.fromBytes||(m=>{let u=m.subarray(1),w=t.fromBytes(u.subarray(0,t.BYTES)),x=t.fromBytes(u.subarray(t.BYTES,2*t.BYTES));return{x:w,y:x}});function a(m){let{a:u,b:w}=e,x=t.sqr(m),v=t.mul(x,m);return t.add(t.add(v,t.mul(m,u)),w)}if(!t.eql(t.sqr(e.Gy),a(e.Gx)))throw new Error("bad generator point: equation left != right");function c(m){return Ge(m,H,e.n)}function s(m){let{allowedPrivateKeyLengths:u,nByteLength:w,wrapPrivateKey:x,n:v}=e;if(u&&typeof m!="bigint"){if(ue(m)&&(m=xe(m)),typeof m!="string"||!u.includes(m.length))throw new Error("invalid private key");m=m.padStart(w*2,"0")}let B;try{B=typeof m=="bigint"?m:te(G("private key",m,w))}catch{throw new Error("invalid private key, expected hex or "+w+" bytes, got "+typeof m)}return x&&(B=N(B,v)),le("private key",B,H,v),B}function f(m){if(!(m instanceof l))throw new Error("ProjectivePoint expected")}let y=ot((m,u)=>{let{px:w,py:x,pz:v}=m;if(t.eql(v,t.ONE))return{x:w,y:x};let B=m.is0();u==null&&(u=B?t.ONE:t.inv(v));let I=t.mul(w,u),P=t.mul(x,u),_=t.mul(v,u);if(B)return{x:t.ZERO,y:t.ZERO};if(!t.eql(_,t.ONE))throw new Error("invZ was invalid");return{x:I,y:P}}),d=ot(m=>{if(m.is0()){if(e.allowInfinityPoint&&!t.is0(m.py))return;throw new Error("bad point: ZERO")}let{x:u,y:w}=m.toAffine();if(!t.isValid(u)||!t.isValid(w))throw new Error("bad point: x or y not FE");let x=t.sqr(w),v=a(u);if(!t.eql(x,v))throw new Error("bad point: equation left != right");if(!m.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class l{constructor(u,w,x){if(this.px=u,this.py=w,this.pz=x,u==null||!t.isValid(u))throw new Error("x required");if(w==null||!t.isValid(w))throw new Error("y required");if(x==null||!t.isValid(x))throw new Error("z required");Object.freeze(this)}static fromAffine(u){let{x:w,y:x}=u||{};if(!u||!t.isValid(w)||!t.isValid(x))throw new Error("invalid affine point");if(u instanceof l)throw new Error("projective point not allowed");let v=B=>t.eql(B,t.ZERO);return v(w)&&v(x)?l.ZERO:new l(w,x,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){let w=t.invertBatch(u.map(x=>x.pz));return u.map((x,v)=>x.toAffine(w[v])).map(l.fromAffine)}static fromHex(u){let w=l.fromAffine(o(G("pointHex",u)));return w.assertValidity(),w}static fromPrivateKey(u){return l.BASE.multiply(s(u))}static msm(u,w){return nr(l,n,u,w)}_setWindowSize(u){S.setWindowSize(this,u)}assertValidity(){d(this)}hasEvenY(){let{y:u}=this.toAffine();if(t.isOdd)return!t.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){f(u);let{px:w,py:x,pz:v}=this,{px:B,py:I,pz:P}=u,_=t.eql(t.mul(w,P),t.mul(B,v)),A=t.eql(t.mul(x,P),t.mul(I,v));return _&&A}negate(){return new l(this.px,t.neg(this.py),this.pz)}double(){let{a:u,b:w}=e,x=t.mul(w,or),{px:v,py:B,pz:I}=this,P=t.ZERO,_=t.ZERO,A=t.ZERO,E=t.mul(v,v),R=t.mul(B,B),L=t.mul(I,I),U=t.mul(v,B);return U=t.add(U,U),A=t.mul(v,I),A=t.add(A,A),P=t.mul(u,A),_=t.mul(x,L),_=t.add(P,_),P=t.sub(R,_),_=t.add(R,_),_=t.mul(P,_),P=t.mul(U,P),A=t.mul(x,A),L=t.mul(u,L),U=t.sub(E,L),U=t.mul(u,U),U=t.add(U,A),A=t.add(E,E),E=t.add(A,E),E=t.add(E,L),E=t.mul(E,U),_=t.add(_,E),L=t.mul(B,I),L=t.add(L,L),E=t.mul(L,U),P=t.sub(P,E),A=t.mul(L,R),A=t.add(A,A),A=t.add(A,A),new l(P,_,A)}add(u){f(u);let{px:w,py:x,pz:v}=this,{px:B,py:I,pz:P}=u,_=t.ZERO,A=t.ZERO,E=t.ZERO,R=e.a,L=t.mul(e.b,or),U=t.mul(w,B),j=t.mul(x,I),h=t.mul(v,P),p=t.add(w,x),b=t.add(B,I);p=t.mul(p,b),b=t.add(U,j),p=t.sub(p,b),b=t.add(w,v);let K=t.add(B,P);return b=t.mul(b,K),K=t.add(U,h),b=t.sub(b,K),K=t.add(x,v),_=t.add(I,P),K=t.mul(K,_),_=t.add(j,h),K=t.sub(K,_),E=t.mul(R,b),_=t.mul(L,h),E=t.add(_,E),_=t.sub(j,E),E=t.add(j,E),A=t.mul(_,E),j=t.add(U,U),j=t.add(j,U),h=t.mul(R,h),b=t.mul(L,b),j=t.add(j,h),h=t.sub(U,h),h=t.mul(R,h),b=t.add(b,h),U=t.mul(j,b),A=t.add(A,U),U=t.mul(K,b),_=t.mul(p,_),_=t.sub(_,U),U=t.mul(p,j),E=t.mul(K,E),E=t.add(E,U),new l(_,A,E)}subtract(u){return this.add(u.negate())}is0(){return this.equals(l.ZERO)}wNAF(u){return S.wNAFCached(this,u,l.normalizeZ)}multiplyUnsafe(u){let{endo:w,n:x}=e;le("scalar",u,ne,x);let v=l.ZERO;if(u===ne)return v;if(this.is0()||u===H)return this;if(!w||S.hasPrecomputes(this))return S.wNAFCachedUnsafe(this,u,l.normalizeZ);let{k1neg:B,k1:I,k2neg:P,k2:_}=w.splitScalar(u),A=v,E=v,R=this;for(;I>ne||_>ne;)I&H&&(A=A.add(R)),_&H&&(E=E.add(R)),R=R.double(),I>>=H,_>>=H;return B&&(A=A.negate()),P&&(E=E.negate()),E=new l(t.mul(E.px,w.beta),E.py,E.pz),A.add(E)}multiply(u){let{endo:w,n:x}=e;le("scalar",u,H,x);let v,B;if(w){let{k1neg:I,k1:P,k2neg:_,k2:A}=w.splitScalar(u),{p:E,f:R}=this.wNAF(P),{p:L,f:U}=this.wNAF(A);E=S.constTimeNegate(I,E),L=S.constTimeNegate(_,L),L=new l(t.mul(L.px,w.beta),L.py,L.pz),v=E.add(L),B=R.add(U)}else{let{p:I,f:P}=this.wNAF(u);v=I,B=P}return l.normalizeZ([v,B])[0]}multiplyAndAddUnsafe(u,w,x){let v=l.BASE,B=(P,_)=>_===ne||_===H||!P.equals(v)?P.multiplyUnsafe(_):P.multiply(_),I=B(this,w).add(B(u,x));return I.is0()?void 0:I}toAffine(u){return y(this,u)}isTorsionFree(){let{h:u,isTorsionFree:w}=e;if(u===H)return!0;if(w)return w(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:u,clearCofactor:w}=e;return u===H?this:w?w(l,this):this.multiplyUnsafe(e.h)}toRawBytes(u=!0){return ge("isCompressed",u),this.assertValidity(),i(l,this,u)}toHex(u=!0){return ge("isCompressed",u),xe(this.toRawBytes(u))}}l.BASE=new l(e.Gx,e.Gy,t.ONE),l.ZERO=new l(t.ZERO,t.ONE,t.ZERO);let g=e.nBitLength,S=rr(l,e.endo?Math.ceil(g/2):g);return{CURVE:e,ProjectivePoint:l,normPrivateKeyToScalar:s,weierstrassEquation:a,isWithinCurveOrder:c}}function Xr(r){let e=It(r);return de(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function sr(r){let e=Xr(r),{Fp:t,n}=e,i=t.BYTES+1,o=2*t.BYTES+1;function a(h){return N(h,n)}function c(h){return st(h,n)}let{ProjectivePoint:s,normPrivateKeyToScalar:f,weierstrassEquation:y,isWithinCurveOrder:d}=Wr({...e,toBytes(h,p,b){let K=p.toAffine(),k=t.toBytes(K.x),z=He;return ge("isCompressed",b),b?z(Uint8Array.from([p.hasEvenY()?2:3]),k):z(Uint8Array.from([4]),k,t.toBytes(K.y))},fromBytes(h){let p=h.length,b=h[0],K=h.subarray(1);if(p===i&&(b===2||b===3)){let k=te(K);if(!Ge(k,H,t.ORDER))throw new Error("Point is not on curve");let z=y(k),D;try{D=t.sqrt(z)}catch(Z){let q=Z instanceof Error?": "+Z.message:"";throw new Error("Point is not on curve"+q)}let C=(D&H)===H;return(b&1)===1!==C&&(D=t.neg(D)),{x:k,y:D}}else if(p===o&&b===4){let k=t.fromBytes(K.subarray(0,t.BYTES)),z=t.fromBytes(K.subarray(t.BYTES,2*t.BYTES));return{x:k,y:z}}else{let k=i,z=o;throw new Error("invalid Point, expected length of "+k+", or uncompressed "+z+", got "+p)}}}),l=h=>xe(fe(h,e.nByteLength));function g(h){let p=n>>H;return h>p}function S(h){return g(h)?a(-h):h}let m=(h,p,b)=>te(h.slice(p,b));class u{constructor(p,b,K){this.r=p,this.s=b,this.recovery=K,this.assertValidity()}static fromCompact(p){let b=e.nByteLength;return p=G("compactSignature",p,b*2),new u(m(p,0,b),m(p,b,2*b))}static fromDER(p){let{r:b,s:K}=re.toSig(G("DER",p));return new u(b,K)}assertValidity(){le("r",this.r,H,n),le("s",this.s,H,n)}addRecoveryBit(p){return new u(this.r,this.s,p)}recoverPublicKey(p){let{r:b,s:K,recovery:k}=this,z=P(G("msgHash",p));if(k==null||![0,1,2,3].includes(k))throw new Error("recovery id invalid");let D=k===2||k===3?b+e.n:b;if(D>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");let C=k&1?"03":"02",$=s.fromHex(C+l(D)),Z=c(D),q=a(-z*Z),Ke=a(K*Z),ie=s.BASE.multiplyAndAddUnsafe($,q,Ke);if(!ie)throw new Error("point at infinify");return ie.assertValidity(),ie}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new u(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return _e(this.toDERHex())}toDERHex(){return re.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return _e(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}let w={isValidPrivateKey(h){try{return f(h),!0}catch{return!1}},normPrivateKeyToScalar:f,randomPrivateKey:()=>{let h=At(e.n);return Jt(e.randomBytes(h),e.n)},precompute(h=8,p=s.BASE){return p._setWindowSize(h),p.multiply(BigInt(3)),p}};function x(h,p=!0){return s.fromPrivateKey(h).toRawBytes(p)}function v(h){let p=ue(h),b=typeof h=="string",K=(p||b)&&h.length;return p?K===i||K===o:b?K===2*i||K===2*o:h instanceof s}function B(h,p,b=!0){if(v(h))throw new Error("first arg must be private key");if(!v(p))throw new Error("second arg must be public key");return s.fromHex(p).multiply(f(h)).toRawBytes(b)}let I=e.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");let p=te(h),b=h.length*8-e.nBitLength;return b>0?p>>BigInt(b):p},P=e.bits2int_modN||function(h){return a(I(h))},_=Ve(e.nBitLength);function A(h){return le("num < 2^"+e.nBitLength,h,ne,_),fe(h,e.nByteLength)}function E(h,p,b=R){if(["recovered","canonical"].some(he=>he in b))throw new Error("sign() legacy options not supported");let{hash:K,randomBytes:k}=e,{lowS:z,prehash:D,extraEntropy:C}=b;z==null&&(z=!0),h=G("msgHash",h),ir(b),D&&(h=G("prehashed msgHash",K(h)));let $=P(h),Z=f(p),q=[A(Z),A($)];if(C!=null&&C!==!1){let he=C===!0?k(t.BYTES):C;q.push(G("extraEntropy",he))}let Ke=He(...q),ie=$;function lt(he){let Ae=I(he);if(!d(Ae))return;let dt=c(Ae),Re=s.BASE.multiply(Ae).toAffine(),ye=a(Re.x);if(ye===ne)return;let Ne=a(dt*a(ie+ye*Z));if(Ne===ne)return;let Pe=(Re.x===ye?0:2)|Number(Re.y&H),zt=Ne;return z&&g(Ne)&&(zt=S(Ne),Pe^=1),new u(ye,zt,Pe)}return{seed:Ke,k2sig:lt}}let R={lowS:e.lowS,prehash:!1},L={lowS:e.lowS,prehash:!1};function U(h,p,b=R){let{seed:K,k2sig:k}=E(h,p,b),z=e;return xt(z.hash.outputLen,z.nByteLength,z.hmac)(K,k)}s.BASE._setWindowSize(8);function j(h,p,b,K=L){let k=h;p=G("msgHash",p),b=G("publicKey",b);let{lowS:z,prehash:D,format:C}=K;if(ir(K),"strict"in K)throw new Error("options.strict was renamed to lowS");if(C!==void 0&&C!=="compact"&&C!=="der")throw new Error("format must be compact or der");let $=typeof k=="string"||ue(k),Z=!$&&!C&&typeof k=="object"&&k!==null&&typeof k.r=="bigint"&&typeof k.s=="bigint";if(!$&&!Z)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let q,Ke;try{if(Z&&(q=new u(k.r,k.s)),$){try{C!=="compact"&&(q=u.fromDER(k))}catch(Pe){if(!(Pe instanceof re.Err))throw Pe}!q&&C!=="der"&&(q=u.fromCompact(k))}Ke=s.fromHex(b)}catch{return!1}if(!q||z&&q.hasHighS())return!1;D&&(p=e.hash(p));let{r:ie,s:lt}=q,he=P(p),Ae=c(lt),dt=a(he*Ae),Re=a(ie*Ae),ye=s.BASE.multiplyAndAddUnsafe(Ke,dt,Re)?.toAffine();return ye?a(ye.x)===ie:!1}return{CURVE:e,getPublicKey:x,getSharedSecret:B,sign:U,verify:j,ProjectivePoint:s,Signature:u,utils:w}}function $r(r){return{hash:r,hmac:(e,...t)=>Me(r,e,jt(...t)),randomBytes:Gt}}function ar(r,e){let t=n=>sr({...r,...$r(n)});return Object.freeze({...t(e),create:t})}var fr=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),cr=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Qr=BigInt(1),Ut=BigInt(2),ur=(r,e)=>(r+e/Ut)/e;function Jr(r){let e=fr,t=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),a=BigInt(23),c=BigInt(44),s=BigInt(88),f=r*r*r%e,y=f*f*r%e,d=V(y,t,e)*y%e,l=V(d,t,e)*y%e,g=V(l,Ut,e)*f%e,S=V(g,i,e)*g%e,m=V(S,o,e)*S%e,u=V(m,c,e)*m%e,w=V(u,s,e)*u%e,x=V(w,c,e)*m%e,v=V(x,t,e)*y%e,B=V(v,a,e)*S%e,I=V(B,n,e)*f%e,P=V(I,Ut,e);if(!Lt.eql(Lt.sqr(P),r))throw new Error("Cannot find square root");return P}var Lt=at(fr,void 0,void 0,{sqrt:Jr}),Ze=ar({a:BigInt(0),b:BigInt(7),Fp:Lt,n:cr,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{let e=cr,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Qr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,a=BigInt("0x100000000000000000000000000000000"),c=ur(o*r,e),s=ur(-n*r,e),f=N(r-c*t-s*i,e),y=N(-c*n-s*o,e),d=f>a,l=y>a;if(d&&(f=e-f),l&&(y=e-y),f>a||y>a)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:d,k1:f,k2neg:l,k2:y}}}},et),po=BigInt(0);var bo=Ze.ProjectivePoint;var ut="ECDH",ft=class{constructor(e){Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=e,this._nPk=33,this._nSk=32}async serializePublicKey(e){try{return await this._serializePublicKey(e)}catch(t){throw new J(t)}}async deserializePublicKey(e){try{return await this._importRawKey(e,!0)}catch(t){throw new W(t)}}async serializePrivateKey(e){try{return await this._serializePrivateKey(e)}catch(t){throw new J(t)}}async deserializePrivateKey(e){try{return await this._importRawKey(e,!1)}catch(t){throw new W(t)}}async importKey(e,t,n){try{if(e!=="raw")throw new Error("Unsupported format");return await this._importRawKey(t,n)}catch(i){throw new W(i)}}async generateKeyPair(){try{let e=Ze.utils.randomPrivateKey(),t=new X(ut,e,"private",be);return{publicKey:await this.derivePublicKey(t),privateKey:t}}catch(e){throw new F(e)}}async deriveKeyPair(e){try{let t=await this._hkdf.labeledExtract(M,Ie,new Uint8Array(e)),n=await this._hkdf.labeledExpand(t,De,M,this._nSk),i=new X(ut,new Uint8Array(n),"private",be);return{privateKey:i,publicKey:await this.derivePublicKey(i)}}catch(t){throw new Se(t)}}async derivePublicKey(e){try{return await this._derivePublicKey(e)}catch(t){throw new W(t)}}async dh(e,t){try{return await this._dh(e,t)}catch(n){throw new J(n)}}_serializePublicKey(e){return new Promise(t=>{t(e.key.buffer)})}_serializePrivateKey(e){return new Promise(t=>{t(e.key.buffer)})}_importRawKey(e,t){return new Promise((n,i)=>{t&&e.byteLength!==this._nPk&&i(new Error("Invalid length of the key")),!t&&e.byteLength!==this._nSk&&i(new Error("Invalid length of the key")),n(new X(ut,new Uint8Array(e),t?"public":"private",t?[]:be))})}_derivePublicKey(e){return new Promise((t,n)=>{try{let i=Ze.getPublicKey(e.key);t(new X(ut,i,"public"))}catch(i){n(i)}})}_dh(e,t){return new Promise((n,i)=>{try{n(Ze.getSharedSecret(e.key,t.key).buffer)}catch(o){i(o)}})}};var Ot=class extends ke{constructor(){let e=new ze;super(oe.DhkemSecp256k1HkdfSha256,new ft(e),e),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:oe.DhkemSecp256k1HkdfSha256}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:33}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:32})}};export{Ot as DhkemSecp256k1HkdfSha256};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
